<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="计算机网络运输层"><meta name="keywords" content="计算机网络,运输层"><meta name="author" content="luo,1127959736@qq.com"><meta name="copyright" content="luo"><title>计算机网络运输层 | luo's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="luo's Blog" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%BF%90%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0"><span class="toc-text"> 1 运输层协议概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%BF%90%E8%BE%93%E5%B1%82"><span class="toc-text"> 1.1 为什么需要运输层？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E8%BF%90%E8%BE%93%E5%B1%82%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8A%9F%E8%83%BD"><span class="toc-text"> 1.2 运输层的一些功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#121-%E5%A4%8D%E7%94%A8%E5%92%8C%E5%88%86%E7%94%A8"><span class="toc-text"> 1.2.1 复用和分用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#122-%E8%BF%90%E8%BE%93%E5%B1%82%E6%8F%90%E4%BE%9B%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%BB%E8%BE%91%E9%80%9A%E4%BF%A1"><span class="toc-text"> 1.2.2 运输层提供应用进程间的逻辑通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#123-%E6%8F%90%E4%BE%9B%E5%8F%AF%E9%9D%A0%E5%92%8C%E4%B8%8D%E5%8F%AF%E9%9D%A0%E4%B8%A4%E7%A7%8D%E4%BF%A1%E9%81%93"><span class="toc-text"> 1.2.3 提供可靠和不可靠两种信道</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E8%BF%90%E8%BE%93%E5%B1%82%E7%9A%84%E4%B8%A4%E4%B8%AA%E4%B8%BB%E8%A6%81%E5%8D%8F%E8%AE%AE"><span class="toc-text"> 1.3 运输层的两个主要协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E8%BF%90%E8%BE%93%E5%B1%82%E7%9A%84%E7%AB%AF%E5%8F%A3"><span class="toc-text"> 1.4 运输层的端口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#141-%E4%BB%80%E4%B9%88%E6%98%AF%E7%AB%AF%E5%8F%A3"><span class="toc-text"> 1.4.1 什么是端口？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#142-%E7%AB%AF%E5%8F%A3%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text"> 1.4.2 端口的工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#143-%E8%BF%90%E8%BE%93%E5%B1%82%E7%AB%AF%E5%8F%A3%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text"> 1.4.3 运输层端口的分类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AEudp"><span class="toc-text"> 2 用户数据报协议UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-udp-%E6%A6%82%E8%BF%B0"><span class="toc-text"> 2.1 UDP 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-udp%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="toc-text"> 2.2 UDP的首部格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AEtcp%E6%A6%82%E8%BF%B0"><span class="toc-text"> 3 传输控制协议TCP概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#31-tcp%E6%9C%80%E4%B8%BB%E8%A6%81%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text"> 3.1 TCP最主要的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-tcp%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="toc-text"> 3.2 TCP的连接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text"> 4 可靠传输的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#41-%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE"><span class="toc-text"> 4.1 停止等待协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#411-%E6%97%A0%E5%B7%AE%E9%94%99%E6%83%85%E5%86%B5"><span class="toc-text"> 4.1.1 无差错情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#412-%E5%87%BA%E7%8E%B0%E5%B7%AE%E9%94%99"><span class="toc-text"> 4.1.2 出现差错</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#413-%E7%A1%AE%E8%AE%A4%E4%B8%A2%E5%A4%B1%E5%92%8C%E7%A1%AE%E8%AE%A4%E8%BF%9F%E5%88%B0"><span class="toc-text"> 4.1.3 确认丢失和确认迟到</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#414-%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87"><span class="toc-text"> 4.1.4 信道利用率</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-%E8%BF%9E%E7%BB%ADarq%E5%8D%8F%E8%AE%AE"><span class="toc-text"> 4.2 连续ARQ协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-tcp%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="toc-text"> 5 TCP报文段的首部格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-tcp%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 6 TCP可靠传输的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#61-%E4%BB%A5%E5%AD%97%E8%8A%82%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-text"> 6.1 以字节为单位的滑动窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62-%E7%AA%97%E5%8F%A3%E4%B8%8E%E7%BC%93%E5%AD%98%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text"> 6.2 窗口与缓存的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text"> 6.3 超时重传时间的选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64-%E9%80%89%E6%8B%A9%E7%A1%AE%E8%AE%A4sack"><span class="toc-text"> 6.4 选择确认SACK</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-tcp%E7%9A%84%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="toc-text"> 7 TCP的运输连接管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#71-tcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B"><span class="toc-text"> 7.1 TCP的连接建立</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#72-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8Ba%E6%9C%80%E5%90%8E%E8%BF%98%E8%A6%81%E5%8F%91%E9%80%81%E4%B8%80%E6%AC%A1%E7%A1%AE%E8%AE%A4"><span class="toc-text"> 7.2 为什么连接建立，A最后还要发送一次确认？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#73-tcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E9%87%8A%E6%94%BE"><span class="toc-text"> 7.3 TCP的连接释放</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-tcp%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-text"> 8 TCP的流量控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#81-%E5%88%A9%E7%94%A8%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-text"> 8.1 利用滑动窗口实现流量控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#82-tcp-%E7%9A%84%E4%BC%A0%E8%BE%93%E6%95%88%E7%8E%87"><span class="toc-text"> 8.2 TCP 的传输效率</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-tcp%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-text"> 9 TCP的拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#91-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%9A%84%E4%B8%80%E8%88%AC%E5%8E%9F%E7%90%86"><span class="toc-text"> 9.1 拥塞控制的一般原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#911%E8%BF%99%E9%87%8C%E8%BE%A8%E5%88%AB%E4%B8%80%E4%B8%8B%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text"> 9.1.1这里辨别一下拥塞控制和流量控制的关系：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#912-%E7%90%86%E6%83%B3%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%92%8C%E5%AE%9E%E9%99%85%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%AF%B9%E6%AF%94"><span class="toc-text"> 9.1.2 理想拥塞控制和实际拥塞控制对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#913-%E5%BC%80%E7%8E%AF%E6%8E%A7%E5%88%B6%E5%92%8C%E9%97%AD%E7%8E%AF%E6%8E%A7%E5%88%B6"><span class="toc-text"> 9.1.3 开环控制和闭环控制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#92-tcp%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95"><span class="toc-text"> 9.2 TCP的拥塞控制方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#921-%E6%85%A2%E5%BC%80%E5%A7%8B%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-text"> 9.2.1 慢开始算法原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#922-%E6%85%A2%E5%BC%80%E5%A7%8B%E9%97%A8%E9%99%90ssthresh"><span class="toc-text"> 9.2.2 慢开始门限ssthresh</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#923-%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-text"> 9.2.3 拥塞避免算法原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#924-%E5%BF%AB%E9%87%8D%E4%BC%A0"><span class="toc-text"> 9.2.4 快重传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#925-%E5%BF%AB%E6%81%A2%E5%A4%8D"><span class="toc-text"> 9.2.5 快恢复</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E6%80%BB%E7%BB%93jiade"><span class="toc-text"> 10 总结(jiade)</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/touxiang.jpg"></div><div class="author-info__name text-center">luo</div><div class="author-info__description text-center">在一群优秀的人中间，常常以为自己是他们一员，然后忘了努力</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">18</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">16</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">3</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://m0d1.top">mod1</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://c10udlnk.top">c10udlnk</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.fxizenta.design/">Fxizenta</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://mclaren888.cn">Mclaren</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://dzcgood.xyz/">DzcGood</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://imcomma.top/">imcomma</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/background3.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">luo's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">luo</a><a class="site-page" href="/archives">时间线</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">计算机网络运输层</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-06-18</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">17.9k</span><span class="post-meta__separator">|</span><span>阅读时长: 55 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>本文巨长且干货极少，<strong>阅读请谨慎</strong>！！！！</p>
<h2 id="1-运输层协议概述"><a class="markdownIt-Anchor" href="#1-运输层协议概述"></a> 1 运输层协议概述</h2>
<h3 id="11-为什么需要运输层"><a class="markdownIt-Anchor" href="#11-为什么需要运输层"></a> 1.1 为什么需要运输层？</h3>
<p>和之前介绍的层次一样，在开始之前，我们需要<strong>先知道为什么需要运输层</strong>？</p>
<p>我们知道现代操作系统，都是支持&quot;多任务&quot;的操作系统。“多任务&quot;简单的说就是操作系统可以同时运行多个任务，比如你可以一边在用浏览器上网，一边打开网易云听歌，一边用Word赶作业。</p>
<p>那么操作系统如何实现这种”多任务“呢？答案就是操作系统轮流让各个任务交替执行,但是因为CPU太快了，给我们的感受就是所有任务都在同时执行。对于操作系统而言，一个任务就是一个<strong>进程(Process)</strong>,</p>
<p>这里提到<strong>进程</strong>，我们知道，计算机网络体系结构中的<strong>物理层</strong>，<strong>数据链路层</strong>以及<strong>网络层</strong>它们要解决的问题是在网络互联的情况下，如何<strong>实现主机到主机的通信</strong>。</p>
<p>然而，真正在计算机网络中进行的通信是<strong>位于通信两端主机中的进程</strong>之间的通信，是一台主机中的<strong>一个进程</strong>和另一台主机中的<strong>另一个进程</strong>在交换数据(也就是通信)。</p>
<span id="more"></span>
<p>IP协议能把分组送到目的主机，但是这个分组只是停留在目的主机的网络层而不知道交付给主机中的哪一个进程，而运输层就是来解决<strong>交付给哪个进程的问题</strong>。</p>
<p>从运输层的角度看：</p>
<blockquote>
<p><strong>通信的真正端点并不是主机而是主机中的进程</strong>。</p>
</blockquote>
<p>比如说在一台主机上经常有多个进程<strong>同时分别</strong>和另一台主机上的多个进程通信。例如，你在使用浏览器查找某网站的信息时，你的主机应用层运行浏览器客户进程。如果你在浏览网页的同时，还使用了电子邮件给网站发送反馈意见，那么你的主机的应用层还要运行电子邮件的客户进程。</p>
<h3 id="12-运输层的一些功能"><a class="markdownIt-Anchor" href="#12-运输层的一些功能"></a> 1.2 运输层的一些功能</h3>
<h4 id="121-复用和分用"><a class="markdownIt-Anchor" href="#121-复用和分用"></a> 1.2.1 复用和分用</h4>
<p>如图5-1 主机A的应用进程AP1和主机B的应用进程AP3通信，<strong>与此同时</strong>，主机A应用进程AP2也和对方的应用进程AP4通信。比如说你和朋友在微信聊天，这时突然你要传输一个大文件给朋友，微信实现不了，所以你打开了QQ向朋友传大文件，QQ传输文件的同时，你继续和朋友聊天。</p>
<p>这表明了运输层有很重要的功能<strong>复用(multiplexing)<strong>和</strong>分用(demultiplexing)</strong>。</p>
<ul>
<li>
<p><strong>复用</strong>指发送方<strong>不同的应用进程</strong>都可以使用<strong>同一个运输协议</strong>传送数据。</p>
</li>
<li>
<p><strong>分用</strong>指接收方的运输层在剥去报文的首部后<strong>能够把这些数据正确交付目的应用进程</strong>。</p>
<img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_1.jpg" style="zoom: 25%;">
</li>
</ul>
<h4 id="122-运输层提供应用进程间的逻辑通信"><a class="markdownIt-Anchor" href="#122-运输层提供应用进程间的逻辑通信"></a> 1.2.2 运输层提供应用进程间的逻辑通信</h4>
<blockquote>
<p>运输层提供应用进程间的<strong>逻辑通信</strong></p>
</blockquote>
<p><strong>逻辑通信</strong>的意思是：从应用层来看，只要把应用层的报文交给下面的<strong>运输层</strong>，运输层就可以把这报文传送到对方的运输层(应用层根本不管对方有多远，报文怎么发过去的，下层协议怎么实现的，就只是告诉运输层，你帮我把报文送到某某的运输层，本机运输层就一定可以将报文送到)，就好像这种通信就是<strong>沿着水平方向直接传送数据</strong>，但事实上我们知道，<strong>两个运输层之间根本不存在这样一条水平方向的物理链路</strong>，报文的传送还是要沿着图中的虚线方向经过多个层次才能传送到目的主机的运输层。</p>
<p>逻辑通信的意思是”好像是这样通信，事实上并非如此“。</p>
<p>这里就可以看出网络层和运输层的区别了：</p>
<blockquote>
<p>网络层为<strong>主机</strong>之间提供了逻辑通信，而运输层为应用<strong>进程</strong>之间提供端到端的逻辑通信。</p>
</blockquote>
<p>如图5-2：</p>
<img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_2.jpg" style="zoom: 25%;">
<h4 id="123-提供可靠和不可靠两种信道"><a class="markdownIt-Anchor" href="#123-提供可靠和不可靠两种信道"></a> 1.2.3 提供可靠和不可靠两种信道</h4>
<p>我们知道，数据链路层提供的是<strong>无差错传输</strong>，不是<strong>可靠运输</strong>，网络层IP数据报首部中的检验和字段，只检验首部是否出现差错而不检查数据部分。</p>
<p>根据应用程序的不同需求，运输层可以使用两种不同的运输协议，即<strong>面向连接的TCP</strong> 和 <strong>无连接的UDP</strong>。 当运输层采用<strong>面向连接的TCP</strong>协议时，尽管下面的网络是不可靠的，但这种逻辑通信信道就相当于<strong>一条全双工的可靠信道</strong>。但当运输层采用<strong>无连接的UDP协议</strong>时，这种逻辑通信信道就仍然是<strong>不可靠信道</strong>。</p>
<h3 id="13-运输层的两个主要协议"><a class="markdownIt-Anchor" href="#13-运输层的两个主要协议"></a> 1.3 运输层的两个主要协议</h3>
<p>**(1)用户数据报协议UDP **: User Datagram Protocol</p>
<p><strong>(2)传输控制协议TCP</strong>:  Transmission Control Protocol</p>
<p>图5-3给出了这两种协议在协议栈的位置</p>
<img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_3.jpg" style="zoom: 25%;">
<p>在TCP/IP体系中，根据所使用的协议是TCP或UDP，分别称两个对等运输实体在通信时<strong>传送的数据单位</strong>为<strong>TCP报文段(segment)<strong>或</strong>UDP用户数据报</strong>。</p>
<p>UDP在传送数据之前<strong>不需要先建立连接</strong>，目的主机的运输层收到UDP报文后，<strong>不需要给出任何确认</strong>。虽然UDP不提供可靠服务，但在某些应用下，UDP是非常有效的工作方式，因为UDP比较快，效率高。比如说<strong>视频通信</strong>，在通信中，一些视频帧的丢失我们是可以接受的，但我们要保证的是通信的流畅度和延迟低。</p>
<p>TCP则提供<strong>面向连接的服务</strong>，在传送数据之<strong>前先建立连接</strong>，数据传送<strong>结束后要释放连接</strong>。<strong>TCP不提供广播或多播服务</strong>。正因为TCP要提供<strong>可靠的</strong>，<strong>面向连接</strong>的运输服务，因此不可避免地增加了许多的开销。</p>
<p>表5-1 给出了一些应用和应用层协议主要使用的运输层协议</p>
<img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_4.jpg" style="zoom: 20%;">
<h3 id="14-运输层的端口"><a class="markdownIt-Anchor" href="#14-运输层的端口"></a> 1.4 运输层的端口</h3>
<h4 id="141-什么是端口"><a class="markdownIt-Anchor" href="#141-什么是端口"></a> 1.4.1 什么是端口？</h4>
<p>前面我们提到了<strong>复用</strong>和<strong>分用</strong>：</p>
<blockquote>
<ul>
<li>
<p><strong>复用</strong>指发送方<strong>不同的应用进程</strong>都可以使用<strong>同一个运输协议</strong>传送数据。</p>
</li>
<li>
<p><strong>分用</strong>指接收方的运输层在剥去报文的首部后<strong>能够把这些数据正确交付目的应用进程</strong>。</p>
</li>
</ul>
</blockquote>
<p>举一个日常生活中复用和分用的简单的例子，假定一个学校向其他学校发出的信都由该学校的收发室负责寄出，这相当学校里的每个院系都要<strong>复用</strong>这个收发室，而当学校收发室收到信后，根据信的收件地址，将信具体送给对应的院系，这叫是<strong>分用</strong>。</p>
<p>运输层上的复用和分用功能也是类似的。应用层所有的应用进程都可以通过运输层再传送到网络层，这就是<strong>复用</strong>，运输层就相当于<strong>收发室</strong>，而运输层收到IP层发送给各应用的数据后，必须分别交付指明的各应用进程，这就是<strong>分用</strong>。那么运输层如何找到对应的各应用进程呢？答案是<strong>给应用层的每个应用进程赋予一个非常明确的标志</strong>。</p>
<p>我们知道，在单个计算机中的进程我们是用<strong>进程标识符</strong>来标志的。然而不同的操作系统使用的进程标识符格式是不同的，为了使运行不同的操作系统的计算机的应用进程能够实现通信，需要用一种<strong>统一的方法来标识进程</strong>，而这种方法与特定操作系统必须无关。</p>
<p>但是，把一个特定机器上运行的特定进程，指明为互联网通信上的最后终点还是<strong>不可行</strong>的，因为我们知道，进程的创建和撤销是<strong>动态的</strong>，新建一个进程就会给出一个新的进程号，通信的一方几乎无法识别对方机器上的进程，我们往往需要利用目的主机提供的功能来识别终点，而不需要知道具体实现这个功能的进程是哪一个。</p>
<p>解决问题的方法就是在<strong>运输层使用协议端口号(protocol port number)</strong>，也通常成为<strong>端口(port)</strong>。也就是说，我们不直接把目的主机上的某个进程作为终点(事实上也无法这样做，因为源主机无法识别进程)，而只要将所传送的报文送到目的主机上<strong>某个合适的端口</strong>，至于最后交付给目的进程，就由TCP或UDP来实现。</p>
<p>注意<strong>软件端口和硬件端口的区别</strong>：</p>
<blockquote>
<p>在这种<strong>协议栈层间的抽象的协议端口</strong>是<strong>软件端口</strong>。而在路由器或交换机上的<strong>硬件端口</strong>是不同硬件设备之间的接口。<strong>软件端口</strong>相当于是应用层的各种协议进程与运输实体进行层间交互的一种<strong>地址</strong>。</p>
</blockquote>
<h4 id="142-端口的工作原理"><a class="markdownIt-Anchor" href="#142-端口的工作原理"></a> 1.4.2 端口的工作原理</h4>
<p>当运输层收到IP层交上来的运输层报文时，就可以根据其首部中的<strong>目的端口号</strong>把数据交付应用层中的<strong>目的应用进程</strong>。</p>
<p>TCP/IP 的运输层用一个<strong>16位端口号</strong>来标志一个端口，注意的是：<strong>端口号只具有本地意义</strong>，它只是为了标志<strong>本计算机</strong>应用层中各个进程在和运输层交互的一个接口。在不同的计算机中，相同的端口号是<strong>没有关联的</strong>。</p>
<p>由此可见，两个计算机中的进程要互相通信，不仅仅必须知道目的主机的IP地址(<strong>网络层以下的层需要依靠IP地址找到目的主机</strong>)，而且要知道对方的<strong>端口号</strong>(运输层要依据端口号找到目的主机中的应用进程)。</p>
<p>举一个寄信的例子，我们给某人写信，必须写上他的住所地址(为了找到他的家庭地址，<strong>相当于IP地址</strong>)，还要写上收件人的名字(相当于<strong>端口号</strong>)，因为一个住所可能有多个人住，只有写上收件人的姓名，才知道把信给谁。</p>
<h4 id="143-运输层端口的分类"><a class="markdownIt-Anchor" href="#143-运输层端口的分类"></a> 1.4.3 运输层端口的分类</h4>
<p>运输层的端口号分为下面的两大类。</p>
<p><strong>(1) 服务器端使用的端口号</strong>：服务器使用的端口号又分为两类，分别是：</p>
<ul>
<li><strong>熟知端口号</strong>或<strong>系统端口号</strong>： 数值为0~1023，LANA把这些端口号指派给了TCP/IP最重要的一些应用程序，让所有用户都知道。如表5-2：</li>
<li><strong>登记端口号</strong>：数值为1024~49151 为没有熟知端口号的应用程序使用的，需防止重复。</li>
</ul>
<p><strong>(2)</strong> <strong>客户端使用的端口号</strong>：数值为49152~65535。这类端口号仅在用户进程运行时才<strong>动态选择</strong>，又叫做<strong>短暂端口号</strong>。这类端口号留给客户进程选择<strong>暂时使用</strong>，通信结束后，这个端口号就可以供其他客户进程使用。</p>
<img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_5.jpg" style="zoom: 20%;">
<h2 id="2-用户数据报协议udp"><a class="markdownIt-Anchor" href="#2-用户数据报协议udp"></a> 2 用户数据报协议UDP</h2>
<h3 id="21-udp-概述"><a class="markdownIt-Anchor" href="#21-udp-概述"></a> 2.1 UDP 概述</h3>
<p><strong>UDP</strong>的主要特点是：</p>
<p>(1) UDP是<strong>无连接</strong>的 发送数据之前不需要建立连接，当然结束时也不需要释放连接。</p>
<p>(2) UDP使用<strong>尽最大努力交付</strong>，同样是<strong>不可靠交付</strong>。</p>
<p>(3) UDP是<strong>面向报文</strong>的。发送方的UDP对应用程序交下来的报文，在<strong>添加首部后就向下交付IP层</strong>。UDP对应用层交下来的报文，<strong>不合并，也不拆分</strong>，<strong>保留这些报文的边界</strong>。也就是说，应用层交给UDP多长的报文，UDP照样发送，即一次发送一个报文。<br>
如图5-4所示，接收方的UDP对IP层交上来的UDP用户数据报，在<strong>去除首部后就原封不动地交付上层</strong>的应用进程，也就是说，UDP一次交付一个完整的报文。<br>
这就要求应用程序必须选择<strong>合适大小的报文</strong>，如果报文太长，IP层在传送时可能要进行分片，这降低了IP层的效率，如果太短，IP数据报的首部的相对长度太大，这也降低了IP层的效率。</p>
<img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_6.jpg" style="zoom: 20%;">
<p>(4) UDP<strong>没有拥塞控制</strong>：网络中出现的拥塞不会使源主机的发送速率降低。对于很多实时应用比如IP电话，实时视频会议要求源主机以恒定的速率发送数据，并且允许在网络发生拥塞时丢失一些数据，但不能有太大的时延，UDP是非常适合的。但这样也有可能引起网络产生严重的拥塞问题。</p>
<p>(5) UDP支持<strong>一对一，一对多，多对一和多对多的交互通信</strong>。</p>
<p>(6) UDP的<strong>首部开销小</strong>，只有8个字节。</p>
<h3 id="22-udp的首部格式"><a class="markdownIt-Anchor" href="#22-udp的首部格式"></a> 2.2 UDP的首部格式</h3>
<p>如图5-5，用户数据报UDP有两个字段：<strong>数据字段</strong>和<strong>首部字段</strong>。首部字段很简单，只有8个字节，由<strong>四个字段</strong>组成，<strong>每个字段的长度都是两个字节</strong>，各字段的意义如下：</p>
<ul>
<li><strong>源端口</strong>：源端口号，在需要对方回信时选用，不需要可用全0</li>
<li><strong>目的端口</strong>：目的端口号，这在终点交付报文时必须使用。</li>
<li><strong>长度</strong> UDP用户数据报的长度，最小值为8(<strong>仅有首部</strong>的情况)</li>
<li><strong>检验和</strong>： 检测UDP用户数据报在传输中是否有错，有错就丢弃。</li>
</ul>
<img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_7.jpg" style="zoom: 20%;">
<p>当运输层从IP层收到UDP数据报时，就根据数据报中的<strong>目的端口</strong>，把UDP数据报通过相应的端口，上交到目的应用进程，如图5-6：</p>
<img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_8.jpg" style="zoom: 20%;">
<p>如果接收方UDP发现收到的报文的<strong>目的端口不正确</strong>，也就是不存在对应于该端口号的应用进程，就丢弃该报文，并由网际控制报文协议ICMP发送&quot;<strong>端口不可达</strong>&quot;差错报文给发送方。比如我们熟悉的traceroute实现原理就是发送一个不可交付的UDP报文，该报文故意使用一个非法的<strong>UDP端口</strong>，结果ICMP就返回<strong>端口不可达</strong>差错报文，达到跟踪路径的目的。</p>
<p>UDP用户数据报首部检验和的计算：</p>
<p>UDP用户数据报首部中计算检验和时，要在UDP用户数据报之前添加<strong>12字节的伪首部</strong>。所谓“伪首部”并<strong>不是</strong>UDP用户数据报<strong>真正的首部</strong>，只是在计算检验和时临时添加到UDP用户数据包前面，得到一个<strong>临时的UDP数据报</strong>，再根据这个数据报去<strong>计算检验和</strong>，伪首部仅仅是为了计算检验和。</p>
<p>UDP计算校验和的方法和计算IP数据报首部检验和的方法相似，不同的是IP数据报的检验和<strong>只检验IP数据报的首部</strong>，而UDP的检验和是<strong>把首部和数据部分一起都检验</strong>。</p>
<p>具体的检验方法是：</p>
<p>在发送方，先将检验和字段置为全0，再把伪首部已经UDP用户数据报看成是由许多16位的字串连接起来的。如果UDP用户数据报的数据部分<strong>不是偶数个字节</strong>，则要填入一个全0字节。(注意，此字节不发送，只是为了求检验和)，然后按<strong>二进制反码计算出这些16位字的和</strong>，将<strong>和</strong>的<strong>二进制反码</strong>写入检验和字段后，就发送UDP用户数据报。</p>
<p>在接收方，把收到的UDP用户数据报连通伪首部(以及可能的填充全0字节)一起，按二进制反码求这些16位字的和，当无差错时其结果应为全1(求反码时为全0)，否则就表明有差错出现。</p>
<p>接收方一遇到差错，就丢弃这个UDP用户数据报(也可以上交应用层，但附上出现了差错的警告)。</p>
<p>如图5-7给出了一个<strong>计算UDP检验和的例子</strong>：</p>
<img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_9.jpg" style="zoom: 20%;">
<h2 id="3-传输控制协议tcp概述"><a class="markdownIt-Anchor" href="#3-传输控制协议tcp概述"></a> 3 传输控制协议TCP概述</h2>
<p>好复杂的协议，头大…算了算了一步步学吧~</p>
<h3 id="31-tcp最主要的特点"><a class="markdownIt-Anchor" href="#31-tcp最主要的特点"></a> 3.1 TCP最主要的特点</h3>
<ol>
<li>
<p>TCP是<strong>面向连接的运输层协议</strong>：应用程序在使用TCP协议之前，必须先建立TCP连接，传送数据完毕后，必须释放已经建立的TCP连接。</p>
</li>
<li>
<p>每一条TCP连接只能有两个<strong>端点(endpoint)</strong>。每一条TCP连接只能是<strong>点对点</strong>的。</p>
</li>
<li>
<p>TCP提供<strong>可靠交付</strong>的服务。通过TCP连接传送的数据，<strong>无差错</strong>，<strong>不丢失</strong>，<strong>不重复</strong>，<strong>并且按序到达</strong>。</p>
</li>
<li>
<p>TCP提供<strong>全双工通信</strong>。TCP允许通信双方的<strong>应用进程在任何时候都能发送数据</strong>，TCP连接的两端都设有<strong>发送缓存</strong>和<strong>接收缓存</strong>，用来临时存放双向通信的数据。在发送时，应用程序在把数据传送给TCP的缓存后，就可以做自己的事，而<strong>TCP在合适的时候再把数据发送出去</strong>。在接收时，TCP把收到的数据放入缓存，上层的应用进程在合适的时候读取缓存中的数据。</p>
</li>
<li>
<p><strong>面向字节流</strong> UDP是面向报文，而TCP是面向字节流的。<strong>流(stream)<strong>指的是</strong>流入到进程或从进程流出的字节序列</strong>。含义是：虽然应用程序和TCP的交互是一次一个数据块(大小不等)，但TCP把应用程序交付下来的数据<strong>仅仅</strong>看成一连串<strong>无结构的字节流</strong>。TCP并不知道传送的字节流的含义，也<strong>不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系</strong>。例如，发送方应用程序交给发送方TCP共10个数据块，接收方的TCP可能只用了4个数据块就把收到的字节流交付上层的应用程序，因为应用程序和TCP<strong>交互的数据块大小可以不等</strong>。但从<strong>字节流</strong>的角度来看，<strong>接收方收到的字节流必须和发送方发出的字节流是完全一样的</strong>，接收方有能力识别收到的字节流，把它还原成有意义的应用层数据，交付上层。</p>
<p>如图5-8 ：</p>
<img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_10.jpg" style="zoom: 33%;">
</li>
</ol>
<p>从图5-8可以看出，TCP和UDP在发送报文时所采用的方式完全不同，TCP是面向<strong>字节流</strong>的，TCP并不关心应用进程一次把多长的报文发送到TCP缓存中，而是根据对方给出的<strong>窗口</strong>和当前网络拥塞的程度决定<strong>一个报文段应包含多少个字节</strong>，而UDP是<strong>面向报文的</strong>，只负责将从应用进程收到的报文添加首部后交付给IP层，所以UDP发送的报文长度是应用进程给出了。TCP可以<strong>灵活地控制报文的长度</strong>，如果TCP缓存的数据块太长，可以划分短一些再传送。如果太短，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。</p>
<h3 id="32-tcp的连接"><a class="markdownIt-Anchor" href="#32-tcp的连接"></a> 3.2 TCP的连接</h3>
<p>TCP把<strong>连接</strong>作为<strong>最基本的抽象</strong>。</p>
<p>前面提到，每一条TCP连接有两个<strong>端点</strong>。那么，<strong>TCP连接的端点</strong>是什么？不是主机，不是主机的IP地址，不是应用进程，也不是运输层的协议端口，而是<strong>套接字(socket)<strong>或</strong>插口</strong>。根据RFC793的定义：端口号<strong>拼接到(concatenated with)</strong> IP地址即构成了套接字。因此，套接字的表示方法是在点分十分制的IP地址后面写上端口号，中间用冒号或逗号隔开。例如，若IP地址是192.3.4.5而端口号是80，那么得到的套接字就是(192.3.4.5:80)。有：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">套</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">字</mi><mi>s</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi><mo>=</mo><mo stretchy="false">(</mo><mi>I</mi><mi>P</mi><mi mathvariant="normal">地</mi><mi mathvariant="normal">址</mi><mi mathvariant="normal">：</mi><mi mathvariant="normal">端</mi><mi mathvariant="normal">口</mi><mi mathvariant="normal">号</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">套接字socket=(IP地址：端口号)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord cjk_fallback">套</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">字</span><span class="mord mathdefault">s</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord cjk_fallback">地</span><span class="mord cjk_fallback">址</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">端</span><span class="mord cjk_fallback">口</span><span class="mord cjk_fallback">号</span><span class="mclose">)</span></span></span></span></span></p>
<p><strong>每一条TCP连接唯一地被通信两端的两个端点(即两个套接字)所确定</strong>。即：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>C</mi><mi>P</mi><mi mathvariant="normal">连</mi><mi mathvariant="normal">接</mi><mo>:</mo><mo>:</mo><mo>=</mo><mo stretchy="false">{</mo><mi>s</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>e</mi><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>s</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>e</mi><msub><mi>t</mi><mn>2</mn></msub><mo stretchy="false">}</mo><mo>=</mo><mo stretchy="false">{</mo><mo stretchy="false">(</mo><mi>I</mi><msub><mi>P</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>p</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>I</mi><msub><mi>P</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>p</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">TCP连接 ::= \{socket_1,socket_2\}=\{(IP_1,port_1),(IP_2,port_2)\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord cjk_fallback">连</span><span class="mord cjk_fallback">接</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">s</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">}</span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">IP_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">IP_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>分别为通信两个主机的IP地址，而<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">port_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">port_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>分别是两个端点主机中的端口号。</p>
<p>再强调一遍，<strong>TCP连接的端点是个很抽象的套接字(即IP地址：端口号)</strong>。同时，同一个IP地址可以有多个不同的TCP连接，同一个端口号也可以出现在多个不同的TCP连接中。</p>
<h2 id="4-可靠传输的原理"><a class="markdownIt-Anchor" href="#4-可靠传输的原理"></a> 4 可靠传输的原理</h2>
<p>我们知道，TCP提供的是<strong>可靠传输</strong>，那么采用什么样的适当措施才能使得两个运输层之间的通信变得可靠？</p>
<p>首先<strong>理想的传输条件有以下两个特点</strong>：</p>
<ul>
<li>一 传输信道<strong>不出现差错</strong>。</li>
<li>二 不管发送方以多快的速度发送数据，接收方<strong>总是来得及处理</strong>收到的数据。</li>
</ul>
<p>在这样的理想传输条件下，不需要采取任何措施就能够实现<strong>可靠传输</strong>。然而实际的网络都不具备一下的两个条件，所以需要使用一些可靠传输协议，当出现差错时让发送方重传出现差错的数据(<strong>实现特点一</strong>)，同时在接收方来不及处理收到的数据时，及时告知发送方降低发送数据的速度(<strong>实现特点二</strong>)。实现了这两个特点，就实现了可靠传输。下面就是具体讲<strong>如何去达到这两个特点</strong>：</p>
<h3 id="41-停止等待协议"><a class="markdownIt-Anchor" href="#41-停止等待协议"></a> 4.1 停止等待协议</h3>
<p>运输层传送的协议的<strong>数据单元</strong>叫做<strong>报文段</strong>，网络层传送的协议数据单元叫做<strong>IP数据报</strong>。但下面为了讨论方便，把传送的数据单元都称为<strong>分组</strong>，而不考虑数据是在哪一个层次上传送的。</p>
<p><strong>停止等待</strong>就是每发完一个分组就停止发送，<strong>等待</strong>对方的<strong>确认</strong>，<strong>收到确认后再发送</strong>下一个分组。</p>
<h4 id="411-无差错情况"><a class="markdownIt-Anchor" href="#411-无差错情况"></a> 4.1.1 无差错情况</h4>
<p>停止等待协议可以用5-9来说明。图5-9(a)是传输分组中没有出现差错的情况。A发送完分组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,就暂停发送，等待B的确认。B收到了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>就向A确认。A收到了B对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的确认后，就继续发送下一个分组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">M_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,然后就暂停发送，收到B对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">M_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的确认后，再发送<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">M_{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_11.jpg" style="zoom: 33%;">
<h4 id="412-出现差错"><a class="markdownIt-Anchor" href="#412-出现差错"></a> 4.1.2 出现差错</h4>
<p>图5-9(b)是分组在传输过程中出现差错的情况。B收到了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,但是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>检测出了差错，就丢弃<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,其他什么也不做(<strong>并不通知A收到有差错的分组</strong>)，另一种情况是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>在传输过程中丢失了，这时B什么也不知道。在这两种情况下，<strong>B都不会发任何消息</strong>。</p>
<p><strong>可靠传输</strong>是这样设计的：A只要超过了一段时间没有收到B的确认，就认为刚才发送的<strong>分组丢失</strong>了(有可能被接收到了，但出错了，A一律看成是丢失了)，因此A重传前面发送的分组，这就是<strong>超时重传</strong>。如何确定A要等待多长的时间才重传？我们在A每发送完一个分组时，设置一个<strong>超时计时器</strong>，如果在超时计时器到期之前收到了对方的确认，就<strong>撤销</strong>已经设置的超时计时器，如果超时计时器到期之前没有收到对方的确认，就重传分组。</p>
<p>这里需要注意的一些点是：</p>
<ul>
<li><strong>一</strong>，A在发送完一个分组后，<strong>必须暂时保留已发送的分组的副本</strong>，因为分组可能会丢失，需要重传，只有收到相应的分组确认后才可以清除分组的副本。</li>
<li><strong>二</strong>，分组和确认分组都必须进行<strong>编号</strong>，这样才能明确是哪一个发送出去的分组收到了确认，而哪一个分组还没有收到确认。</li>
<li><strong>三</strong>，超时计时器设置的重传时间<strong>应当比数据在分组传输的平均往返时间更长一些</strong>，以防止正常确认报文还未到达A，A就开始重传了，造成了不必要的重传。</li>
</ul>
<h4 id="413-确认丢失和确认迟到"><a class="markdownIt-Anchor" href="#413-确认丢失和确认迟到"></a> 4.1.3 确认丢失和确认迟到</h4>
<p>图5-10(a)说明的是另一种情况，A发送的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>分组顺利到达了B，且没有差错，B按协议向A发送一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>收到确认分组，但是该确认分组在传输的过程中丢失了，此时A并不知道<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是丢失了，还是出错了，还是B的确认报文丢失了，因此A在超时计时器到底后就重传<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,假设传输顺利，B此时又收到了一遍<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,这是B会采取两个行动：</p>
<ul>
<li><strong>一</strong> <strong>丢弃</strong>这个重复的分组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,不向上交付。</li>
<li><strong>二</strong> <strong>向A重新发送确认</strong>，因为A之所以重传就表示A没有收到对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的确认，所以需要再确认一遍。</li>
</ul>
<img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_12.jpg" style="zoom: 20%;">
<p>图5-10(b)也是一种可能出现的情况。传输过程中没有出现差错，但B对分组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的确认迟到了。A会收到重复的确认。对重复的确认的处理很简单：<strong>收下了重复的确认分组就丢弃</strong>。在这过程中，B也会收到重复的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,但B会丢弃重复的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，但每次收到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>都<strong>重传确认分组</strong>。</p>
<p>这种可靠传输，A最终总是可以收到对所有发出的分组的确认，这样我们就可以<strong>在不可靠的传输网络上实现可靠的通信</strong>。</p>
<p>像上述的这种可靠传输协议常称为<strong>自动重传请求ARQ(Automatic Repeat reQuest)</strong>。意思是重传的请求是自动进行的，接收方不需要请求发送方重传某个出错的分组。(靠的是发送方自己设置的<strong>超时计时器</strong>)。</p>
<h4 id="414-信道利用率"><a class="markdownIt-Anchor" href="#414-信道利用率"></a> 4.1.4 信道利用率</h4>
<p><strong>停止等待协议</strong>的优点就是它的实现简单，但缺点是信道的利用率太低了。如图5-11，假定在A和B之间有一条直通的信道来传送分组。</p>
<img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_13.jpg" style="zoom: 33%;">
<p>假定A发送分组需要的时间是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>D</mi></msub></mrow><annotation encoding="application/x-tex">T_{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>D</mi></msub></mrow><annotation encoding="application/x-tex">T_{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>等于分组长度除以数据传输速率。再假定分组正确到达B后，B处理分组的时间忽略不计，即时立即发回确认。假定B发送确认分组需要时间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">T_{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，如果A处理确认分组的时间也忽略不计，那么A在经过时间**(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>D</mi></msub></mrow><annotation encoding="application/x-tex">T_{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>+RTT+<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">T_{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><strong>)后才发送下一个分组。这里的</strong>RTT<strong>为</strong>往返时间**。因为仅仅有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>D</mi></msub></mrow><annotation encoding="application/x-tex">T_{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的时间用来传送有用的数据，因此信道利用率U为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mo>=</mo><msub><mi>T</mi><mi>D</mi></msub><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><msub><mi>T</mi><mi>D</mi></msub><mo>+</mo><mi>R</mi><mi>T</mi><mi>T</mi><mo>+</mo><msub><mi>T</mi><mi>A</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U=T_{D}/(T_{D}+RTT+T_{A})
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>为了提高传输效率，发送方可以不使用<strong>低效率</strong>的停止等待协议，而是采用<strong>流水线传输</strong>。如图5-12，流水线传输就是发送方可以连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认，这样可以使得信道上一直有数据不间断地在传送。当使用流水线传输时，就需要使用<strong>连续ARQ协议</strong>和<strong>滑动窗口协议</strong>。</p>
<img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_14.jpg" style="zoom: 33%;">
<h3 id="42-连续arq协议"><a class="markdownIt-Anchor" href="#42-连续arq协议"></a> 4.2 连续ARQ协议</h3>
<p>图5-13(a)表示发送方维持的<strong>发送窗口</strong>，它的意思是：位于发送窗口内的5个分组都可以连续发送出去，而不需要等待对方的确认，通过这种方式，<strong>信道利用率</strong>就提高了。</p>
<img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/29.jpg" style="zoom: 20%;">
<p>如图5-13，分组发送是按照分组序号从小到大发送的。连续的ARQ协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。如图5-13(b)表示发送方收到了对第1个分组的确认，于是就把发送窗口向前移动一个分组。</p>
<p>接收方一般是采用<strong>累积确认</strong>的方式，也就是说，接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，<strong>对按序到达的最后一个分组发送确认</strong>，表明<strong>到这个分组为止的所有分组都已正确收到</strong>了。</p>
<p><strong>累积确认</strong>的优点是：即使<strong>确认丢失了也不必重传</strong>，信道利用率比停止等待协议要高。但缺点是不能向发送方反映出接收方已经正确收到的所有分组的信息。</p>
<p>举一个累积确认的例子，如果发送方发送了前5个分组，而中间的第3个分组丢失，这时接收方只能对前两个分组发出确认，而发送方没有收到后面三个分组的确认，只要重传后面三个分组。这也叫做<strong>Go-back-N</strong>（回退N)。</p>
<h2 id="5-tcp报文段的首部格式"><a class="markdownIt-Anchor" href="#5-tcp报文段的首部格式"></a> 5 TCP报文段的首部格式</h2>
<p>我们知道，TCP是面向字节流的，但TCP传送的数据单元是<strong>报文段</strong>。一个TCP报文段分为<strong>首部</strong>和<strong>数据</strong>两部分。</p>
<p>TCP报文段首部的<strong>前20个字节是固定的</strong>，后面有4n字节是根据需要而增加的选项(n为整数）。因此，<strong>TCP首部的最小长度是20字节</strong>。</p>
<img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_15.jpg" style="zoom: 33%;">
<p>首部固定部分各字段的意义如下：</p>
<ol>
<li>
<p><strong>源端口</strong>和<strong>目的端口</strong>：一个端口16位，各占两个字节，分别写入源端口号和目的端口号。实现前面提到的<strong>分用</strong>功能。</p>
</li>
<li>
<p><strong>序号</strong> 占4个字节，序号范围是[0,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{32}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>]，共<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>(即4294967296)个序号。序号增加<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{32}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>后，下一个序号就又回到。也就是说，序号使用mod <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>运算。<br>
我们说过，TCP是<strong>面向字节流</strong>的。在一个TCP连接中传送的字节流中的<strong>每一个字节</strong>都<strong>按顺序编号</strong>。整个要传送的字节流的起始序号需要在连接建立时设置。首部中的<strong>序号字段</strong>就是指<strong>本报文段</strong>所发送的数据的<strong>第一个字节的序号</strong>。比如说，一报文段的序号字段值是301，而携带的数据共有100个字节(表面该数据报有100个字节流那么长)，这就表明：本报文段的第一个字节的序号是301，最后一个字节的序号是400，所以下一个报文段的序号字段值为401。该字段也称<strong>报文段序号</strong>。</p>
</li>
<li>
<p><strong>确认号</strong>：占4个字节，是<strong>期望收到对方下一个报文段的第一个数据字节的序号</strong>(也就是报文的序号)。比方说B正确收到了A发送过来的一个报文段，序号字段为501，而数据长度为200字节，那么表明B正确收到了A发送的到序号700为止的数据。所以B期望收到A的下一个报文的序号是701，所以B在发送给A的确认报文段中把<strong>确认号设置为701</strong>。<br>
总之，我们需要明白：</p>
<blockquote>
<p>若确认号 = N，就表明：到序号N-1为止的所有数据<strong>都已正确收到</strong>。</p>
</blockquote>
</li>
<li>
<p><strong>数据偏移</strong>：占4位，指出TCP报文段的数据起始处距TCP报文段的起始处有多远，实际上也就是指出<strong>TCP报文的首部长度</strong>。因为首部中还有选项字段，所以得通过该字段确定数据部分在哪个位置开始。<br>
注意，数据偏移的单位是<strong>32个字(4字节)</strong>，4位表示最大十进制数为15，所以数据偏移的最大值是60个字节，也就是TCP首部长度最大是60字节，也就是选项字段最大为40字节。</p>
</li>
<li>
<p><strong>保留</strong> 6位，保留为今后使用，但目前全置为0。</p>
<p>下面为**6个控制位 **(6)~(11)</p>
</li>
<li>
<p><strong>紧急URG(URGent)</strong>: 当URG=1时，表明<strong>紧急指针字段有效</strong>，告诉系统此报文段中有紧急数据，需要尽快传送，相当于说要优先传送这些数据，不要按原来的排队顺序来传送，这时发送方TCP就会将紧急数据插入到本报文段数据的<strong>最前面</strong>。</p>
</li>
<li>
<p><strong>确认ACK(ACKnowledgment)</strong>: 仅当ACK=1时<strong>确认号字段</strong>才有效。当ACK=0时，确认号无效。TCP规定，在<strong>连接建立后</strong>所有传送的报文段都必须<strong>把ACK置1</strong>。</p>
</li>
<li>
<p><strong>推送PSH(PuSH)</strong>: 我们前面提到了TCP协议在发送端和接收端都有<strong>缓存</strong>，数据放入缓存，而什么时候发送和什么时候接收给上层要等<strong>合适</strong>的时机，但有时候两个应用进程进行交互式的通信，在一端的应用进程希望在键入一个命令后就<strong>立即能够收到对方的响应</strong>，而不是还需要停在缓存在等待合适的时机。在这种情况下，TCP就可以使用推送字段，发送方TCP把PSH置为1，并立即创建一个报文段发送出去。接收方TCP收到PSH=1的报文段，就尽快地<strong>交付给上层应用进程</strong>，而<strong>不再等到整个缓存都填满了再向上交付</strong>。</p>
</li>
<li>
<p><strong>复位RST(ReSeT)</strong> 当RST=1时，表明TCP连接中出现了严重错误，必须<strong>释放连接</strong>，再重新建立运输连接。RST置1还用来拒绝一个非法的报文段或拒绝打开连接。</p>
</li>
<li>
<p><strong>同步SYN(SYNchronization)</strong>：在连接建立时用来同步序号。当SYN=1时而ACK=0时，表明这是一个<strong>连接请求报文段</strong>。对方若同意建立连接，则应在响应的报文段使SYN=1和ACK=1。因此，SYN置为1就表示这是一个<strong>连接请求</strong>或<strong>连接接受报文</strong>。</p>
</li>
<li>
<p><strong>终止FIN(FINis)</strong>:：用来释放一个连接。当FIN=1时，表示该报文段的发送方的数据已发送完毕，并要求释放运输连接。</p>
</li>
<li>
<p><strong>窗口</strong> 占2个字节。窗口值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mi mathvariant="normal">，</mi><msup><mn>2</mn><mn>16</mn></msup><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0，2^{16}-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>之间的一个整数。窗口指的是发送本报文段的一方的<strong>接收窗口</strong>。窗口值告诉对方：从本报文段首部的确认号算起，接收方目前运行对方发送的数据量(<strong>以字节为单位</strong>)，之所以这么做是因为接收方<strong>接收缓存</strong>是有限的，如果接收的数据超过了缓存，会出现分组丢失。</p>
<p>举个例子，A发送了一个报文段，确认号为701，窗口字段是1000。意思就是告诉对方：“从701号算起，我的接受缓存还能接受1000个字节的数据”。</p>
<blockquote>
<p>窗口字段明确指出了现在允许对方发送的数据量，经常需要根据实际缓存可接收空间而变化。</p>
</blockquote>
</li>
<li>
<p><strong>检验和</strong>：占2字节，检验的范围和UDP一样，<strong>包括首部和数据</strong>这两部分。检验方法与UDP检验和类似，只是一些字段需要改变。如伪首部中的第四个字段需要改成6，第五个字段UDP长度应改为TCP长度。</p>
</li>
<li>
<p><strong>紧急指针</strong>：2个字节，仅当URG=1时才有意义，指出了本报文段中紧急数据的字节数，指出了紧急数据的末尾在报文段中的位置。值得注意的是，<strong>窗口为0也可以发送紧急数据</strong>。</p>
</li>
<li>
<p><strong>选项</strong> 长度可变，前面提到，最长可达40字节</p>
</li>
</ol>
<h2 id="6-tcp可靠传输的实现"><a class="markdownIt-Anchor" href="#6-tcp可靠传输的实现"></a> 6 TCP可靠传输的实现</h2>
<p>为了方便理解，<strong>假定数据传输只在一个方向进行</strong>，即A发送数据，B给出确认。</p>
<h3 id="61-以字节为单位的滑动窗口"><a class="markdownIt-Anchor" href="#61-以字节为单位的滑动窗口"></a> 6.1 以字节为单位的滑动窗口</h3>
<p>TCP的滑动窗口是<strong>以字节为单位的</strong>。假定A收到了B发来的确认报文段，告诉窗口是<strong>20字节</strong>，而确认号是31，也就是说B期望收到的下一个报文的序号字段为31，并且序号30之前的报文已经收到了。根据信息，A构造出字节的<strong>发送窗口</strong>，如图5-15：</p>
<img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_16.jpg" style="zoom: 33%;">
<p>发送窗口表示：在没有收到B的确认的情况下，A可以连续把窗口内的数据都发送出去，需要再强调一遍：<strong>凡是已经发送出去的数据，但还没有收到确认，这些数据都必须暂时保留，以便在超时重传时使用</strong>。</p>
<p>发送窗口里面的序号表示允许发送的序号，在介绍TCP报文字段时提到，<strong>接收方会把自己的接收窗口数值放在窗口字段中发送给对方</strong>。因此，<strong>A的发送窗口一定不能超过B的接收窗口的值</strong>，否则会出现接收方处理不过来而导致某些报文段的丢失。</p>
<p>发送窗口的位置由<strong>窗口前沿</strong>和<strong>后沿</strong>的位置共同确定。发送窗口后沿的变化情况有两种：<strong>不动</strong>就表示没有收到新的确认，<strong>前移</strong>就表示收到了新的确认了。发送窗口前沿一般是<strong>不断向前移动</strong>的，但也有可能<strong>不动</strong>的，可能是因为没有收到新的确认而对方的接收窗口大小也保持不变，也可能是收到新的确认报文了，但是窗口大小变小了。</p>
<img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_17.jpg" style="zoom: 33%;">
<p>如图5-16，要描述一个发送窗口的状态需要三个指针，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub><mi mathvariant="normal">，</mi><msub><mi>P</mi><mn>2</mn></msub><mi mathvariant="normal">，</mi><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_{1}，P_{2}，P_{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>指针都指向字节的序号，三个指针指向的部分的意义如下：</p>
<p>小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的是已发送并已收到确认的部分，而大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的是不允许发送的部分。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>-<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=A的发送窗口。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>-<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=<strong>已发送</strong>但<strong>未收到确认</strong>的字节数。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>-<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=<strong>允许发送</strong>但<strong>尚未发送</strong>的字节数。</p>
<p>再观察B的<strong>接受窗口</strong>，B的接收窗口的大小是20。如图，到30号为止的数据是已经发送过确认，并且已经交付主机了。所以B不再保留这些数据，接收窗口内的序号31~50是允许接收的。如图5-16，B收到了序号为32和33的数据，但并没有收到序号为31的数据，我们前面有提到，B只能对按序收到的数据中的最高序号给出确认，因此B发送的确认报文段中的确认号<strong>还是31</strong>。</p>
<p>假定B之后收到了序号为31的数据，并把序号31<sub>33的数据交付主机，然后B就删除这些数据，把接收窗口向前移动3个序号，同时给A**发送确认**。窗口仍然为20，但**确认号变为34**。A收到B的确认后，将发送窗口向前滑动3个序号，指针$P_{2}$暂时不动，A现在可发送的序号范围是42</sub>53。</p>
<img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_18.jpg" style="zoom: 25%;">
<p>之后A继续发送序号42~53的数据，指针<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>向前移动和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>重合，此时发送窗口内的序号都已经使用完了，但还没有收到确认，可用窗口为0，<strong>停止发送</strong>，等待接收方发出确认。</p>
<img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_19.jpg" style="zoom: 25%;">
<h3 id="62-窗口与缓存的关系"><a class="markdownIt-Anchor" href="#62-窗口与缓存的关系"></a> 6.2 窗口与缓存的关系</h3>
<p>前面提到，发送方和接收方都存在有缓存，<strong>发送方的应用进程把字节流写入TCP的发送缓存，接收方的应用进程从TCP的接收缓存中读取字节流</strong>。进一步讨论<strong>窗口</strong>和<strong>缓存</strong>的关系。如图5-19：</p>
<img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_20.jpg" style="zoom: 25%;">
<p><strong>发送缓存</strong>用来暂存：</p>
<ul>
<li><strong>发送应用程序传送给发送方TCP准备发送的数据</strong></li>
<li><strong>TCP已经发送但尚未收到确认的数据</strong></li>
</ul>
<p>已被确认的数据会从发送缓存中删除。</p>
<p><strong>接收缓存</strong>用来暂存：</p>
<ul>
<li><strong>按序到达的，但尚未被应用程序接收读取的数据</strong></li>
<li><strong>未按序到达的数据</strong></li>
</ul>
<p>接收应用程序来不及读取收到的数据，接收缓存就被逐渐被填满，直到接收窗口为0。如果接收应用程序能够非常及时快速地读取缓存中的数据，接收窗口就可以增大。</p>
<p>对于缓存和窗口，还要强调以下三点：</p>
<ul>
<li><strong>在同一时刻，A的发送窗口并不是总是和B的接收窗口一样大</strong>。原因是：我们知道A的发送窗口是根据B发送的报文的窗口字段来确定的，而B发送的报文的窗口字段虽然是根据<strong>接收窗口</strong>的大小确定的，但是通过网络传送窗口报文组需要经历一段的<strong>时间滞后</strong>，所以导致A的发送窗口并不总是和B的接受窗口一样大。</li>
<li>TCP通常对不按序到达的数据先临时存放在接收窗口中，等到字节流中所缺少的字节收到时，再<strong>按序交付上层的应用程序</strong>。</li>
<li>TCP要求接收方需要有<strong>累计确认</strong>的功能，这样可以减小传输开销。接收方可以在<strong>合适</strong>的时候<strong>发送确认</strong>，也可以在自己有数据要发送时把确认信息顺便<strong>捎带</strong>上，称为<strong>捎带确认</strong>。</li>
</ul>
<h3 id="63-超时重传时间的选择"><a class="markdownIt-Anchor" href="#63-超时重传时间的选择"></a> 6.3 超时重传时间的选择</h3>
<p>前面提到，TCP的发送方在规定的时间内没有收到确认就要重传已发送的报文段，概念是很简单的，但是如何<strong>确认重传的时间选择</strong>却成为了TCP最复杂的问题之一。</p>
<p>如果把超时重传设计<strong>设置得太短</strong>，就会引起很多报文段的<strong>不必要重传</strong>。<strong>设置得太长</strong>，又使网络的空闲时间增大，<strong>降低了传输效率</strong>。</p>
<p>TCP采用了一种自适应的算法，它记录一个报文段发出的时间，以及受到相应的确认的时间。这两个时间之差就是<strong>报文段的往返时间RTT</strong>。TCP保留了RTT的一个<strong>加权平均往返时间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">RTT_{s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></strong>,又称为<strong>平滑的往返时间</strong>，因为是对众多往返时间的加权平均，所以结果更加<strong>平滑</strong>。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">RTT_{s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>具体的计算是：第一次测量RTT样本时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">RTT_{s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>就为所测量到的RTT的样本值，以后每测量到一个新的RTT样本，就按下面公示重新计算新的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">RTT_{s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">新</mi><mi mathvariant="normal">的</mi><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mi mathvariant="normal">旧</mi><mi mathvariant="normal">的</mi><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mi>α</mi><mo>×</mo><mo stretchy="false">(</mo><mi mathvariant="normal">新</mi><mi mathvariant="normal">的</mi><mi>R</mi><mi>T</mi><mi>T</mi><mi mathvariant="normal">样</mi><mi mathvariant="normal">本</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">新的RTT_{s}=(1-\alpha) × (旧的RTT_{s})+\alpha × (新的RTT样本)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">新</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">旧</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">新</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord cjk_fallback">样</span><span class="mord cjk_fallback">本</span><span class="mclose">)</span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>的取值由标准推荐。</p>
<p>前面我们说到，超时计时器设置的**超时重传时间RTO(RetransmissionTime-Out)**应略大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">RTT_{s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。具体计算还需要看协议的标准。</p>
<h3 id="64-选择确认sack"><a class="markdownIt-Anchor" href="#64-选择确认sack"></a> 6.4 选择确认SACK</h3>
<p>这里还需要解决一个问题，就是收到的报文段无差错，只是未按序号，中间还<strong>缺少一些序号的数据</strong>。那么能否<strong>只传送缺少的数据而不重传已经正确到达接收方的数据</strong>？<strong>选择确认</strong>就是用来处理这种情况的可行方法。</p>
<p>举个例子说明**选择确认(Selective ACK)**的工作原理。如图5-21，可以看出，序号1<sub>1000收到了，但序号1001</sub>1500没有收到，1501~3000收到了，但是3001到3500又缺少了，再后面序号4501起都没有收到。</p>
<img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_21.jpg" style="zoom: 25%;">
<p>接收方收到了和前面的字节流不连续的两个字节块，如果这些<strong>字节的序号都在接收窗口之内</strong>，那么接收方就先收下这些数据，并把这些信息告诉发送方，<strong>使发送方不要再重复发送这些已经收到的数据</strong>了。</p>
<p>从图5-21可看出，和前后字节不连续的每一个字节快都有<strong>两个边界</strong>，左边界和右边界。在图中用四个指针标记这些边界。第一个字节块的左边界<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">L_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=1501,但右边界<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">R_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=3001而不是3000，这表明<strong>左边界</strong>指出字节块的第一个字节的序号，但<strong>右边界减1</strong>才是字节块中的最后一个序号。</p>
<p>RFC 2018规定：</p>
<ul>
<li>如果要使用选择确认，那么在建立 TCP 连接时，就要在 TCP 首部的<strong>选项中</strong>加上“<strong>允许 SACK</strong>”的选项，而双方必须都事先商定好。</li>
<li>如果使用选择确认，那么原来首部中的“确认号字段”的用法仍然不变。只是以后在 TCP 报文段的首部中都增加了 SACK 选项，以便报告收到的不连续的字节块的边界。</li>
<li>由于首部选项的长度最多只有 40 字节，而指明一个边界就要用掉 4 字节，因此在选项中最多只能指明4个字节块的边界信息。(只能是因为40个字节还需要有的字节用来指明<strong>允许SACK</strong>等)</li>
</ul>
<p>大多数的实现还是重传<strong>所有未被确认的数据块</strong>。</p>
<h2 id="7-tcp的运输连接管理"><a class="markdownIt-Anchor" href="#7-tcp的运输连接管理"></a> 7 TCP的运输连接管理</h2>
<p>我们知道，TCP是<strong>面向连接</strong>的协议，运输连接是用来传送TCP报文的。TCP运输连接的<strong>建立和释放</strong>是每一次面向连接的通信中必不可少的。</p>
<p>因此，运输连接分为三个阶段：<strong>连接建立，数据传送，连接释放</strong>。运输连接的管理就是使运输连接的建立和释放都能正常地进行。</p>
<p>连接建立过程中要解决以下<strong>三个问题</strong>：</p>
<ul>
<li>要使每一方能够确知对方的存在。</li>
<li>要允许双方协商一些参数（如<strong>最大报文段长度</strong>，<strong>最大窗口大小</strong>，<strong>服务质量</strong>等）。</li>
<li>能够对运输实体资源（如缓存大小，连接表中的项目等）进行分配。</li>
</ul>
<h3 id="71-tcp的连接建立"><a class="markdownIt-Anchor" href="#71-tcp的连接建立"></a> 7.1 TCP的连接建立</h3>
<p>TCP连接的建立都是采用<strong>客户服务器</strong>方式。主动发起连接建立的应用进程叫做<strong>客户(cilent)</strong>，被动等待连接建立的应用进程叫做<strong>服务器(server)</strong>。</p>
<p>TCP的建立连接的过程叫做<strong>握手</strong>。握手需要再客户和服务器之间交换三个TCP报文段，称为<strong>三次握手</strong>，如图5-28：</p>
<img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_27.jpg" style="zoom: 25%;">
<p>主机A运行TCP客户程序，B运行TCP服务器程序。最初两端的TCP进程均处于**CLOSED(关闭)**状态。<strong>A主动打开连接</strong>，<strong>B被动打开连接</strong>。</p>
<p>最开始，B的TCP服务器进程先创建<strong>传输控制块TCB</strong>，准备接受客户进程的连接请求，服务器进程处于**LISTEN(收听)**状态，等待客户的连接请求，如有，作出响应。</p>
<p>A的TCP客户进程也是首先创建<strong>传输控制模块TCB</strong>。然后，在打算建立TCP连接的时候，<strong>向B发出连接请求报文段</strong>，此时首部中的同步位<strong>SYN=1</strong>,表明这是一个连接请求报文，同时选择一个初始序号<strong>seq=x</strong>。注意，TCP规定，SYN=1的报文段<strong>不能携带数据</strong>，但是要<strong>消耗掉一个序号</strong>。发送完连接请求报文后，TCP客户进程就进入了(SYN-SENT)，也就是<strong>同步已发送</strong>状态。</p>
<p>B收到连接请求报文段后，如果同意建立连接，则向A<strong>发送确认</strong>， B 在确认报文段中应使 SYN=1, ACK=1,表明这是一个<strong>连接接受报文</strong>，其确认号ack = x+1(<strong>表明下一个想接收到的报文的序号为x+1</strong>，自己选择的序号 seq =y。这是TCP服务器进程进入了SYN-RCVD，也就是<strong>同步收到</strong>状态。</p>
<p>TCP客户进程收到B的确认后，还要向B再给出确认。其确认报文的ACK=1,确认号ack=y+1,seq=x+1。同时,A的TCP通知上层应用进程，告诉<strong>连接已经建立</strong>了，可以发数据了。注意，TCP的标准规定ACK报文段可以携带数据，但<strong>如果不携带数据则不消耗序号</strong>，这种情况下一个数据报文的序号仍然是seq=x+1。发送完报文后,A进入ESTABLISHED，也就是<strong>已建立连接</strong>状态。B收到A的确认后，也进入已建立连接状态，通知上层TCP连接已经确立。</p>
<h3 id="72-为什么连接建立a最后还要发送一次确认"><a class="markdownIt-Anchor" href="#72-为什么连接建立a最后还要发送一次确认"></a> 7.2 为什么连接建立，A最后还要发送一次确认？</h3>
<p>主要是为了防止<strong>已失效的连接请求报文段</strong>突然传送到了B，产生错误。假定A发出的第一个连接请求报文段在某些网络结点长时间滞留了，A等待超时计时器时间走完没有收到确认，于是再次发起连接请求，请求成功，A和B正常同时并完成了连接的释放。过了一段时间，第一次滞留在网络中的连接请求报文到达了B，这本来是一个早已失效的报文段了，但B收到此失效的连接请求报文段后，以为是A又发出了一次新的连接请求，于是B会正常地向A发送确认报文。如果我们的协议是<strong>B只要发出确认，新的连接就建立了</strong>，那么A这时候就会很莫名其妙，我没有发出连接请求啊，因此A不会理睬B的确认，也不会向B发送数据，但B却误以为新的运输连接已经建立，一直处于等待状态，B因此浪费了许多的资源。</p>
<h3 id="73-tcp的连接释放"><a class="markdownIt-Anchor" href="#73-tcp的连接释放"></a> 7.3 TCP的连接释放</h3>
<p>数据传输后，<strong>通信双方</strong>都可以释放连接。连接释放前，A和B都处于已建立连接(ESTABLISHED)状态，如图5-29。</p>
<img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_28.jpg" style="zoom: 25%;">
<p>A的应用进程先向其TCP发出连接释放报文段，<strong>并停止再发送数据</strong>，主动关闭TCP连接。A把连接释放报文段首部的终止控制位FIN=1，其序号为seq=u。这时A进入FIN-WAIT-1 <strong>终止等待1</strong>状态，等待B的确认。</p>
<p>B收到连接释放报文段后立即发出确认号，确认号是ack=u+1，而整个报文段自己的序号seq=v，然后B就进入了CLOSE-WAIT <strong>关闭等待</strong>状态。TCP服务器进程这时通知高层应用进程。从A到B这个方向的连接就释放了，TCP连接处于<strong>半关闭</strong>状态，也就是<strong>A已经没有数据要发送了，但B若发送数据，A仍要接收</strong>。</p>
<p>A收到来自B的确认后，就进入了 FIN-WAIT-2 <strong>终止等待2</strong>状态，等待B发出的连接释放报文段。</p>
<p>若B已经没有要向A发送的数据了，其应用进程就通知TCP释放连接。这时B发出的连接释放报文段同样使FIN=1，ACK=1，seq等于对应的序号w，ack=u+1(与上一个确认报文相同，因为A早已经不再发送数据了)。发送完后，B就进入了LAST-ACK <strong>最后确认</strong>状态，等待A的确认。</p>
<p>A收到B的连接释放报文段后，必须发出确认，在确认报文段中把ACK置1，确认号ack=w+1，而自己的序号是seq=u+1，之后进入到TIME-WAIT <strong>时间等待</strong>状态。</p>
<p>现在的TCP连接还没有释放掉，必须经过<strong>时间等待计时器(TIME-WAIT timer)<strong>设置的时间2MSL，A才进入到CLOSED状态。时间MSL叫</strong>最长报文段寿命</strong>(Maximum Segment Lifetime)。</p>
<p>为什么A在TIME-WAIT状态必须等待2MSL的时间呢？有两个理由：</p>
<ul>
<li>第一，为了保证A发送的最后一个ACK报文段能够到达B。因为这个ACK报文段可能会丢失，因而B会超时重传连接断开报文字段，A就能在2MSL时间内收到这个报文段，重传一次确认。</li>
<li>第二，防止前面提到的<strong>已失效的连接请求报文段</strong>出现在本连接中，A在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失，保证下一个新的连接中不会出现这种旧的连接请求报文段。</li>
</ul>
<h2 id="8-tcp的流量控制"><a class="markdownIt-Anchor" href="#8-tcp的流量控制"></a> 8 TCP的流量控制</h2>
<h3 id="81-利用滑动窗口实现流量控制"><a class="markdownIt-Anchor" href="#81-利用滑动窗口实现流量控制"></a> 8.1 利用滑动窗口实现流量控制</h3>
<p>一般来说，我们总是希望数据传输得更快一些，但如果发送方把数据发送得过快，接收方就可能来不及接收，造成了数据的丢失。所谓**流量控制(flow control)**就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发送拥塞。<strong>利用滑动窗口</strong>机制可以很方便地在TCP连接上实现流量控制。</p>
<p>如图5-22流量控制举例：</p>
<img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_22.jpg" style="zoom: 25%;">
<p>A向B发送数据，在连接建立时，B告诉A：“<strong>我的接收窗口rwnd=400(字节，不是报文段)”</strong>，因此，<strong>发送方的发送窗口不能超过接收方给出的接收窗口的数值</strong>。</p>
<p>假设每一个报文段为100字节长，数据报文段序号的初始值设为1。</p>
<p>从图中注意到，接收方的主机B进行了<strong>三次流量控制</strong>。第一次把窗口减小到rwnd=300，第二次减到rwnd=100，最后减到rwmd=0，即不允许发送方再发送数据了。这种暂停的状态将持续到主机B重新发出一个新的窗口值为止。</p>
<p>现在我们需要考虑一种情况：在图5-22中,B向A发送了零窗口的报文段不久后，B的接收缓存有了一些存储空间，于是B向A发送了rwnd=400的报文段，告诉A“<strong>现在有空间了，你可以继续发送数据了</strong>”，然而非常非常不幸运的是，这个报文段<strong>居然丢失了</strong>，A就一直等一直等等收到B发送的非零窗口的通知，而B心想：“<strong>我都告诉你有空间了，咋还不发数据</strong>”，也在一直等一直等。如果没有其他措施，这种互相等待的死锁局面将一直延续下去。</p>
<p>为了解决这个问题，TCP为每一个连接设有一个<strong>持续计时器(persistence timer)</strong>。只要TCP连接的一方<strong>收到对方的零窗口通知</strong>，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口<strong>探测报文段</strong>，而对方就在确认这个探测报文段时给出现在的<strong>接收窗口值</strong>。如果接收窗口为0，那么收到这个报文段的一方就<strong>重新设置</strong>持续计时器，如果不是0，就打破了死锁的僵局。</p>
<h3 id="82-tcp-的传输效率"><a class="markdownIt-Anchor" href="#82-tcp-的传输效率"></a> 8.2 TCP 的传输效率</h3>
<p>前面提到了，应用进程把数据传送到TCP的发送缓存后，剩下的发送任务就由TCP来控制了，可以用<strong>不同的机制来控制TCP报文段的发送时机</strong>。</p>
<ul>
<li>
<p>第一种机制是 TCP 维持一个变量，它等于最大报文段长度<strong>MSS</strong>。只要缓存中存放的数据达到MSS字节时，就组装成一个TCP报文段发送出去。</p>
</li>
<li>
<p>第二种机制是由<strong>发送方的应用进程指明要求发送报文段</strong>，即TCP支持的推送(push)操作。</p>
</li>
<li>
<p>第三种机制是发送方的一个<strong>计时器</strong>期限到了，这时就把当前已有的缓存数据装入报文段(<strong>但长度不能超过MSS</strong>)发送出去。</p>
</li>
</ul>
<p><strong>交互式程序中的效率</strong>：</p>
<p>发送方发送1字节的数据，同时要求服务器端回显这1字节数据。服务器确认后，再发回这1字节数据。则效率：1B/(41B的报文+40B的确认(<strong>20IP首部+20TCP首部+无数据</strong>)+41B的回显报文+40B的确认)<br>
办法：</p>
<ul>
<li>使用捎带确认: <strong>适当推迟发回确认报文，并尽量使用捎带确认的方法</strong>。</li>
<li>Nagle算法：若发送方的应用程序把数据逐个送到TCP发送缓存，发送方将第一个数据字节发送出去，收到确认后，再把缓存中的数据数据组装成一个报文段发送出去。原则是：<strong>只有收到对前一个报文段的确认，才继续发送下一个报文段</strong>。</li>
</ul>
<h2 id="9-tcp的拥塞控制"><a class="markdownIt-Anchor" href="#9-tcp的拥塞控制"></a> 9 TCP的拥塞控制</h2>
<h3 id="91-拥塞控制的一般原理"><a class="markdownIt-Anchor" href="#91-拥塞控制的一般原理"></a> 9.1 拥塞控制的一般原理</h3>
<p>在计算机网络中的带宽，交换结点中的缓存等都是网络的资源。在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏–产生<strong>拥塞(congestion)</strong>。</p>
<ul>
<li>出现资源拥塞的条件：对于资源需求的总和 &gt; 可用资源</li>
<li>如果网络中许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。</li>
</ul>
<h4 id="911这里辨别一下拥塞控制和流量控制的关系"><a class="markdownIt-Anchor" href="#911这里辨别一下拥塞控制和流量控制的关系"></a> 9.1.1这里辨别一下<strong>拥塞控制</strong>和<strong>流量控制</strong>的关系：</h4>
<p>拥塞控制与流量控制的关系密切，但也存在差别。<strong>拥塞控制</strong>是<strong>防止过多的数据注入到网络中</strong>，这样可以<strong>使网络中的路由器或链路不致过载</strong>。拥塞控制是一个<strong>全局性</strong>的过程，涉及到网络中所有的主机，所有的路由器以及与降低网络传输性能有关的所有因素。</p>
<p>而<strong>流量控制往往是指点对点通信量的控制</strong>，是个<strong>端到端</strong>的问题，流量控制所要做的就是<strong>抑制发送端发送</strong>数据的速率，<strong>以便使接收端来得及接收</strong>。</p>
<p>举个例子，设某个光纤网络的链路传输速率为1000Gbit/s。一台巨型计算机向一台个人一点以1Gbit/s的速率传送文件。（<strong>端到端</strong>）显然，网络本身的带宽资源是足够的，不存在拥塞的问题，但必须进行流量控制，因为个人电脑不如巨型计算机快。</p>
<p>而如果有另一个网络，链路传输速率为1Mbit/s，而有1000台大型计算机连接在网络上。假定其中的500台计算机分别向其余的500台计算机以100kbit/s的速率发送文件，很明显<strong>网络的资源已经不够了</strong>，整个网络的输入负载已经超过了网络所能承受的。</p>
<h4 id="912-理想拥塞控制和实际拥塞控制对比"><a class="markdownIt-Anchor" href="#912-理想拥塞控制和实际拥塞控制对比"></a> 9.1.2 理想拥塞控制和实际拥塞控制对比</h4>
<p>如图5-23：</p>
<img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_23.jpg" style="zoom: 25%;">
<p>横坐标是<strong>提供的负载(offered load)</strong>,代表单位时间内输入给网络的分组数目，也称为<strong>输入负载</strong>或<strong>网络负载</strong>。纵坐标是<strong>吞吐量(throughput)</strong>,代表单位时间内从网络<strong>输出</strong>的分组数目。</p>
<p>具有理想拥塞控制的网络，在吞吐量饱和之间，网络吞吐量应等于提供的负载，所以吞吐量曲线是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn><msup><mn>5</mn><mi mathvariant="normal">。</mi></msup></mrow><annotation encoding="application/x-tex">45^{。}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord"><span class="mord">5</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.363em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">。</span></span></span></span></span></span></span></span></span></span></span></span>的斜线，但当提供的负载超过某一个<strong>限度</strong>时，网络资源受限，吞吐量不再增长而保持为水平线，提供的负载有一部分将会丢失了。虽然如此，但是在这种理想的拥塞控制作用下，网络的吞吐量仍然维持在其所能达到的最大值。</p>
<p>但是，实际网络的情况就不一样了，随着提供的负载增大，网络的吞吐量的增长速率在逐渐减小，也就是说，在网络吞吐量还未达到饱和时，就有一部分输入负载被丢弃了。并当<strong>网络的吞吐量</strong>明显地小于<strong>理想的吞吐量</strong>时，网络就进入了<strong>轻度拥塞</strong>的状态。当提供的负载达到某一数值，网络的吞吐量反而下降了，这时网络就进入了<strong>拥塞状态</strong>。当提供的负载继续增大，网络的吞吐量将下降到0，无法工作，进入了所谓的<strong>死锁状态</strong>。</p>
<h4 id="913-开环控制和闭环控制"><a class="markdownIt-Anchor" href="#913-开环控制和闭环控制"></a> 9.1.3 开环控制和闭环控制</h4>
<ul>
<li>开环控制方法就是在设计网络时<strong>事先将有关发生拥塞的因素考虑周到</strong>，力求网络在<strong>工作时不产生拥塞</strong>。</li>
<li>闭环控制是基于反馈环路的概念。属于闭环控制的有以下几种措施：
<ol>
<li>监测网络系统以便<strong>检测到拥塞在何时、何处</strong>发生。</li>
<li>将拥塞发生的<strong>信息传送</strong>到可采取行动的地方。</li>
<li><strong>调整网络</strong>系统的运行以解决出现的问题。</li>
</ol>
</li>
</ul>
<h3 id="92-tcp的拥塞控制方法"><a class="markdownIt-Anchor" href="#92-tcp的拥塞控制方法"></a> 9.2 TCP的拥塞控制方法</h3>
<p>TCP进行拥塞控制的算法有四种，即<strong>慢开始(slow-start)</strong>，<strong>拥塞避免(congestion avoidance)</strong>，<strong>快重传(fast retransmit)<strong>和</strong>快恢复(fast recovery)</strong></p>
<p>首先介绍一些概念:</p>
<p><strong>发送方</strong>维持一个叫做**拥塞窗口cwnd(congestion window)**的状态变量。拥塞窗口的大小取决于网络的拥塞程序，并动态地变化。<strong>发送方让自己的发送窗口等于拥塞窗口</strong>。</p>
<p><strong>接收端窗口rwnd</strong>：  这是接收端根据其目前的接收缓存大小所许诺的最新的窗口值，是来自接收端的流量控制。接收端将此窗口值放在 TCP 报文的首部中的窗口字段，传送给发送端。</p>
<p>发送方控制拥塞窗口的原则是：只要网络不出现拥塞，拥塞窗口就可以再<strong>增大一倍</strong>，以转发更多的分组。但只要出现拥塞或有可能出现拥塞，就<strong>把拥塞窗口减小一些</strong>，以缓解拥塞。发送方如何知道网络发生了拥塞？<strong>判断网络拥塞的依据就是出现了超时</strong>(其实并不准确，后面会解释)。</p>
<p><strong>发送窗口的上限值</strong>：发送端的发送窗口的上限值应当取为接收端窗口 rwnd和拥塞窗口cwnd 这两个变量中较小的一个，即应按以下公式确定：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">发</mi><mi mathvariant="normal">送</mi><mi mathvariant="normal">窗</mi><mi mathvariant="normal">口</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">上</mi><mi mathvariant="normal">限</mi><mi mathvariant="normal">值</mi><mo>=</mo><mi>M</mi><mi>i</mi><mi>n</mi><mo stretchy="false">[</mo><mi>r</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo separator="true">,</mo><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">发送窗口的上限值=Min[rwnd,cwnd]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">发</span><span class="mord cjk_fallback">送</span><span class="mord cjk_fallback">窗</span><span class="mord cjk_fallback">口</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">上</span><span class="mord cjk_fallback">限</span><span class="mord cjk_fallback">值</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span></span></p>
<p>当 rwnd &lt; cwnd 时，是接收端的接收能力限制发送窗口的最大值。当 cwnd &lt; rwnd 时，则是网络的拥塞限制发送窗口的最大值。</p>
<h4 id="921-慢开始算法原理"><a class="markdownIt-Anchor" href="#921-慢开始算法原理"></a> 9.2.1 慢开始算法原理</h4>
<p><strong>慢开始</strong>算法的思路：<strong>由小到大</strong>逐渐增大<strong>发送窗口</strong>，也就是说，<strong>由小到大逐渐增加拥塞窗口数值</strong>，原因很简单，因为刚开始我们并不知道网络的负荷情况，所以先发较少的数据探测一下，具体规定为：</p>
<ul>
<li>在主机刚刚开始发送报文段时可先将拥塞窗口cwnd设置为一个最大报文段 MSS 的数值。</li>
<li>在每收到一个对新的报文段的确认后，将拥塞窗口增加至多一个 MSS 的数值。</li>
<li>用这样的方法逐步增大发送端的拥塞窗口 cwnd，可以使分组注入到网络的速率更加合理。</li>
</ul>
<p>下面举例说明<strong>慢开始算法的原理</strong>： 如图5-24</p>
<img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_24.jpg" style="zoom: 25%;">
<p><strong>报文段的个数</strong>作为<strong>窗口大小的单位</strong>。</p>
<p>当TCP连接进行初始化时，将拥塞窗口cwnd=1，发送第一个报文段<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，接收方收到后确认<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,发送方收到对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的确认后，把cwnd从1增大到2，于是发送方接着发送<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">M_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">M_{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>两个报文段，接收方都收到后发回对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">M_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">M_{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的确认。发送方每收到一个<strong>对新报文段的确认</strong>，就使发送方的拥塞窗口加1，因此发送方收到两个确认后，cwnd就从2增大到4了，可以发之后的四个报文段了。</p>
<p>因此使用慢开始算法后，<strong>每经过一个传播轮次(transmission round)，拥塞窗口cwnd就加倍。</strong> 如图5-24，一个传播轮次所经历的时间其实就是往返时间RTT，这里还需要注意RTT不是恒定的数值，一个传播轮次的时间更加具体的说是：cwnd所允许发送的报文段<strong>都连续发送</strong>出去，<strong>并全部收到了确认</strong>经历的<strong>总时间</strong>。</p>
<h4 id="922-慢开始门限ssthresh"><a class="markdownIt-Anchor" href="#922-慢开始门限ssthresh"></a> 9.2.2 慢开始门限ssthresh</h4>
<p>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个<strong>慢开始门限ssthresh</strong>状态变量。慢开始门限的用法是：</p>
<ul>
<li>当cwnd&lt;ssthresh时，使用上述的慢开始算法</li>
<li>当cwnd&gt;ssthresh时，停止使用慢开始算法而改用拥塞避免算法</li>
<li>当cwnd=ssthresh，两种算法都可以使用</li>
</ul>
<h4 id="923-拥塞避免算法原理"><a class="markdownIt-Anchor" href="#923-拥塞避免算法原理"></a> 9.2.3 拥塞避免算法原理</h4>
<p><strong>拥塞避免</strong>算法的思路是让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口+1，而不是像慢开始算法那样加倍增长，也叫<strong>加法增大(Additive Increase)</strong>，cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p>
<img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_25.jpg" style="zoom: 25%;">
<p>如图5-25，在慢开始算法下，当拥塞窗口cwnd增长到慢开始门限值ssthresh时，就改为执行拥塞避免算法，拥塞窗口按线性规律增长，<strong>使得网络比较不容易出现拥塞</strong>，但并非不是完全能够避免了拥塞。</p>
<p>当拥塞窗口cwnd=24时，网络中出现了超时，如图中的点2，表明已经出现了网络拥塞，发送方于是调整门限ssthresh=cwnd/2=12，重新设置拥塞窗口cwnd=1，重新进入慢开始阶段，当拥塞窗口到达了新的门限12时，就继续改为执行<strong>拥塞避免</strong>算法。</p>
<p>我们说到<strong>网络中出现了超时，就表明已经出现了网络拥塞</strong>，这个只是大多数的情况下，这么说其实并不准确，有时个别报文段在网络中丢失了，但实际上并不是网络拥塞造成的，这会导致发送方错误地重新设置慢开始门限，把拥塞窗口cwnd设置为1，<strong>因而降低了传输效率</strong>。(因为网络并没有拥塞，还不需要去控制拥塞窗口。)</p>
<h4 id="924-快重传"><a class="markdownIt-Anchor" href="#924-快重传"></a> 9.2.4 快重传</h4>
<p>怎么去解决上面说 的这种误会呢？采用快重传算法可以使发送方<strong>尽早知道发生了个别报文段的丢失</strong>。</p>
<p>快重传算法首先<strong>要求接收方不要等待自己发送数据时才捎带确认</strong>，而是<strong>立即发送确认</strong>。这样做可以让发送方及早知道有报文段没有到达接收方。快重传算法规定，<strong>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段</strong>。这样就不会出现超时，发送方也就不会误以为出现了网络拥塞。</p>
<img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_26.jpg" style="zoom: 25%;">
<h4 id="925-快恢复"><a class="markdownIt-Anchor" href="#925-快恢复"></a> 9.2.5 快恢复</h4>
<p>如图在5-25中的点4，发送方一连收到3个对同一个报文段的重复确认，知道现在<strong>只是</strong>丢失了个别的报文段。于是不启动慢开始，而是执行<strong>快恢复</strong>算法。这是，发送方调整门限值ssthresh=cwnd/2=8，同时设置拥塞窗口cwnd=ssthresh=8，开始执行<strong>拥塞避免</strong>算法。</p>
<h2 id="10-总结jiade"><a class="markdownIt-Anchor" href="#10-总结jiade"></a> 10 总结(jiade)</h2>
<p>终于终于写完了~~~，真是<strong>又臭又长</strong>，TCP的东西实在是太多了，还有好多细节没有写到。</p>
<p>总结一下</p>
<p>我们从<strong>为什么需要运输层</strong>说起，提到了真正在计算机网络中进行的通信是<strong>位于通信两端主机中的进程</strong>之间的通信，IP协议以下层协议只能把分组送到目的主机，而运输层就是来解决<strong>交付给哪个进程的问题</strong>，紧接着介绍了运输层的功能，包括<strong>复用</strong>和<strong>分用</strong>，以及<strong>提供应用进程间的逻辑通信</strong>，运输层提供了两种信道，<strong>可靠信道</strong>，对应TCP协议，<strong>不可靠信道</strong>，对应UDP协议，之后介绍了<strong>端口</strong>----用于给应用层的每个应用进程赋予一个非常明确的标志。之后介绍了UDP协议，主要特点是<strong>无连接</strong>，<strong>不可靠</strong>，<strong>面向报文</strong>，<strong>无拥塞控制</strong>。</p>
<p>然后就开始了漫长的TCP协议学习…</p>
<p>TCP的主要特点是<strong>面向连接</strong>，<strong>点到点的</strong>(连接的端点是<strong>套接字</strong>)，<strong>可靠的</strong>，<strong>全双工通信</strong>，<strong>面向字节流</strong>。</p>
<p>这是我们第一次遇到<strong>可靠交付</strong>的情况，所以我们介绍了<strong>可靠传输的原理</strong>，知道了<strong>理想的传输条件有以下两个特点</strong>：</p>
<blockquote>
<ul>
<li>一 传输信道<strong>不出现差错</strong>。</li>
<li>二 不管发送方以多快的速度发送数据，接收方<strong>总是来得及处理</strong>收到的数据。</li>
</ul>
</blockquote>
<p>实现了这两个特点，就实现了可靠传输，然后就开始具体学习如何实现这两个特点，学习可靠传输的原理，首先是<strong>停止等待协议</strong>，因为<strong>停止等待协议</strong>信道利用率太低，又引入了更高效率的<strong>ARQ连续协议</strong>。</p>
<p>然后就在可靠传输原理上，学习TCP可靠传输的实现，介绍了<strong>滑动窗口</strong>和<strong>超时重传时间</strong>，之后是<strong>TCP</strong>的运输连接，<strong>三次握手</strong>和<strong>四次挥手</strong>，最后介绍了TCP的流量控制和拥塞控制。</p>
<p>真的真的结束了，感觉对运输层的理解还是<strong>形成不了体系</strong>，所以本篇博客只是<strong>自己</strong>对课程学习的一些笔记和总结，大部分内容参考自**《计算机网络》**第七版，谢希仁编著。</p>
<p>如有出错(非常大可能会出错哈哈)，欢迎指正！</p>
<p>完…</p>
<p>应该不会有人看到这吧哈哈哈哈哈~~~~~~  (溜了溜了)</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:1127959736@qq.com">luo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://luo41.top/2021/06/18/计算机网络运输层/">https://luo41.top/2021/06/18/计算机网络运输层/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://luo41.top">luo's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E8%BF%90%E8%BE%93%E5%B1%82/">运输层</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/07/24/CIA-and-OSI-SECURITY-ARCHITECTURE/"><i class="fa fa-chevron-left">  </i><span>CIA and OSI SECURITY ARCHITECTURE</span></a></div><div class="next-post pull-right"><a href="/2021/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%89%A9%E7%90%86%E5%B1%82/"><span>计算机网络物理层</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '32255e197922b1ab75ad',
  clientSecret: '9bbe47fc29096bda7c2e430895ef65fa58c8d7db',
  repo: 'zhengjianda.github.io',
  owner: 'zhengjianda',
  admin: 'zhengjianda',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(/background3.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 By luo</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="100" alpha="0.6" zIndex="-1" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>