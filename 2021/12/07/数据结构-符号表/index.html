<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="数据结构-符号表"><meta name="keywords" content="数据结构"><meta name="author" content="luo,1127959736@qq.com"><meta name="copyright" content="luo"><title>数据结构-符号表 | luo's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="luo's Blog" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text"> 1 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AC%A6%E5%8F%B7%E8%A1%A8"><span class="toc-number">2.</span> <span class="toc-text"> 2 符号表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-api"><span class="toc-number">2.1.</span> <span class="toc-text"> 2.1 API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E6%9C%89%E5%BA%8F%E7%AC%A6%E5%8F%B7%E8%A1%A8"><span class="toc-number">2.2.</span> <span class="toc-text"> 2.2 有序符号表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E6%97%A0%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="toc-number">2.3.</span> <span class="toc-text"> 2.3 无序链表中的顺序查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">2.4.</span> <span class="toc-text"> 2.4 有序数组的二分查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">3.</span> <span class="toc-text"> 3 二叉查找树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.1.</span> <span class="toc-text"> 3.1 基本实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA"><span class="toc-number">3.1.1.</span> <span class="toc-text"> 1 数据表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9F%A5%E6%89%BE"><span class="toc-number">3.1.2.</span> <span class="toc-text"> 2 查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%8F%92%E5%85%A5"><span class="toc-number">3.1.3.</span> <span class="toc-text"> 3 插入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E5%88%86%E6%9E%90"><span class="toc-number">3.2.</span> <span class="toc-text"> 3.2 分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E6%9C%89%E5%BA%8F%E6%80%A7%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%8E%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.</span> <span class="toc-text"> 3.3 有序性相关的方法与删除操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9C%80%E5%A4%A7%E9%94%AE%E5%92%8C%E6%9C%80%E5%B0%8F%E9%94%AE"><span class="toc-number">3.3.1.</span> <span class="toc-text"> 1. 最大键和最小键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%90%91%E4%B8%8A%E5%8F%96%E6%95%B4%E5%92%8C%E5%90%91%E4%B8%8B%E5%8F%96%E6%95%B4"><span class="toc-number">3.3.2.</span> <span class="toc-text"> 2 向上取整和向下取整</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%80%89%E6%8B%A9%E6%93%8D%E4%BD%9C%E5%92%8C%E6%8E%92%E5%90%8D%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.3.</span> <span class="toc-text"> 3 选择操作和排名操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%88%A0%E9%99%A4%E6%9C%80%E5%A4%A7%E9%94%AE%E5%92%8C%E5%88%A0%E9%99%A4%E6%9C%80%E5%B0%8F%E9%94%AE"><span class="toc-number">3.3.4.</span> <span class="toc-text"> 4 删除最大键和删除最小键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.5.</span> <span class="toc-text"> 5 删除操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E8%8C%83%E5%9B%B4%E6%9F%A5%E6%89%BE"><span class="toc-number">3.3.6.</span> <span class="toc-text"> 6 范围查找</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">3.4.</span> <span class="toc-text"> 3.4 性能分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">4.</span> <span class="toc-text"> 4 平衡查找树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#41-2-3%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">4.1.</span> <span class="toc-text"> 4.1 2-3查找树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9F%A5%E6%89%BE"><span class="toc-number">4.1.1.</span> <span class="toc-text"> 1 查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%90%912-%E7%BB%93%E7%82%B9%E4%B8%AD%E6%8F%92%E5%85%A5%E6%96%B0%E9%94%AE"><span class="toc-number">4.1.2.</span> <span class="toc-text"> 2 向2-结点中插入新键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%90%91%E4%B8%80%E6%A3%B5%E5%8F%AA%E5%90%AB%E6%9C%89%E4%B8%80%E4%B8%AA3-%E7%BB%93%E7%82%B9%E7%9A%84%E6%A0%91%E4%B8%AD%E6%8F%92%E5%85%A5%E6%96%B0%E9%94%AE"><span class="toc-number">4.1.3.</span> <span class="toc-text"> 3 向一棵只含有一个3-结点的树中插入新键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%90%91%E4%B8%80%E4%B8%AA%E7%88%B6%E7%BB%93%E7%82%B9%E4%B8%BA2-%E7%BB%93%E7%82%B9%E7%9A%843-%E7%BB%93%E7%82%B9%E4%B8%AD%E6%8F%92%E5%85%A5%E6%96%B0%E9%94%AE"><span class="toc-number">4.1.4.</span> <span class="toc-text"> 4 向一个父结点为2-结点的3-结点中插入新键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%90%91%E4%B8%80%E4%B8%AA%E7%88%B6%E7%BB%93%E7%82%B9%E4%B8%BA3-%E7%BB%93%E7%82%B9%E7%9A%843-%E7%BB%93%E7%82%B9%E6%8F%92%E5%85%A5%E6%96%B0%E9%94%AE"><span class="toc-number">4.1.5.</span> <span class="toc-text"> 5 向一个父结点为3-结点的3-结点插入新键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%88%86%E8%A7%A3%E6%A0%B9%E7%BB%93%E7%82%B9"><span class="toc-number">4.1.6.</span> <span class="toc-text"> 6 分解根结点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%B1%80%E9%83%A8%E5%8F%98%E6%8D%A2"><span class="toc-number">4.1.7.</span> <span class="toc-text"> 7 局部变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%85%A8%E5%B1%80%E6%80%A7%E8%B4%A8"><span class="toc-number">4.1.8.</span> <span class="toc-text"> 8 全局性质</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%BA%A2%E9%BB%91%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">5.</span> <span class="toc-text"> 5 红黑二叉查找树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#51-%E6%9B%BF%E6%8D%A23-%E7%BB%93%E7%82%B9"><span class="toc-number">5.1.</span> <span class="toc-text"> 5.1 替换3-结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52-%E4%B8%80%E7%A7%8D%E7%AD%89%E4%BB%B7%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">5.2.</span> <span class="toc-text"> 5.2 一种等价的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53-%E4%B8%80%E4%B8%80%E5%AF%B9%E5%BA%94"><span class="toc-number">5.3.</span> <span class="toc-text"> 5.3 一一对应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54-%E9%A2%9C%E8%89%B2%E8%A1%A8%E7%A4%BA"><span class="toc-number">5.4.</span> <span class="toc-text"> 5.4 颜色表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55-%E6%97%8B%E8%BD%AC"><span class="toc-number">5.5.</span> <span class="toc-text"> 5.5 旋转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56-%E5%9C%A8%E6%97%8B%E8%BD%AC%E5%90%8E%E9%87%8D%E7%BD%AE%E7%88%B6%E7%BB%93%E7%82%B9%E7%9A%84%E9%93%BE%E6%8E%A5"><span class="toc-number">5.6.</span> <span class="toc-text"> 5.6 在旋转后重置父结点的链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#57-%E5%90%91%E5%8D%95%E4%B8%AA2-%E7%BB%93%E7%82%B9%E4%B8%AD%E6%8F%92%E5%85%A5%E6%96%B0%E9%94%AE"><span class="toc-number">5.7.</span> <span class="toc-text"> 5.7 向单个2-结点中插入新键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#58-%E5%90%91%E6%A0%91%E5%BA%95%E9%83%A8%E7%9A%842-%E7%BB%93%E7%82%B9%E6%8F%92%E5%85%A5%E6%96%B0%E9%94%AE"><span class="toc-number">5.8.</span> <span class="toc-text"> 5.8 向树底部的2-结点插入新键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#59-%E5%90%91%E4%B8%80%E6%A3%B5%E5%8F%8C%E9%94%AE%E6%A0%91%E5%8D%B3%E5%8D%95%E4%B8%AA3-%E7%BB%93%E7%82%B9%E4%B8%AD%E6%8F%92%E5%85%A5%E6%96%B0%E9%94%AE"><span class="toc-number">5.9.</span> <span class="toc-text"> 5.9 向一棵双键树(即单个3-结点)中插入新键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#510-%E9%A2%9C%E8%89%B2%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.10.</span> <span class="toc-text"> 5.10 颜色转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#511-%E6%A0%B9%E7%BB%93%E7%82%B9%E6%80%BB%E6%98%AF%E9%BB%91%E8%89%B2%E7%9A%84"><span class="toc-number">5.11.</span> <span class="toc-text"> 5.11 根结点总是黑色的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#512-%E5%90%91%E6%A0%91%E5%BA%95%E9%83%A8%E7%9A%843-%E7%BB%93%E7%82%B9%E6%8F%92%E5%85%A5%E6%96%B0%E9%94%AE"><span class="toc-number">5.12.</span> <span class="toc-text"> 5.12 向树底部的3-结点插入新键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#513-%E5%B0%86%E7%BA%A2%E9%93%BE%E6%8E%A5%E5%9C%A8%E6%A0%91%E4%B8%AD%E5%90%91%E4%B8%8A%E4%BC%A0%E9%80%92"><span class="toc-number">5.13.</span> <span class="toc-text"> 5.13 将红链接在树中向上传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#514-%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">5.14.</span> <span class="toc-text"> 5.14 删除操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#515-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">5.15.</span> <span class="toc-text"> 5.15 红黑树的性质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-number">6.</span> <span class="toc-text"> 6 散列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#61-%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.</span> <span class="toc-text"> 6.1 散列函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%AD%A3%E6%95%B4%E6%95%B0"><span class="toc-number">6.1.1.</span> <span class="toc-text"> 1 正整数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-number">6.1.2.</span> <span class="toc-text"> 2 浮点数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">6.1.3.</span> <span class="toc-text"> 3 字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%BB%84%E5%90%88%E9%94%AE"><span class="toc-number">6.1.4.</span> <span class="toc-text"> 4 组合键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-java%E7%9A%84%E8%A7%84%E5%AE%9A"><span class="toc-number">6.1.5.</span> <span class="toc-text"> 5 JAVA的规定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%B0%86hashcode%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95"><span class="toc-number">6.1.6.</span> <span class="toc-text"> 6 将hashCode()的返回值转化为一个数组索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E8%BD%AF%E7%BC%93%E5%AD%98"><span class="toc-number">6.1.7.</span> <span class="toc-text"> 7 软缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62-%E5%9F%BA%E4%BA%8E%E6%8B%89%E9%93%BE%E6%B3%95%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-number">6.2.</span> <span class="toc-text"> 6.2 基于拉链法的散列表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">6.2.1.</span> <span class="toc-text"> 1 删除操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9C%89%E5%BA%8F%E6%80%A7%E7%9B%B8%E5%85%B3%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">6.2.2.</span> <span class="toc-text"> 2 有序性相关的操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63-%E5%9F%BA%E4%BA%8E%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-number">6.3.</span> <span class="toc-text"> 6.3 基于线性探测法的散列表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C-2"><span class="toc-number">6.3.1.</span> <span class="toc-text"> 1 删除操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%94%AE%E7%B0%87"><span class="toc-number">6.3.2.</span> <span class="toc-text"> 2 键簇</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">6.4.</span> <span class="toc-text"> 6.4 调整数组大小</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%BA%94%E7%94%A8"><span class="toc-number">7.</span> <span class="toc-text"> 7 应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#71-%E9%80%89%E6%8B%A9%E7%AC%A6%E5%8F%B7%E8%A1%A8%E7%9A%84%E5%93%AA%E7%A7%8D%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.1.</span> <span class="toc-text"> 7.1 选择符号表的哪种实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#72-%E7%94%A8%E4%BE%8B"><span class="toc-number">7.2.</span> <span class="toc-text"> 7.2 用例</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/touxiang.jpg"></div><div class="author-info__name text-center">luo</div><div class="author-info__description text-center">在一群优秀的人中间，常常以为自己是他们一员，然后忘了努力</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">20</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">17</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">3</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://m0d1.top">mod1</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://c10udlnk.top">c10udlnk</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.fxizenta.design/">Fxizenta</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://mclaren888.cn">Mclaren</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://dzcgood.xyz/">DzcGood</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://imcomma.top/">imcomma</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/background2.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">luo's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">luo</a><a class="site-page" href="/archives">时间线</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">数据结构-符号表</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-12-07</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">20.6k</span><span class="post-meta__separator">|</span><span>阅读时长: 74 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="1-前言"><a class="markdownIt-Anchor" href="#1-前言"></a> 1 前言</h2>
<p>最近在学习《算法4》第三章<strong>查找</strong>，里面讲述了现代应用常用的一种抽象结构<strong>符号表</strong>以及符号表的几种实现，本文仅是自己学习的记录，如有不当，欢迎指正。</p>
<p>现代计算机和网络使得我们能够访问<strong>海量</strong>的信息。<strong>高效检索</strong>这些信息的能力是处理它们的重要前提。</p>
<p>我们使用<strong>符号表</strong>这个词来描述一张抽象的表格，我们会将信息(<strong>也称之为值</strong>)存储在其中，然后按照指定的<strong>键</strong>来搜索并获取这些信息。键和值的具体意义取决于不同的应用。</p>
<p>符号表有时也被称为<strong>字典</strong>，例如在英语字典中，<code>键就是单词，值就是单词所对应的定义和注解</code>。</p>
<p>符号表有时又叫做<strong>索引</strong>，在一本书中，<code>键是术语，而值是对应的页面</code>。</p>
<p>本章说明了基本的API和两种重要实现后，会学习三种经典的<strong>数据类型</strong>实现<strong>高效的符号表</strong>：二叉查找树，红黑树和散列表。</p>
<span id="more"></span>
<h2 id="2-符号表"><a class="markdownIt-Anchor" href="#2-符号表"></a> 2 符号表</h2>
<p>符号表最主要的目的就是将一个键和一个值联系起来。并希望能够将一个<strong>键值对插入符号表</strong>，且插入之后能从符号表的所有键值对中<strong>按照键直接找到相对应的值</strong>。</p>
<blockquote>
<p>定义：符号表是一种<strong>存储键值对</strong>的数据结构，支持两种操作：<strong>插入</strong>(put): 将一组新的键值对存入表中；<strong>查找</strong>(get)：根据指定的键，返回对应的值。</p>
</blockquote>
<p>一些典型的符号表应用：</p>
<table>
<thead>
<tr>
<th style="text-align:left">符号表应用</th>
<th>查找的目的</th>
<th>键 Key</th>
<th>值 Val</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">字典</td>
<td>找出单词的释义</td>
<td>单词</td>
<td>释义</td>
</tr>
<tr>
<td style="text-align:left">图书索引</td>
<td>找出相关的页码</td>
<td>术语</td>
<td>页码</td>
</tr>
<tr>
<td style="text-align:left">文件共享</td>
<td>找到歌曲的下载地址</td>
<td>歌曲名</td>
<td>下载地址</td>
</tr>
<tr>
<td style="text-align:left">账户管理</td>
<td>处理交易</td>
<td>账户号码</td>
<td>交易详情</td>
</tr>
<tr>
<td style="text-align:left">网络搜索</td>
<td>找出相关的网页</td>
<td>关键词</td>
<td>网页名称</td>
</tr>
<tr>
<td style="text-align:left">编译器</td>
<td>找出符号的类型和值</td>
<td>变量名</td>
<td>类型和值</td>
</tr>
</tbody>
</table>
<h3 id="21-api"><a class="markdownIt-Anchor" href="#21-api"></a> 2.1 API</h3>
<p>符号表是一种典型的<strong>抽象数据类型</strong>; 代表着一组定义清晰的值以及相应的操作，使得我们能够将<strong>类型的实现和使用</strong>区分开，通过泛型符号表API，暂时忽略掉键和值的具体类型，先把注意力集中到操作上。</p>
<p>以下是一种简单的泛型符号表API</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ST</span>&lt;<span class="title">Key</span>,<span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line">    ST()  <span class="comment">//创建一张符号表</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value val)</span> <span class="comment">//将键值对插入表中</span></span></span><br><span class="line"><span class="function">    Value <span class="title">get</span><span class="params">(Key key)</span> <span class="comment">//获取键key对应的值，不存在则返回null</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span>  <span class="comment">//从表中删除对应的键及其对应的值</span></span></span><br><span class="line"><span class="function">    <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Key key)</span> <span class="comment">//键key在表中是否有对应的值</span></span></span><br><span class="line"><span class="function">    <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>  <span class="comment">//表是否为空</span></span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>  <span class="comment">//表的大小</span></span></span><br><span class="line"><span class="function">    Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">()</span> <span class="comment">//表中所有键的集合</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>首先讨论一下API到具体实现中需要注意的几个<strong>设计决策</strong></p>
<ol>
<li><strong>泛型</strong> 泛型的使用使得了一次代码，到处使用称为了现实。对于符号表，我们在创建时，通过明确地指定<strong>键和值的类型</strong>来区分它们的不同角色，比如说键是单词类型，而值是对应单词的注解，那么这个新创建的表自然就是一本<strong>字典</strong>，而如果指定键是<strong>术语</strong>，而值是对应的页码，那么该新创建的表则可以充当是一本书的<strong>索引</strong>。</li>
<li><strong>重复的键</strong>：我们遵循以下规则:
<ul>
<li>每个键只对应着一个值，即<strong>表中不允许有重复的键</strong>。</li>
<li>当我们插入一个新的键值对时，发现该键已经存在于表中了，我们就用<strong>新的值代替旧的值</strong>。</li>
</ul>
</li>
<li><strong>空键</strong> 我们规定键不能为空，使用空键为空会产生一个运行时异常。</li>
<li><strong>空值</strong> 我们还规定不允许有空值。这个规定的直接原因是在我们的API定义中，当键不存在时get()方法会返回<strong>null</strong>。这个规定给我们带来了两个好处：1是可以通过判断get()方法是否返回空来判断给定的键是否存在于符号表中 2 是当我们删除一个key以及它对应的val时，我们可以通过put(key,null)来实现对key的删除，进而实现<strong>延时删除</strong>。</li>
<li><strong>删除操作</strong> 在符号表中，删除的实现可以有两种方法，<strong>延时删除</strong>，也就是先将键对应的值置为空，然后再某个时候再删去所有值为空的键。也可以实现为<strong>即时删除</strong>，也就是立刻从表中删除指定的键。</li>
<li><strong>键的等价性</strong>  要确定一个键是否存在于符号表中，我们首先需要建立<code>对象等价性</code>的概念，如何判断传入的key和表中的key是相等的或不等的呢？在JAVA中，按照约定所有的对象都继承了一个equals()方法，可以通过equals方法来判断两个key是否相等。</li>
</ol>
<h3 id="22-有序符号表"><a class="markdownIt-Anchor" href="#22-有序符号表"></a> 2.2 有序符号表</h3>
<p>上面提到的API是最基本的，无序的符号表实现的一些基本方法。然而在现实生活中的典型的应用程序中，键一般都是<strong>可比较的</strong>。为了查找的方便，常常会对键进行排序(如英语字典自然是按字母先后顺序的，这样查找起来才方便嘛)，因此抽象到我们的数据结构中，体现为<code>键都是Comparable</code>的对象，因此我们可以通过a.compareTo(b)来比较a和b两个键。</p>
<p>基于此，我们书写一种<strong>有序的泛型符号表的API</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">key</span>&gt;, <span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line">    ST()  <span class="comment">//创建一张符号表</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value val)</span> <span class="comment">//将键值对插入表中</span></span></span><br><span class="line"><span class="function">    Value <span class="title">get</span><span class="params">(Key key)</span> <span class="comment">//获取键key对应的值，不存在则返回null</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span>  <span class="comment">//从表中删除对应的键及其对应的值</span></span></span><br><span class="line"><span class="function">    <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Key key)</span> <span class="comment">//键key在表中是否有对应的值</span></span></span><br><span class="line"><span class="function">    <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>  <span class="comment">//表是否为空</span></span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>  <span class="comment">//表的大小</span></span></span><br><span class="line"><span class="function">    Key <span class="title">min</span><span class="params">()</span>  <span class="comment">//最小的键</span></span></span><br><span class="line"><span class="function">    Key <span class="title">max</span><span class="params">()</span>  <span class="comment">//最大的键</span></span></span><br><span class="line"><span class="function">    Key <span class="title">floor</span><span class="params">(Key key)</span> <span class="comment">//小于等于key的最大键</span></span></span><br><span class="line"><span class="function">    Key <span class="title">ceiling</span><span class="params">(Key key)</span><span class="comment">//大于等于key的最小键</span></span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span>   <span class="comment">//小于key的键的数量</span></span></span><br><span class="line"><span class="function">    Key <span class="title">select</span><span class="params">(<span class="keyword">int</span> k)</span> <span class="comment">// 排名为key的键</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span>  <span class="comment">//删除最小的键</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">deleteMax</span><span class="params">()</span>  <span class="comment">//删除最大的键</span></span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> <span class="title">size</span><span class="params">(Key lo,Key hi)</span>  <span class="comment">//[lo....hi]之间键的数量</span></span></span><br><span class="line"><span class="function">    Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">(Key lo,Key hi)</span> <span class="comment">//[lo..hi]之间的所有键，已排序</span></span></span><br><span class="line"><span class="function">    Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">()</span> <span class="comment">//表中所有键的集合    </span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>重点看<strong>排名</strong>和<strong>选择</strong>，检测一个新的键是否插入合适的位置的基本操作是<strong>排名</strong>(rank，找出小于指定键的键的数量，<strong>返回的位置就是指定键插入的位置</strong>)  和 <strong>选择</strong>(select，找出排名为k的键)，并且有对于0到size()-1的所有i都有<code>i == rank(select(i))</code>且有<code>key=select(rank(key))</code>。</p>
<p>同时还实现了<strong>范围查找</strong>，给定两个键，在这两个键之间有多少键，有哪些键？在很多应用特别大型数据库中，能够处理这类查询是有序符号表在实践中被广泛应用的重要原因之一。</p>
<p><strong>再谈键的等价性</strong>：前面提到，键的等价性我们通过equals来进行判断。而JAVA的一条最佳实践就是维护所有Comparable类型中的compareTo()方法和equals()方法的<strong>一致性</strong>。也就是说，任何一种Comparable类型的两个值a和b都要a.compareTo(b)==0 和a.equals(b)的返回值的相同。为了避免潜在的二义性，我们只会使用compareTo()方法来比较两个键。</p>
<h3 id="23-无序链表中的顺序查找"><a class="markdownIt-Anchor" href="#23-无序链表中的顺序查找"></a> 2.3 无序链表中的顺序查找</h3>
<p>符号表中使用的数据结构的一个简单选择是<strong>链表</strong>，每个结点存储一个<strong>键值对</strong>，如下面的代码所示：</p>
<p>get()的实现即是<strong>遍历链表</strong>，用equals()方法比较待查找的键和每个结点中键，匹配成功我们就返回对应的值，都不能匹配则返回null。</p>
<p>put()的实现同样也是<strong>遍历</strong>链表，如果匹配成功我们就用第二个参数指定的值<strong>更新</strong>该键对应的原来的值，否则我们就用<strong>给定的键值对创建一个新的结点并插入到链表的开头</strong>。这种方法也称之为<strong>顺序</strong>查找。</p>
<p>基于链表的符号表的索引用例的轨迹如图：</p>
<img src="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%A6%E5%8F%B7%E8%A1%A8/查找Blog图_1.jpg" alt="查找Blog图_1" style="zoom:25%;">
<p><strong>无序链表实现的符号表</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Chapter2_Search;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.Algorithm.Chapter1.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序查找，基于无序链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequentialSearchST</span> &lt;<span class="title">Key</span>,<span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//The size of List</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="comment">// 链表节点的定义</span></span><br><span class="line">        Key key;</span><br><span class="line">        Value val;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//有参构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value val, Node next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Node x=first;x!=<span class="keyword">null</span>;x=x.next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(key.equals(x.key))&#123;</span><br><span class="line">                <span class="keyword">return</span> x.val; <span class="comment">//命中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  <span class="comment">//未命中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Node x=first;x!=<span class="keyword">null</span>;x=x.next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(key.equals(x.key))&#123;</span><br><span class="line">                x.val=val;  <span class="comment">//命中，修改原值</span></span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        first=<span class="keyword">new</span> Node(key,val,first); <span class="comment">//  未命中，新建一个Node， 且该Node成为了新的first</span></span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Node x=first;x!=<span class="keyword">null</span>;x=x.next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(key.equals(x.key))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N==<span class="number">0</span>?<span class="keyword">true</span>:<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(key.equals(first.key))&#123;</span><br><span class="line">            Node tem=first;</span><br><span class="line">            first=first.next;</span><br><span class="line">            tem=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Node pre=first,x=first.next;x!=<span class="keyword">null</span>;x=x.next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(key.equals(x.key))&#123;</span><br><span class="line">                pre.next=x.next;</span><br><span class="line">                x=<span class="keyword">null</span>;</span><br><span class="line">                N--;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            pre=pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Queue&lt;Object&gt; queue=<span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Node i=first;i!=<span class="keyword">null</span>;i=i.next)&#123;</span><br><span class="line">            queue.enqueue(i.key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (Iterable&lt;Key&gt;) queue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找一个<strong>已经存在</strong>的键并不需要线性级别的时间，一种度量方法是查找表的中每个键，并将总时间除以N。在查找表中的<strong>每个键的可能性都相同的情况下时</strong>，这个结果就是<code>一次查找平均所需要的比较数</code>,我们称之为<strong>随机命中</strong>。尽管符号表中用例的查找位置不大可能是随机的，但这个模型也可以适应的很好，我们容易得到<code>随机命中所需的平均比较次数为~N/2</code>。算法中第一个键需要1次比较，第二键需要2次比较，一次类推，<code>平均比较次数为</code>(1+2+3+4+5+6+…+N)/N=(N+1)/2~N/2。</p>
<blockquote>
<p>推论：向一个空表中插入N个不同的键需要~<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">N^2/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord">2</span></span></span></span>次比较。</p>
</blockquote>
<p>分析证明了基于链表的实现的符号表的顺序查找是非常低效的，特别是在巨型表中,N常常非常巨大。</p>
<h3 id="24-有序数组的二分查找"><a class="markdownIt-Anchor" href="#24-有序数组的二分查找"></a> 2.4 有序数组的二分查找</h3>
<p>下面我们要学习有序符号表API的完整实现。它使用的数据结构是<strong>一对平行的数组</strong>。一个存储键一个存储值，算法BinarySearchST可以保证数组中Comparable类型的<strong>键有序</strong>，然后使用数组的<strong>索引</strong>高效地实现get()和其他操作。</p>
<p>这份代码实现的核心的<strong>rank</strong>方法，它返回表中小于给定键的键的数量，对应get方法，只要给定的键存在表中，rank方法就能精确地告诉我们在哪里找到它(<strong>返回对应的下标</strong>)</p>
<p>对于put方法，只要给定的键存在于表中，rank()方法同样能精确地告诉我们到哪里去更新它的值(返回精确的<strong>下标</strong>)，以及键不存在时应该将键放在何处(<strong>就放在返回的下标的位置</strong>)，我们将所有更大的键向后移动一格来腾出位置(<strong>从后向前移动</strong>)并将给定的键值对分别插入到各自数组的合适位置。</p>
<p>基于<strong>有序数组</strong>的符号表实现的索引用例的轨迹如下图:</p>
<img src="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%A6%E5%8F%B7%E8%A1%A8/查找Blog图_2.jpg" alt="查找Blog图_1" style="zoom:25%;">
<p><strong>基于有序数组实现的符号表</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchST</span> &lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;,<span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Key[] keys;</span><br><span class="line">    <span class="keyword">private</span> Value[] vals;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinarySearchST</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        keys = (Key[]) <span class="keyword">new</span> Comparable[capacity];</span><br><span class="line">        vals = (Value[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinarySearchST</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小于 key的键值，等于key在键数组中对应的索引位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> h=N-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=h)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=l+(h-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cmp=key.compareTo(keys[mid]);</span><br><span class="line">            <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                h=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=rank(key);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;N &amp;&amp; keys[i].compareTo(key)==<span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> vals[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=rank(key);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;N &amp;&amp; keys[i].compareTo(key)==<span class="number">0</span>)&#123;</span><br><span class="line">            vals[i]=val;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=N;j&gt;i;j--)&#123;</span><br><span class="line">            keys[j]=keys[j-<span class="number">1</span>];</span><br><span class="line">            vals[j]=vals[j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        keys[i]=key;</span><br><span class="line">        vals[i]=val;</span><br><span class="line">        N++;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=rank(key);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;N &amp;&amp; key.compareTo(keys[i])==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;N-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                keys[j]=keys[j+<span class="number">1</span>];</span><br><span class="line">                vals[j]=vals[j+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            keys[N]=<span class="keyword">null</span>;</span><br><span class="line">            vals[N]=<span class="keyword">null</span>;</span><br><span class="line">            N--;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=rank(key);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;N &amp;&amp; key.compareTo(keys[i])==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> keys[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">max</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> keys[N-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//小于等于key的最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">floor</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=rank(key);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;N &amp;&amp; keys[i].compareTo(key)==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> keys[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ((i-<span class="number">1</span>)&lt;N)?keys[i-<span class="number">1</span>]:<span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//大于等于key的最小键值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">ceiling</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=rank(key);</span><br><span class="line">        <span class="keyword">return</span> i&lt;N?keys[i]:<span class="keyword">null</span>; <span class="comment">//key比所有值都大时返回null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查询索引值为k的键,为rank的逆</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">select</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;<span class="number">0</span> || k&gt;=N)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> keys[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        delete(min());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        delete(max());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(Key lo,Key hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo.compareTo(hi)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=rank(lo);</span><br><span class="line">        <span class="keyword">int</span> j=rank(hi);</span><br><span class="line">        <span class="keyword">if</span>(j&lt;N &amp;&amp; keys[j].compareTo(hi)==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> j-i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j-i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">(Key lo,Key hi)</span></span>&#123;</span><br><span class="line">        Queue&lt;Key&gt; q=<span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=rank(lo);i&lt;rank(hi);++i)&#123;</span><br><span class="line">            q.enqueue(keys[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(contains(hi))&#123;</span><br><span class="line">            q.enqueue(keys[rank(hi)]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys(min(),max());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用有序数组存储键的原因是，我们在查找的时候可以使用<strong>二分查找</strong>，我们基于二分查找实现了其他方法的基石：<strong>rank</strong>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rank方法迭代版本</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> h=N-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=h)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=l+(h-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cmp=key.compareTo(keys[mid]);</span><br><span class="line">            <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                h=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rank方法递归版本</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(hi&lt;lo)&#123;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=lo+(hi-lo)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> cmp=key.compareTo(keys[mid]);</span><br><span class="line">    <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> rank(key,lo,mid-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>（cmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> rank(key,mid+<span class="number">1</span>,hi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在有序数组中使用二分法查找排名的轨迹如下图:</p>
<img src="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%A6%E5%8F%B7%E8%A1%A8/查找Blog图_3.jpg" alt="查找Blog图_1" style="zoom:25%;">
<p><strong>rank</strong>方法的递归实现还能够让我们立即得到一个结论：<strong>二分查找很快</strong>，在N个键的有序数组进行二分查找最多需要(lgN+1)次比较，无论是否成功。</p>
<p>在给出的方法的实现中，ceiling方法调用了一次rank，而接受两次参数的默认size方法调用了两次rank，因此也保证了这次操作所需的时间最多是<strong>对数级别</strong>的。而min()，max()，和select()操作所需的时间都是常数级别的，这是数组的特性：<strong>快速访问</strong>。</p>
<p>下图是<strong>BinarySearchST的操作的成本</strong>:</p>
<img src="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%A6%E5%8F%B7%E8%A1%A8/查找Blog图_4.jpg" alt="查找Blog图_1" style="zoom:15%;">
<p>尽管BinarySearchST能够保证查找所需的时间是对数级别的，但BinarySearch仍然无法支持我们构建大型的符号表去处理大型的问题。<code>因为put方法太慢了</code>。二分查找减少了比较的次数，但它无法改变一下事实：<code>在键是随机排列的情况下，构造一个基于有序数组的符号表所需要访问数组的次数是数组长度的平方级别的</code>。</p>
<p>一般情况下二分查找都比顺序查找快得多，有时候也是实际应用程序的一个好的选择，对于一个<strong>静态表</strong>(初始化之后不再允许插入了)来说，将其在初始化时就排序，我们在初始化时花费平方级别的时间完成初始化，<strong>之后的查找只需花费对数级别的时间</strong>，在一些应用中这样的花费是可以接受的。当然，二分查找不适合很多应用，如<strong>查找</strong>和<strong>插入</strong>操作是混合进行的。</p>
<p>现代应用需要同时能够支持<code>高效的查找和插入</code>两种操作的符号表实现，也就是说，我们在构造庞大的符号表的同时能够任意的<strong>插入，删除，查找</strong>键值对。</p>
<p>下表是简单的符号表的成本总结：</p>
<img src="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%A6%E5%8F%B7%E8%A1%A8/查找Blog图_5.jpg" alt="查找Blog图_" style="zoom:25%;">
<p>核心的问题在于我们能否找到同时保证<code>查找和插入操作</code>都是<strong>对数级别</strong>的算法和数据结构，答案是<strong>可以</strong>。</p>
<p>我们如何实现这个目标呢？要支持高效的插入操作，我们似乎需要一种<strong>链式结构</strong>，而要支持高效的查找操作，我们希望数据结构可以使用<strong>二分查找</strong>。但单链表是无法使用二分查找的，因为二分查找的高效操作来自于<strong>快速通过索引</strong>取得任何子数组的<strong>中间元素</strong>，但得到一条单链表的中间元素的唯一方法只能是<strong>沿链表遍历</strong>。</p>
<p>为了将二分查找的效率和链表插入的灵活性结合起来，我们需要更复杂的数据结构，能够同时拥有两者的就是<code>二叉查找树</code>。</p>
<h2 id="3-二叉查找树"><a class="markdownIt-Anchor" href="#3-二叉查找树"></a> 3 二叉查找树</h2>
<p>二叉查找树实现的符号表结合了<strong>链表插入的灵活性</strong>和<strong>有序数组查找的高效性</strong>。</p>
<p>我们所使用的数据结构由<strong>结点</strong>组成，节点包含的链接可以为空<strong>null</strong>或者指向其他结点。</p>
<p>在<strong>二叉树</strong>中，每个结点只能有一个父结点，<strong>根结点</strong>例外，每个结点都有<strong>左右</strong>两个链接，分别指向自己的<strong>左子结点</strong>和<strong>右子结点</strong>。</p>
<p>尽管指向的是下一个结点，我们可以有更大的视野，把每个链接看成指向了<strong>另一棵二叉树</strong>，而这棵树的根结点就是被指向的那个结点。</p>
<p>在二叉查找树中，每个结点还包含了一个键和一个值，键之间有顺序之分以支持<strong>高效的查找</strong>。</p>
<blockquote>
<p>定义: 一棵二叉查找树(BST)是一棵二叉树，其中每个结点都含有一个Comparable的键(以及对应的值)，且每个结点的键都<strong>大于左子树中的任意结点</strong>的键而<strong>小于右子树中任意的结点</strong></p>
</blockquote>
<p>通过二叉树的定义，我们看到，二叉树首先是链式结构的，可以支持<strong>高效的插入</strong>，同时，<code>每个结点的键都大于左子树中的任意结点的键而小于右子树中任意的结点</code>使得我们可以高效地找出<strong>中间值</strong>，实现<strong>二分查找</strong>而进行<strong>高效的查找</strong>。</p>
<h3 id="31-基本实现"><a class="markdownIt-Anchor" href="#31-基本实现"></a> 3.1 基本实现</h3>
<p>我们定义了二叉查找树的数据结构，并用它实现<strong>有序符号表</strong>的API。</p>
<h4 id="1-数据表示"><a class="markdownIt-Anchor" href="#1-数据表示"></a> 1 数据表示</h4>
<p>我们定义了一个结点类。每一个结点都含有一个键，一个值，一条左链接，一条右链接和一个<strong>结点计数器</strong>。左链接指向一棵由小于该节点的所有键构成的二叉查找树，右链接指向一棵由大于该结点的所有键组成的二叉查找树。</p>
<p>变量<strong>N</strong>给出了以该结点为根结点的子树的结点总数。</p>
<p>我们在算法中实现了私有方法size(Node x),返回以x为根结点的结点总数，有<code>size(x)=size(x.left)+size(x.right)+1</code></p>
<p>一棵二叉查找树代表了一组<strong>键的集合</strong>，而同一个集合可以用多课不同的二叉查找树树表示，如下图所示。</p>
<p>我们将一棵二叉查找树的所有键<strong>投影到一条直线上</strong>，我们一定可以得到一条<strong>有序的键列</strong>。</p>
<h4 id="2-查找"><a class="markdownIt-Anchor" href="#2-查找"></a> 2 查找</h4>
<p>首先给出查找算法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(root,key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Value <span class="title">get</span><span class="params">(Node x,Key key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp=key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> get(x.left,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cmp==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> x.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(x.right,key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般来说，在符号表中查找一个键可能的得到的有两种结果: 如果含有该键的结点存在于表中，我们的查找就<strong>命中</strong>，我们就可以返回相应的值。否则查找<strong>未命中</strong>，返回null。根据数据表示的递归结构我们马上就能得到在二叉查找树中<strong>查找一个键的算法</strong>: 如果树是空的，则查找未命中，返回null;如果被查找的键和当前根结点的键相等，<strong>查找命中</strong>。否则我们就递归地在左或右子树中继续寻找。</p>
<p>在二分查找中每次迭代之后查找的区间就会<strong>减少一半</strong>，而在我们的二叉查找树中，随着我们不断地向下查找，当前结点所表示的<strong>子树的大小也在减少</strong>，因为我们每次要么<strong>命中</strong>，要么根据待查找的键与根结点的键比较大小，从而<strong>只选择左子树</strong>或<strong>只选择右子树</strong>进行递归查找。我们理想的情况下是<strong>减少一半</strong>，但左子树和右子树不一定会相等，但可以肯定的是，查找范围至少会减少一个<strong>结点</strong>，也就是根结点。</p>
<p>当找到一个含有待查找的键的结点(<strong>命中</strong>)或者当前子树变为空(<strong>未命中</strong>)时这个递归过程才会结束。从根结点开始，在每个结点的查找，要么直接返回，要么在他的一个子结点上展开搜索，因此，<code>一次查找也就定义了树的一条路径</code>。对于成功命中的查找，路径在含有被查找的键的结点结束，而对于未命中的查找，路径最终是一个空链接。</p>
<p>二叉查找树中的查找命中和查找未命中情况如下：</p>
<img src="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%A6%E5%8F%B7%E8%A1%A8/查找Blog图_6.jpg" alt="查找Blog图_1" style="zoom:20%;">
<h4 id="3-插入"><a class="markdownIt-Anchor" href="#3-插入"></a> 3 插入</h4>
<p>我们可以看到，二叉查找树的查找代码几乎和二分查找的一样简单，这种<strong>简洁性</strong>是二叉查找树的重要特性之一。</p>
<p>而二叉查找树的另一个更重要的特性就是<strong>插入的实现难度和查找差不多</strong>。当查找一个不存在于树中的结点并结束于一条空链接时，我们需要做的就是将链接指向一个含有<strong>被查找的键的新结点</strong>，进而完成了插入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value val)</span></span>&#123;</span><br><span class="line">    root=put(root,key,val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node x,Key key,Value val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(key,val,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp=key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        x.left=put(x.left,key,val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cmp==<span class="number">0</span>)&#123;</span><br><span class="line">        x.val=val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        x.right=put(x.right,key,val);</span><br><span class="line">    &#125;</span><br><span class="line">    x.N=size(x.left)+size(x.right)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>put()方法的实现逻辑和<strong>二分递归查找</strong>的逻辑是相似的，如果树是空的，则返回一个含有该键值对的新结点;如果被查找的键小于根结点的键，我们递归在<strong>左子树中插入该键</strong>，否则在<strong>右子树中插入该键</strong>。因此，二叉查找树插入可以接近到查找的效率。</p>
<p>使用二叉查找树插入新建的轨迹：</p>
<img src="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%A6%E5%8F%B7%E8%A1%A8/查找Blog图_7.jpg" alt="查找Blog图_1" style="zoom:15%;">
<h3 id="32-分析"><a class="markdownIt-Anchor" href="#32-分析"></a> 3.2 分析</h3>
<p>使用二叉查找树的算法的运行时间取决于<strong>树的形状</strong>，而<code>树的形状又取决于键被插入的先后顺序</code>。在最好的情况下，一棵含有N个结点的树是<strong>完全平衡的</strong>，每条空链接和根结点的距离都为~lgN。而在最坏的情况下，搜索路径上可能有N个结点，也称二叉查找树<strong>退化为链表了</strong>，但在一般情况下树的形状和最好的情况更接近。</p>
<p>如图3.2.7：</p>
<img src="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%A6%E5%8F%B7%E8%A1%A8/查找Blog图_8.jpg" alt="查找Blog图_1" style="zoom:15%;">
<p>一些命题：</p>
<blockquote>
<p>命题C：在由N个随机键构造的二叉查找树中，查找命中平均所需要的比较次数为~2lnN(约为1.39lgN)</p>
</blockquote>
<blockquote>
<p>命题D：在由N个随机键构造的二叉查找树中，<strong>插入</strong>和<strong>查找未命中</strong>平均所需要的比较一次为~2lnN(约为1.39lgN)</p>
</blockquote>
<p>命题C说明了在二叉查找树查找随机键的成本比<strong>二分查找高39%</strong>，而命题D则说明了这些额外的成本是<strong>值得的</strong>，因为插入一个新键的成本是对数级别的。</p>
<h3 id="33-有序性相关的方法与删除操作"><a class="markdownIt-Anchor" href="#33-有序性相关的方法与删除操作"></a> 3.3 有序性相关的方法与删除操作</h3>
<p>二叉查找树得以广泛应用的一个重要原因就是它能够保持<strong>键的有序性</strong>，因此它可以作为实现有序符号表API中的众多方法的基础。下面，我们研究有序符号表API中各个方法的实现</p>
<h4 id="1-最大键和最小键"><a class="markdownIt-Anchor" href="#1-最大键和最小键"></a> 1. 最大键和最小键</h4>
<p><strong>递归实现即可</strong>,比较简单</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> min(root).key;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> Node <span class="title">min</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(x.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> x;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> min(x.left);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Key <span class="title">max</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> max(root).key;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> Node <span class="title">max</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(x.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> x;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> max(x.right);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-向上取整和向下取整"><a class="markdownIt-Anchor" href="#2-向上取整和向下取整"></a> 2 向上取整和向下取整</h4>
<p>同样选择递归实现，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">floor</span><span class="params">(Key key)</span></span>&#123;  <span class="comment">//小于等于key的最大键</span></span><br><span class="line">       Node x=floor(root,key);</span><br><span class="line">       <span class="keyword">if</span>(x==<span class="keyword">null</span>)&#123;  <span class="comment">//找不到小于等于key的最大键，返回null</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> x.key;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">floor</span><span class="params">(Node x,Key key)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(x==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> cmp=key.compareTo(x.key);</span><br><span class="line">       <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> floor(x.left,key);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(cmp==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> x;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">           Node t=floor(x.right,key);  <span class="comment">//右子树中是否有小于等于key的键</span></span><br><span class="line">           <span class="keyword">if</span>(t!=<span class="keyword">null</span>)&#123;  <span class="comment">//有的话右子树中小于等于key的最大键就是整棵树中小于等于key的最大键</span></span><br><span class="line">               <span class="keyword">return</span> t;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">return</span> x;  <span class="comment">//没有的话根结点的键就是整棵树中小于等于key的最大键</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//大于等于key的最小键盘</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Key <span class="title">ceiling</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">       Node t=ceiling(root,key);</span><br><span class="line">       <span class="keyword">if</span>(t!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> t.key;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">ceiling</span><span class="params">(Node x,Key key)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(x==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> cmp=key.compareTo(x.key);</span><br><span class="line">       <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">           Node t=ceiling(x.left,key);</span><br><span class="line">           <span class="keyword">if</span>(t!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> t;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">return</span> x;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(cmp==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> x;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> ceiling(x.right,key);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-选择操作和排名操作"><a class="markdownIt-Anchor" href="#3-选择操作和排名操作"></a> 3 选择操作和排名操作</h4>
<p>我们在二叉查找树中的每个结点维护着<strong>子树结点计数器变量N</strong>就是来支持次操作的。</p>
<p>完整实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rank(root,key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Node x,Key key)</span></span>&#123;  <span class="comment">//返回以x根节点的子树中小于x.key的数量</span></span><br><span class="line">    <span class="keyword">if</span>(x==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp=key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> rank(x.left,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cmp==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> size(x.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+size(x.left)+rank(x.right,key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">select</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123; <span class="comment">//返回排名为k的节点键</span></span><br><span class="line">    <span class="keyword">return</span> select(root,k).key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">select</span><span class="params">(Node x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t=size(x.left);</span><br><span class="line">    <span class="keyword">if</span>(t&gt;k)&#123;</span><br><span class="line">        <span class="keyword">return</span> select(x.left,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t==k)&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> select(x.right,k-t-<span class="number">1</span>);  <span class="comment">//之所以要-1，因为根结点也要算进去</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-删除最大键和删除最小键"><a class="markdownIt-Anchor" href="#4-删除最大键和删除最小键"></a> 4 删除最大键和删除最小键</h4>
<p>删除最大键和删除最小键并不会破坏掉树的有序性，直接删除即可，不再需要其他的操作保证树的完整性，实现比较简单，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span></span>&#123; <span class="comment">//删除最小值</span></span><br><span class="line">     <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">     root=deleteMin(root);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> Node <span class="title">deleteMin</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(x.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> x.right;  <span class="comment">//根节点无左子女，右子女成为了新的根</span></span><br><span class="line">     &#125;</span><br><span class="line">     x.left=deleteMin(x.left);</span><br><span class="line">     x.N=size(x.left)+size(x.right)+<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">return</span> x;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">     root=deleteMax(root);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> Node <span class="title">deleteMax</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(x.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> x;</span><br><span class="line">     &#125;</span><br><span class="line">     x.right=deleteMax(x.right);</span><br><span class="line">     x.N=size(x.left)+size(x.right)+<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">return</span> x;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-删除操作"><a class="markdownIt-Anchor" href="#5-删除操作"></a> 5 删除操作</h4>
<p>我们可以使用类似删除最大值和最小值的方法删除<strong>只有一个结点或者没有子结点</strong>的结点，但如何删除一个<strong>拥有两个子结点的结点呢</strong>？删除之后我们需要处理两棵子树，而被删除的结点的父结点值有一条空出来的链接。</p>
<p>我们采用这样的方法：在删除结点x后用它的<strong>后继结点</strong>填补它的位置，因为x有一个右子结点，因此它的后继结点就是<strong>右子树中的最小结点</strong>。这样的替换可以保持树的有序性，我们可以用4个步骤完成将x替换为它的后继结点的任务：</p>
<ol>
<li>将指向即将被删除的结点的链接保存为t</li>
<li>将x指向它的后继结点<strong>min(x.right)</strong></li>
<li>将x的右链接指向 deleteMin(t.right)</li>
<li>将x的左链接设为t.left，也就是被删除结点的左子树。</li>
</ol>
<p>在递归调用后我们会<strong>修正</strong>被删除的结点的父结点的链接，并将由此结点到根结点的路径上的所有结点的计数器减去1。</p>
<p>二叉查找树的删除操作如图：</p>
<img src="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%A6%E5%8F%B7%E8%A1%A8/查找Blog图_9.jpg" alt="查找Blog图_1" style="zoom:20%;">
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">       root=delete(root,key);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">delete</span><span class="params">(Node x,Key key)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(x==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> cmp=key.compareTo(x.key);</span><br><span class="line">       <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">           x.left=delete(x.left,key);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(cmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           x.right=delete(x.right,key);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>&#123; <span class="comment">//找到要删除的结点</span></span><br><span class="line">           <span class="keyword">if</span>(x.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> x.right;  <span class="comment">//只有单子结点</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(x.right==<span class="keyword">null</span>)&#123;  <span class="comment">//只有单子结点</span></span><br><span class="line">               <span class="keyword">return</span> x.left;</span><br><span class="line">           &#125;</span><br><span class="line">           Node t=x;  <span class="comment">//t临时存储被删除的结点t</span></span><br><span class="line">           x=min(t.right);  <span class="comment">//找到被删除结点的后续节点,x刚好替换在被删除元素的位置上</span></span><br><span class="line">           x.right=deleteMin(t.right);</span><br><span class="line">           x.left=t.left;           <span class="comment">//这两句最为关键,维持了二叉搜索树的有序性</span></span><br><span class="line">       &#125;</span><br><span class="line">       x.N=size(x.left)+size(x.right)+<span class="number">1</span>;  <span class="comment">//维护N</span></span><br><span class="line">       <span class="keyword">return</span> x;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-范围查找"><a class="markdownIt-Anchor" href="#6-范围查找"></a> 6 范围查找</h4>
<p>要实现能够返回给定范围内键的<strong>keys()<strong>方法，我们可以采用树的</strong>中序遍历</strong>，先递归打印树的左子树，打印根结点，再打印树的右子树。</p>
<p>我们还要实现一个<strong>接受两个参数</strong>并能够将给定范围内的键返回给用例的keys()方法，我们可以修改一下这段代码，将所有落在给定范围以内的键加入一个队列Queue并跳过那些不可能含有所查找键的子树。</p>
<p>如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">(Key lo,Key hi)</span></span>&#123;</span><br><span class="line">    Queue&lt;Key&gt; queue=<span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">    keys(root,queue,lo,hi);</span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> keys(min(),max());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">keys</span><span class="params">(Node x, Queue&lt;Key&gt; queue,Key lo,Key hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmplo=lo.compareTo(x.key);</span><br><span class="line">    <span class="keyword">int</span> cmohi=hi.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span>(cmplo&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        keys(x.left,queue,lo,hi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cmplo&lt;=<span class="number">0</span> &amp;&amp; cmohi&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        queue.enqueue(x.key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cmohi&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        keys(x.right,queue,lo,hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="34-性能分析"><a class="markdownIt-Anchor" href="#34-性能分析"></a> 3.4 性能分析</h3>
<p>二叉查找树和有序性相关的操作的效率如何？我们首先需要知道<strong>树的高度</strong>，给定一棵树，树的高度决定了所有操作在最坏情况下的性能(范围查找出外，因为它的额外成本和返回的键的数量成正比)。</p>
<blockquote>
<p>命题E：在一棵二叉查找树中，所有操作在最坏情况下所需的时间都与树的高度成正比。</p>
</blockquote>
<p>总的来说，二叉查找树的实现并不困难，且当树的构造和随机模型近似时在各种实际应用场景中它都可以进行<strong>快速的查找和插入</strong>。同时，它还支持高效的rank()，select()，delete()以及范围查找等操作。但同时，当在某些场景中二叉查找树发生退化，在最坏情况下的恶劣性能是不可接受的。这是我们寻找更好的算法和数据结构的主要原因。</p>
<h2 id="4-平衡查找树"><a class="markdownIt-Anchor" href="#4-平衡查找树"></a> 4 平衡查找树</h2>
<p>我们在前面学习过的算法已经能够很好地应用于许多应用程序中，但它们在<strong>最坏情况下</strong>的性能还是很糟糕。</p>
<p>我们希望对二分查找树进行改进，使得在<strong>最坏情况下</strong>也能保持较高效的性能。</p>
<p>理想情况下我们希望能够保持二分查找树的<strong>平衡性</strong>。在一棵含有N个结点的树中，我们希望树高为~lgN。</p>
<h3 id="41-2-3查找树"><a class="markdownIt-Anchor" href="#41-2-3查找树"></a> 4.1 2-3查找树</h3>
<p>为了保证查找树的平衡性，我们需要一些灵活性，因此在这里我们运行树中的<strong>一个结点可以保存多个键</strong>，确切的说，我们将一棵标准的二叉查找树的结点称为2-结点(<strong>含有一个键和两条链接</strong>)，而现在我们引入3-结点，它包含了两个键和三条链接。2-结点和3-结点中的每条链接都对应着其中保存的键<strong>所分割产生的一个区间</strong>。</p>
<blockquote>
<p>定义：一棵2-3查找树或成为一棵空树，或由以下结点组成：</p>
<ul>
<li>2-结点：含有一个键(及其对应的值)和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。</li>
<li>3-结点：含有两个键(及其对应的值)和三条链接，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。</li>
</ul>
</blockquote>
<p>2-3查找树示意图如下：</p>
<img src="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%A6%E5%8F%B7%E8%A1%A8/查找Blog图_10.jpg" alt="查找Blog图_1" style="zoom:25%;">
<p><code>一棵完美平衡的2-3查找树的所有空链接到根结点的距离都应该是相同的</code>。</p>
<h4 id="1-查找"><a class="markdownIt-Anchor" href="#1-查找"></a> 1 查找</h4>
<p>2-3查找树的查找算法原理是与二叉查找树基本一样的。要判断一个键是否存在树中，先将键与根结点中的键比较，如果相等，则<strong>查找命中</strong>；否则我们就根据比较结果定位到相应的区间，左链接？中链接？还是右链接？再到子树中继续递归地查找。如果子树为空链接，则<strong>查找未命中</strong>。</p>
<p>查找过程如图3.3.2所示:</p>
<img src="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%A6%E5%8F%B7%E8%A1%A8/查找Blog图_11.jpg" alt="查找Blog图_1" style="zoom:25%;">
<h4 id="2-向2-结点中插入新键"><a class="markdownIt-Anchor" href="#2-向2-结点中插入新键"></a> 2 向2-结点中插入新键</h4>
<p>要在2-3树中插入一个新结点，我们可以和二叉查找树一样先进行一次未命中的查找，然后新结点挂在树的底部，但这样的话树无法保持<strong>完美平衡性</strong>。我们使用2-3树的主要原因就在于它<strong>能够在插入后继续保持平衡</strong>。如何未命中的查找结束于一个2-结点，就比较好处理，我们只需要把这个2-结点替换成一个3-结点，将要插入的键保存在其中即可，这样树的高度不会发生变化，自然会<strong>继续保持平衡</strong>。</p>
<p>向2-结点中插入新的键如图3.3.3所示:</p>
<img src="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%A6%E5%8F%B7%E8%A1%A8/查找Blog图_12.jpg" alt="查找Blog图_1" style="zoom:25%;">
<h4 id="3-向一棵只含有一个3-结点的树中插入新键"><a class="markdownIt-Anchor" href="#3-向一棵只含有一个3-结点的树中插入新键"></a> 3 向一棵只含有一个3-结点的树中插入新键</h4>
<p>只含有一个3-结点的树插入新建，唯一结点中已经没有可以插入新建的<strong>空间了</strong>。为了将新键插入，我们临时将新键存入该结点，使之称为一个<strong>4-结点</strong>。它很自然地扩展了以前的结点并含有<strong>3个键</strong>和<strong>4条链接数</strong>。</p>
<p>创建一个4-结点很方便，我们也很容易将他转换为一棵由<strong>3个2-结点组成的2-3树</strong>。这棵树既是一棵含有3个结点的二叉查找树，同时也是一棵完美的<strong>二叉平衡树</strong>，插入前树的高度为0，插入后树的高度为1。这个例子很简单，但却说明了<code>2-3树是如何生长的</code>？<strong>2-3树是向上生长的</strong>！</p>
<p>如图3.3.4</p>
<img src="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%A6%E5%8F%B7%E8%A1%A8/查找Blog图_13.jpg" alt="查找Blog图_1" style="zoom:25%;">
<h4 id="4-向一个父结点为2-结点的3-结点中插入新键"><a class="markdownIt-Anchor" href="#4-向一个父结点为2-结点的3-结点中插入新键"></a> 4 向一个父结点为2-结点的3-结点中插入新键</h4>
<p>假设未命中的查找结束于一个3-结点，而它的父结点是一个2-结点。在这种情况下我们需要在<strong>维持树的完美平衡的前提下为新键腾出空间</strong>。</p>
<p>我们像先前一样构造一个临时的4-结点，并将其分解，但此时我们不会为<strong>中键</strong>创建一个新结点，而是将其移动到原来的2-父结点中，使得父结点称为了一个3-结点。</p>
<p>这次转换并不影响<strong>2-3查找树</strong>的有序性，也不影响树的<strong>完美平衡</strong>性，插入后所有的空链接到根结点的距离仍然相同。</p>
<p>如图3.3.5</p>
<img src="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%A6%E5%8F%B7%E8%A1%A8/查找Blog图_14.jpg" alt="查找Blog图_1" style="zoom:25%;">
<p>这个转换是2-3树<strong>动态变化的核心</strong>。</p>
<h4 id="5-向一个父结点为3-结点的3-结点插入新键"><a class="markdownIt-Anchor" href="#5-向一个父结点为3-结点的3-结点插入新键"></a> 5 向一个父结点为3-结点的3-结点插入新键</h4>
<p>再一步，假设未命中的查找结束于一个父结点为3-结点的3-结点，此时父结点已经没有额外的空间了，这时候该怎么办？</p>
<p>我们再次和上面一样构造一个临时的4-结点，然后依旧将它的中键插入到它的父结点中，父结点此时也变成了一个4-结点，<strong>我们在父结点做相同的变换</strong>，即分解父结点并把父结点的中键插入到<strong>父结点的父结点</strong>中去，套娃…</p>
<p>一直不断地向上分解，直至<code>遇到一个2-结点并把它替换为一个不需要继续分解的3-结点</code>，或是<code>到达3-结点的根</code>。此时根如果也变成了4-结点，则分解根，实现了<strong>2-3树的一次生长</strong>。</p>
<p>插入过程如图3.3.6</p>
<img src="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%A6%E5%8F%B7%E8%A1%A8/查找Blog图_15.jpg" alt="查找Blog图_1" style="zoom:15%;">
<h4 id="6-分解根结点"><a class="markdownIt-Anchor" href="#6-分解根结点"></a> 6 分解根结点</h4>
<p>我们上面提到，如果从插入结点到根结点的路径上全是3-结点，我们的<strong>根结点最终将会变成一个临时的4-结点</strong></p>
<p>此时我们<strong>将临时的根4-结点分解为3个2-结点，使得树高加1，实现了树的生长</strong>。这次最后的变换仍然保持了树的完美平衡性，因为变换的是根结点，也说明了2-3查找树是<strong>向上生长的</strong>。</p>
<p>分解根结点过程如图3.3.7</p>
<img src="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%A6%E5%8F%B7%E8%A1%A8/查找Blog图_16.jpg" alt="查找Blog图_1" style="zoom:15%;">
<h4 id="7-局部变换"><a class="markdownIt-Anchor" href="#7-局部变换"></a> 7 局部变换</h4>
<p>将一个4-结点分解为一棵2-3树可能有6种情况，如图3.3.8。</p>
<p>2-3树插入算法的根本在于这些变换都是<strong>局部的</strong>。2-3树插入算法的根本在于这些<strong>变换都是局部的</strong>。除了相关的结点和链接之外不必修改或者是检查树的其他部分。每次更换中，变更的链接数量不会超过一个很小的常数，这大大降低的代码的复杂性。需要指出的是，不光是在树的底部，树中的<strong>任何地方</strong>只要符合相应的模式，变换都是可以进行的。每个变换都会将<strong>4-结点</strong>中的一个键送入它的父结点中，并重构相应的链接而不必涉及树的其他部分。</p>
<h4 id="8-全局性质"><a class="markdownIt-Anchor" href="#8-全局性质"></a> 8 全局性质</h4>
<p>这些<strong>局部变换</strong>不会影响到树的<strong>全局有序性和平衡性</strong>；任意空链接到根结点的路径长度都是相等的。</p>
<p>和标准的二叉树由上向下生长不同，我们反复提到2-3树的生长的<strong>由下往上</strong>的。在二叉查找树中，按照升序插入10个键会得到高度为9的一棵最差查找树(<strong>退化为链表了</strong>)，而使用了2-3查找树，树的高度是2。</p>
<p>2-3查找树似乎满足了我们的需求，在最坏的情况下，也能有对数级别的效率。</p>
<blockquote>
<p>命题F：在一棵大小为N的2-3查找树中，<strong>查找</strong>和<strong>插入</strong>操作访问结点必然不超过lgN个。因为2-3查找树是<strong>完全平衡树</strong>。</p>
</blockquote>
<p>如图3.3.10是 一棵 2-3查找树的构造轨迹：</p>
<img src="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%A6%E5%8F%B7%E8%A1%A8/查找Blog图_17.jpg" alt="查找Blog图_1" style="zoom:15%;">
<p>因此我们可以确定2-3树在<code>最坏情况</code>下仍有较好的性能。每个操作中处理每个结点的时间都不会超过一个很小的常数，且这两个操作都只会访问一条路径上的结点，所以<code>任何查找或者插入的成本</code>都肯定不会超过对数级别。</p>
<p>可以看到，完美平衡的2-3树要比二叉查找树<strong>平展得多</strong>(高度更低)。例如，在含有10亿个结点的一棵2-3树的高度仅仅在19到30之间，完美只需要访问30个结点就能够在10亿个键中进行任意的<strong>插入</strong>和<strong>查找</strong>，这是相当惊人的。</p>
<p>如图是一棵由随机键构造的一棵典型的2-3树</p>
<img src="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%A6%E5%8F%B7%E8%A1%A8/查找Blog图_18.jpg" alt="查找Blog图_1" style="zoom:25%;">
<p>但是，我们和真正的实现还有一段距离。我们希望找到一种简洁的2-3树实现的数据结构，只需要一点点代价就能用一种统一的方式完成从<strong>二叉查找树</strong>到<strong>2-3查找树</strong>的所有变换，这种数据结构是<strong>红黑二叉查找树</strong>。</p>
<h2 id="5-红黑二叉查找树"><a class="markdownIt-Anchor" href="#5-红黑二叉查找树"></a> 5 红黑二叉查找树</h2>
<p>上文所述的2-3树的插入算法并不难理解，现在我们会看到它的实现也不难，我们学习一种名为<strong>红黑二叉查找树</strong>的简单数据结构来表达并实现它。</p>
<h3 id="51-替换3-结点"><a class="markdownIt-Anchor" href="#51-替换3-结点"></a> 5.1 替换3-结点</h3>
<p>红黑二叉树背后的基本思想是用<strong>标准的二叉查找树</strong>(完全由2-结点构成)和一些额外的信息(<strong>表示3-结点</strong>)来表示2-3树。</p>
<p>我们将树中的<strong>链接分为两种类型</strong>：<strong>红链接</strong>将两个2-结点连接起来构成了一个3-结点。<strong>黑链接</strong>则是2-3树中的普通链接。</p>
<p>确切地说，我们将3-结点表示为<code>由一条左斜的红色链接相连的两个2-结点</code>，如图3.3.12所示。这种表示法的一个优点是，<strong>我们无需修改就可以直接使用标准二叉树的get()方法</strong>。对于任意2-3树，只要对结点进行转换，我们都可以立刻派生出一棵对应的二叉查找树。我们用这种方式表述2-3树的二叉查找树称为<strong>红黑二叉查找树</strong>，以下简称为<strong>红黑树</strong>。红黑树既是<strong>二叉查找树</strong>，又是<strong>2-3树</strong>。</p>
<h3 id="52-一种等价的定义"><a class="markdownIt-Anchor" href="#52-一种等价的定义"></a> 5.2 一种等价的定义</h3>
<p>红黑树的另一种定义是<strong>含有红黑链接</strong>并满足下列条件的二叉查找树：</p>
<ul>
<li>
<p><strong>红链接均为左链接</strong>  (红链接其实也可以为右链接，只是为了<strong>代码的简洁性</strong>，我们强制规定红链接均为左链接)</p>
</li>
<li>
<p><strong>没有任何一个结点同时和两条红链接相连</strong>。(否则就出现了<strong>4-结点</strong>了，在红黑树中会出现这样的结点，但我们马上会进行选择等处理保证<strong>没有任何一个结点同时和两条红链接相连</strong>)</p>
</li>
<li>
<p>该树是<strong>完美黑色平衡</strong>的，即任意空链接到根结点上的路径上的<strong>黑链接</strong>数量相同。</p>
</li>
</ul>
<h3 id="53-一一对应"><a class="markdownIt-Anchor" href="#53-一一对应"></a> 5.3 一一对应</h3>
<p>完美将一棵红黑树中的<strong>红链表画平</strong>，那么将可以看到<code>所以的空链接到根结点的距离都将是相同的</code>，如图3.3.13。</p>
<p>如果我们将红链接相连的结点合并，得到的就是一棵2-3树。相反，如果将一棵2-3树中的3-结点画作由红色链接相连的两个2-结点，那么不会存在能够和两条红链接相连的结点，且树必然是<strong>完美黑色平衡</strong>的。</p>
<p>无论我们选择用何种方法去定义它们，<code>红黑树既是二叉查找树，也是2-3树</code>。如图3.3.14所示：因此，如果我们能够在保持一一对应关系实现2-3树的<strong>插入算法</strong>，那么我们就能够将两个算法的优点结合起来：二叉查找树简介高效的<strong>查找算法</strong>和2-3树中高效的<strong>平衡插入算法</strong>。</p>
<h3 id="54-颜色表示"><a class="markdownIt-Anchor" href="#54-颜色表示"></a> 5.4 颜色表示</h3>
<p>每个结点都只会有一条指向自己的链接，我们将链接的颜色保存在表示结点的Node数据类型的<strong>布尔变量color</strong>中。如果指向它的链接是红色的，那么该变量为true，黑色则是false。我们约定<strong>空链接为黑色</strong>。为了代码的清晰我们定义了两个常量RED和BLACK来设置和测试这个变量。</p>
<p>我们使用isRed()来测试一个结点和它的父结点之间的链表的颜色，当我们提到一个结点的颜色时，我们指的是<strong>指向该结点的链接的颜色</strong>，反之亦然。</p>
<p>颜色表示的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    Key key;</span><br><span class="line">    Value val;</span><br><span class="line">    Node left,right;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">boolean</span> color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value val, <span class="keyword">int</span> n, <span class="keyword">boolean</span> color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        N = n;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x.color==RED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="55-旋转"><a class="markdownIt-Anchor" href="#55-旋转"></a> 5.5 旋转</h3>
<p>我们规定红黑树需要满足条件：</p>
<blockquote>
<ul>
<li>
<p><strong>红链接均为左链接</strong>  (红链接其实也可以为右链接，只是为了<strong>代码的简洁性</strong>，我们强制规定红链接均为左链接)</p>
</li>
<li>
<p><strong>没有任何一个结点同时和两条红链接相连</strong>。(否则就出现了<strong>4-结点</strong>了，在红黑树中会出现这样的结点，但我们马上会进行选择等处理保证<strong>没有任何一个结点同时和两条红链接相连</strong>)</p>
</li>
<li>
<p>该树是<strong>完美黑色平衡</strong>的，即任意空链接到根结点上的路径上的<strong>黑链接</strong>数量相同。</p>
</li>
</ul>
</blockquote>
<p>而在我们实现的某些操作中可能会出现违反上述条件的情况，比如出现了<strong>红色右链接</strong>或者<strong>两条连续的红链接</strong>，但在操作完成前这些都会被小心的<strong>旋转</strong>并<strong>修复</strong>。</p>
<p>旋转操作会改变红链接的指向，首先，假设我们有一条红色的右链接需要被转为左链接，如图3.3.16。这个操作叫做<strong>左旋转</strong>。ratateLeft方法接受一条指向红黑树的某个结点的链接作为参数，假设被指向的结点的右链接是红色的，这个方法会对树进行必要的调整并<strong>返回</strong>一个指向包含<strong>同一组键</strong>的子树且左链接为红色的根结点的链接。</p>
<p>简单的理解是：用两个键中的较小者作为根结点改变为将<strong>较大者作为根结点</strong>。</p>
<p>实现一个红色左链接转换为一个红色右链接的一个<strong>右旋转</strong>的代码完全相同，只需要将left和right互换即可。</p>
<p>旋转操作的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左旋转</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">rotateLeft</span><span class="params">(Node h)</span></span>&#123;</span><br><span class="line">    Node x=h.right;</span><br><span class="line">    h.right=x.left;</span><br><span class="line">    x.left=h;</span><br><span class="line">    x.color=h.color;</span><br><span class="line">    x.N=h.N;</span><br><span class="line">    h.color=RED;</span><br><span class="line">    h.N=size(h.left)+size(h.right)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右旋转</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">rotateRight</span><span class="params">(Node h)</span></span>&#123;</span><br><span class="line">    Node x=h.left;</span><br><span class="line">    h.left=x.right;</span><br><span class="line">    x.right=h;</span><br><span class="line">    x.color=h.color;</span><br><span class="line">    x.N=h.N;</span><br><span class="line">    h.N=size(h.left)+size(h.right)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="56-在旋转后重置父结点的链接"><a class="markdownIt-Anchor" href="#56-在旋转后重置父结点的链接"></a> 5.6 在旋转后重置父结点的链接</h3>
<p>无论是左旋转还是右旋转，<em>旋转操作都会返回一条链接</em>。我们总是会用rotateRight()或rotateLeft()的返回值重置父结点中相应的链接,这个链接可能是红色也可能是黑色的，这就可能会产生<strong>两条连续的红链接</strong>，但我们的算法会继续使用<strong>旋转</strong>(右旋)操作修正这种情况。</p>
<p>在插入新的键时我们可以通过使用<strong>旋转</strong>操作来保证<strong>2-3树</strong>和<strong>红黑树</strong>的一一对应关系，因为<strong>旋转操作</strong>可以保持红黑树的两个重要性质：<strong>有序性和完美平衡性</strong>。也就是说，我们在红黑树中进行选择时无需为树的有序性或者完美平衡性担心，下面我们来看看如何使用旋转操作来保持<strong>红黑树</strong>和<strong>2-3树</strong>的一一对应关系。</p>
<h3 id="57-向单个2-结点中插入新键"><a class="markdownIt-Anchor" href="#57-向单个2-结点中插入新键"></a> 5.7 向单个2-结点中插入新键</h3>
<p>向单个2-结点中插入新键对应于在2-3查找树中向2-结点中插入新键，只需要将新键和父结点合并为一个3-结点即可。对应到<strong>红黑树</strong>中的操作，就是将新键与对于父结点用红链接连接，但考虑到我们规定<code>红黑树中只能有红色左链接</code>，所以当出现红色右链接时我们要进行一次<strong>左旋转操作</strong>。如图3.3.18所示：</p>
<img src="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%A6%E5%8F%B7%E8%A1%A8/查找Blog图_19.jpg" alt="查找Blog图_1" style="zoom:15%;">
<h3 id="58-向树底部的2-结点插入新键"><a class="markdownIt-Anchor" href="#58-向树底部的2-结点插入新键"></a> 5.8 向树底部的2-结点插入新键</h3>
<p>向树底部的2-结点插入新键，当我们找到插入位置后，总是将新结点用<strong>红链接</strong>与它的父结点相连。之所以要这么做的原因是：注意<strong>红黑树是2-3树的一种实现数据结构</strong>，而2-3树是向上生长的树，我们用红链接连接新的结点和父结点，就是为了<strong>保持平衡，保证树向上生长的特性</strong>。</p>
<p>此时，因为它的父结点是2-结点，所以跟上述想单个2-结点中插入新键操仍然相同，依旧是直接插入，或插入完<strong>左旋转</strong>一次。如图3.3.19所示:</p>
<img src="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%A6%E5%8F%B7%E8%A1%A8/查找Blog图_20.jpg" alt="查找Blog图_1" style="zoom:20%;">
<h3 id="59-向一棵双键树即单个3-结点中插入新键"><a class="markdownIt-Anchor" href="#59-向一棵双键树即单个3-结点中插入新键"></a> 5.9 向一棵双键树(即单个3-结点)中插入新键</h3>
<p>该操作对应于2-3查找树中向一棵只含有3-结点的树中插入新键。这种情况又分为了三种情况：<strong>新键小于树中的两个键</strong>，<strong>在两者之间</strong>，<strong>大于树中的两个键</strong>，无论是哪种情况，<strong>都会产生一个同时连接到两条红链接的结点</strong>，我们的目标就是修正这一点：</p>
<ul>
<li>
<p>新键大于原树中的两个键，此时新键被连接到3-结点的右链接。此时树是平衡的，根结点为中间大小的键，它有两条红色的链接分别和左右子女连接。此时我们考虑将两条链接的颜色都<strong>由红变黑</strong>，那么我们就得到了一棵由三个结点组成的平衡树，它正好能够对应一棵2-3树。此时需要注意，在将两条自连接的颜色都<strong>由红变黑</strong>的同时，<strong>指向中间键的链接要变为红色</strong>，因为要保持<strong>树是向上生长的特性</strong>。与我们在2-3查找树中，将中间键要插入到父结点中去是保持一致的。 如图3.3.20(左) 其他两种情况最终也会转为<strong>这种情况</strong>。</p>
</li>
<li>
<p>新键小于原树的两个键，它会被链接到最左边的空链接，这样就会产生<strong>连续两条的红链接</strong>,如图3.3.20(中)，此时我们只需要<strong>将上层的红链接右旋转一次即得到了第一种情况</strong>，然后使用相同的办法处理即可。</p>
</li>
<li>
<p>新键介于原树的两个键之间，这时又会<strong>产生两条连续的红链接</strong>，一条左链接，一条右链接，如图3.3.20(右)。此时我们只需要将下层的红链接<strong>左旋转</strong>得到第二种情况，然后按相同的办法处理。</p>
</li>
</ul>
<p>总的来说，我们通过0次，1次和2次选择以及颜色的变化得到了期望的结构。</p>
<p>图3.3.20如下：</p>
<img src="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%A6%E5%8F%B7%E8%A1%A8/查找Blog图_21.jpg" alt="查找Blog图_1" style="zoom:20%;">
<h3 id="510-颜色转换"><a class="markdownIt-Anchor" href="#510-颜色转换"></a> 5.10 颜色转换</h3>
<p>如图3.3.32所示，我们专门使用一个方法flipColors()来转换一个结点的两个红色子结点的颜色，同时<strong>还要将父结点的颜色由黑变红</strong>，目的是为了<strong>维持红黑树的平衡树，保证树是向上生长的</strong>。</p>
<p>flipColors(Node h)方法实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">filpColor</span><span class="params">(Node h)</span></span>&#123;</span><br><span class="line">    h.color=RED;  <span class="comment">//h结点要被位红结点，否则树的高度会增加，破坏了完全二叉树的平衡性</span></span><br><span class="line">    h.left.color=BLACK;</span><br><span class="line">    h.right.color=BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="511-根结点总是黑色的"><a class="markdownIt-Anchor" href="#511-根结点总是黑色的"></a> 5.11 根结点总是黑色的</h3>
<p>在5.9中，我们所述，颜色转变会使得<strong>根结点</strong>变为红色，我们需要将根结点<strong>由红变黑</strong>，此时也即将一个4-结点变为3个2-结点,树的高度加+1，这就是<strong>红黑树生长的过程</strong>。</p>
<p><code>每当根结点由红变黑时树的黑链接高度就会+1</code></p>
<h3 id="512-向树底部的3-结点插入新键"><a class="markdownIt-Anchor" href="#512-向树底部的3-结点插入新键"></a> 5.12 向树底部的3-结点插入新键</h3>
<p>现在我们假设需要在树的底部的一个3-结点下插入一个新的结点，同样对应于2-3树中的操作。此时，前面出现的三种情况也都会出现，如果3.3.22所示。</p>
<p>指向新结点的链接有可能是3-结点的<strong>右链接</strong>，此时只需要<strong>转换颜色</strong>即可。</p>
<p>指向新结点的链接有可能是3-结点的<strong>左链接</strong>，此时需要先<strong>右旋转</strong>再<strong>转换颜色</strong>即可。</p>
<p>指向新结点的链接有可能是3-结点的<strong>中链接</strong>，此时需要先<strong>左旋转下层链接</strong>，然后<strong>右旋转上层链接</strong>，再转换颜色即可。</p>
<p>注意：颜色转换会使得指向<strong>中结点的链接变红</strong>，也就是相当于把它送入了父结点，这意味着在父结点中插入了一个新键，我们继续用<strong>递归</strong>的方式解决父结点中的问题。</p>
<h3 id="513-将红链接在树中向上传递"><a class="markdownIt-Anchor" href="#513-将红链接在树中向上传递"></a> 5.13 将红链接在树中向上传递</h3>
<p>2-3树中的插入算法需要我们<strong>分解3-结点</strong>，将<strong>中间键插入到父结点</strong>，一直这样操作知道遇到一个<strong>2-结点</strong>或者是<strong>根结点</strong>，我们所考虑过的所有情况都正式为了达成这个目标：<code>每次必要的旋转之后我们都会进行颜色转换</code>，这使得中结点变红，相当于插入了父结点中。而父结点就相当于插入了一个新的键，继续把红链接传递到<strong>父结点的中结点上去</strong>，直到遇到一个2-结点或者是根结点。</p>
<p>图3.3.23总结了三种情况，显示了在<strong>红黑树</strong>实现<strong>2-3树</strong>的插入算法的关键步骤：在一个3-结点下插入新键，先创建一个临时的4-结点，将其分解并将<strong>红链接</strong>又<strong>中结点</strong>传递给它的父结点，重复这个过程， 直到遇到一个2-结点或者是根结点。</p>
<img src="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%A6%E5%8F%B7%E8%A1%A8/查找Blog图_22.jpg" alt="查找Blog图_1" style="zoom:15%;">
<p>总之：只要谨慎地使用<strong>左旋转，右旋转，颜色转换</strong>这三种简单的操作，就能保证插入操作后<strong>红黑树</strong>和<strong>2-3树</strong>的一一对应关系。对于经过的每个结点<strong>顺序</strong>地完成以下操作：注意这里是有顺序的，因为我们知道，三种情况最后都需要转化为<strong>颜色转换</strong>。</p>
<ul>
<li>如果右子结点是红色的，而左子节点是黑色的，进行<strong>左旋转</strong></li>
<li>如果左子结点是红色的且左子节点的左子节点也是红色，进行<strong>右旋转</strong></li>
<li>如果左子节点和右子节点都是红色的，则进行<strong>颜色转换</strong></li>
</ul>
<p>红黑树的插入算法实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">put</span><span class="params">(Node h,Key key,Value val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(h==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(key,val,<span class="number">1</span>,RED);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp=key.compareTo(h.key);</span><br><span class="line">    <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        h.left=put(h.left,key,val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        h.right=put(h.right,key,val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        h.val=val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isRed(h.right) &amp;&amp; !isRed(h.left))&#123;</span><br><span class="line">        h=rotateLeft(h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isRed(h.left) &amp;&amp; isRed(h.left.left))&#123;</span><br><span class="line">        h=rotateRight(h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isRed(h.left) &amp;&amp; isRed(h.right))&#123;</span><br><span class="line">        filpColor(h);</span><br><span class="line">    &#125;</span><br><span class="line">    h.N=size(h.left)+size(h.right)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一棵红黑树的构造轨迹，如图3.3.24</p>
<img src="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%A6%E5%8F%B7%E8%A1%A8/查找Blog图_23.jpg" alt="查找Blog图_1" style="zoom:15%;">
<p><strong>红黑树的完整实现代码</strong> （除去删除操作)，除了插入操作，其他操作基本都与<strong>二叉查找树</strong>相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedBlackBST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;,<span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        Key key;</span><br><span class="line">        Value val;</span><br><span class="line">        Node left,right;</span><br><span class="line">        <span class="keyword">int</span> N;</span><br><span class="line">        <span class="keyword">boolean</span> color;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value val, <span class="keyword">int</span> n, <span class="keyword">boolean</span> color)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            N = n;</span><br><span class="line">            <span class="keyword">this</span>.color = color;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x.color==RED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左旋转</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">rotateLeft</span><span class="params">(Node h)</span></span>&#123;</span><br><span class="line">        Node x=h.right;</span><br><span class="line">        h.right=x.left;</span><br><span class="line">        x.left=h;</span><br><span class="line">        x.color=h.color;</span><br><span class="line">        x.N=h.N;</span><br><span class="line">        h.color=RED;</span><br><span class="line">        h.N=size(h.left)+size(h.right)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//右旋转</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">rotateRight</span><span class="params">(Node h)</span></span>&#123;</span><br><span class="line">        Node x=h.left;</span><br><span class="line">        h.left=x.right;</span><br><span class="line">        x.right=h;</span><br><span class="line">        x.color=h.color;</span><br><span class="line">        x.N=h.N;</span><br><span class="line">        h.N=size(h.left)+size(h.right)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">filpColor</span><span class="params">(Node h)</span></span>&#123;</span><br><span class="line">        h.color=RED;  <span class="comment">//h结点要被位红结点，否则树的高度会增加，破坏了完全二叉树的平衡性</span></span><br><span class="line">        h.left.color=BLACK;</span><br><span class="line">        h.right.color=BLACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Value <span class="title">get</span><span class="params">(Node x, Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cmp=key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> get(x.left,key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmp==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> x.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> get(x.right,key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value val)</span></span>&#123;</span><br><span class="line">        root=put(root,key,val);</span><br><span class="line">        root.color=BLACK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">put</span><span class="params">(Node h,Key key,Value val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(h==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(key,val,<span class="number">1</span>,RED);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cmp=key.compareTo(h.key);</span><br><span class="line">        <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            h.left=put(h.left,key,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            h.right=put(h.right,key,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            h.val=val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isRed(h.right) &amp;&amp; !isRed(h.left))&#123;</span><br><span class="line">            h=rotateLeft(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isRed(h.left) &amp;&amp; isRed(h.left.left))&#123;</span><br><span class="line">            h=rotateRight(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isRed(h.left) &amp;&amp; isRed(h.right))&#123;</span><br><span class="line">            filpColor(h);</span><br><span class="line">        &#125;</span><br><span class="line">        h.N=size(h.left)+size(h.right)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        Node x=root;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> cmp=key.compareTo(x.key);</span><br><span class="line">            <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                x=x.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                x=x.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(root).key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">min</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(x.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">max</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(root).key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">max</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(x.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">floor</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        Node x=floor(root,key);</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x.key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">floor</span><span class="params">(Node x,Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cmp=key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> floor(x.left,key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmp==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Node t=floor(x.right,key);</span><br><span class="line">            <span class="keyword">if</span>(t!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//大于等于key的最小键盘</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">ceiling</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        Node t=ceiling(root,key);</span><br><span class="line">        <span class="keyword">if</span>(t!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> t.key;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">ceiling</span><span class="params">(Node x, Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cmp=key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            Node t=ceiling(x.left,key);</span><br><span class="line">            <span class="keyword">if</span>(t!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmp==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ceiling(x.right,key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rank(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Node x,Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cmp=key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> rank(x.left,key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmp==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> size(x.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+size(x.left)+rank(x.right,key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">select</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> select(root,k).key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">select</span><span class="params">(Node x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> t=size(x.left);</span><br><span class="line">        <span class="keyword">if</span>(t&gt;k)&#123;</span><br><span class="line">            <span class="keyword">return</span> select(x.left,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t==k)&#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> select(x.right,k-t-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(Key lo,Key hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=rank(lo);</span><br><span class="line">        <span class="keyword">int</span> j=rank(hi);</span><br><span class="line">        <span class="keyword">if</span>(contains(hi))&#123;</span><br><span class="line">            <span class="keyword">return</span> j-i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> j-i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">(Key lo,Key hi)</span></span>&#123;</span><br><span class="line">        Queue&lt;Key&gt; queue=<span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">        keys(root,queue,lo,hi);</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys(min(),max());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">keys</span><span class="params">(Node x, Queue&lt;Key&gt; queue, Key lo, Key hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cmplo=lo.compareTo(x.key);</span><br><span class="line">        <span class="keyword">int</span> cmohi=hi.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span>(cmplo&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            keys(x.left,queue,lo,hi);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cmplo&lt;=<span class="number">0</span> &amp;&amp; cmohi&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            queue.enqueue(x.key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cmohi&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            keys(x.right,queue,lo,hi);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="514-删除操作"><a class="markdownIt-Anchor" href="#514-删除操作"></a> 5.14 删除操作</h3>
<p>还没看懂，g。</p>
<h3 id="515-红黑树的性质"><a class="markdownIt-Anchor" href="#515-红黑树的性质"></a> 5.15 红黑树的性质</h3>
<p>结论：<code>所有基于红黑树的符号表实现都能保证操作的运行时间为对数级别</code>。</p>
<p>首先，无论键的插入顺序如何,<code>红黑树都几乎是完美平衡的</code>。</p>
<blockquote>
<p>命题G：一棵大小为N的红黑树的高度不会超过2lgN。</p>
<p>命题H：一棵大小为N的红黑树中，根结点到任意结点的平均长度为~1.00lgN</p>
</blockquote>
<p>红黑树的get()方法并不会检查结点的颜色，因此任何平衡性的操作不会产生任何负担，且因为<strong>树是平衡的</strong>，所以查找比<strong>二叉查找树</strong>快。每个键只会被插入一次，但可能被查找无数次，只用了最小的代价就取得了和最优情况的查找时间。</p>
<p><code>这是我们见到的第一个能够保证对数级别的查找和插入操作的实现</code>。</p>
<blockquote>
<p>命题 I 在一棵红黑树中，下面操作在最坏情况下所需的时间仍是对数级别的：get，put，min，max，floor，ceiling，rank，select deleteMin deleteMax delete 和 range(<strong>范围查找</strong>)</p>
</blockquote>
<p>至此：各种符号表实现的性能总结如表：表3.3.2</p>
<img src="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%A6%E5%8F%B7%E8%A1%A8/查找Blog图_24.jpg" alt="查找Blog图_1" style="zoom:25%;">
<h2 id="6-散列表"><a class="markdownIt-Anchor" href="#6-散列表"></a> 6 散列表</h2>
<p>如果我们的键值对<strong>所有的键都是小整数</strong>，我们可以用一个数组来实现无序的符号表，将<strong>键作为数组的索引</strong>而<strong>数组键i处储存的就是它对应的值</strong>。这样我们就可以<strong>快速访问任意键的值</strong>。</p>
<p>在本节中我们将要学习<strong>散列表</strong>。它是上述简易方法的扩展并能够处理更加<strong>复杂的类型的键</strong>。我们需要用<code>算术操作</code>将键转化为数组的<strong>索引</strong>来访问数组中的键值对。</p>
<p>使用散列的查找算法分为两步：</p>
<p>第一步是用<strong>散列函数</strong>将被查找的键转化为数组的一个索引。理想情况下，<strong>不同的键都能转化为不同的索引值</strong>。然而这仅仅是理想情况，我们知道，在现实应用中的键有时是很大的，我们不可能提供一个巨大的数组，让每个键都有一个&quot;<strong>唯一的家</strong>&quot;。我们提供的数组常常是元小于实际可能的键值的个数的，这种多到少的映射必然会出现<strong>两个或者多个键会散列到相同的索引值的情况</strong>。</p>
<p>因此第二步就是一个<strong>处理碰撞冲突</strong>的过程，如图3.4.1所示。</p>
<img src="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%A6%E5%8F%B7%E8%A1%A8/查找Blog图_25.jpg" alt="查找Blog图_1" style="zoom:15%;">
<p>在描述了多种散列函数的计算后，我们会学习两种解决碰撞的方法：<strong>拉链法和线性探测法</strong>。</p>
<p>散列表是算法在<strong>时间和空间上作出权衡</strong>的经典例子。如果没有<strong>空间内存</strong>的限制，我们可以用一个超大的数组，让每个键都映射到不同的<strong>索引</strong>位置，那么所有的操作只需要访问内存一次即可完成。不会出现碰撞的情况。但这种理想情况不会经常出现，因为当键很多时需要的内存太大了。另一方面，如果没有<strong>时间</strong>的限制，我们可以用无序数组并进行顺序查找，这样就需要很少的内存。而散列表则是在<strong>时间和空间</strong>这两个极端找到了一种平衡。</p>
<p>使用散列表，可以实现在一般应用中拥有<strong>均摊</strong>后<strong>常数级别</strong>的查找和插入的符号表，这使得它在很多情况下成为实现符号表的最佳选择。</p>
<h3 id="61-散列函数"><a class="markdownIt-Anchor" href="#61-散列函数"></a> 6.1 散列函数</h3>
<p>我们面对的第一个问题就是散列函数的计算，这个过程将<strong>键转化为数组的索引</strong>。如果我们有一个能够保存M个键值对的数组，那么我们就需要一个能够将任意键转化为该数组范围内的<strong>索引</strong>(0~M-1范围内的整数)的<strong>散列函数</strong>。</p>
<p>我们要找的散列函数应该<strong>易于计算</strong>且能够<strong>均匀分布所有的键</strong>，即对于任意键，0~M-1之间的每个整数都有相等的可能性与之对应。要理解散列，首先就要思考如何去实现这样一个函数。</p>
<p>散列函数和键的类型相关，严格来说，<code>对于每种类型的键我们都需要一个与之对应的散列函数</code>。如果键是一个数，我们就可以直接用这个数;如果键是一个字符串，比如一个人的名字，我们需要将这个字符串转化为一个数;对于许多常见类型的键，我们可以利用Java提供的默认实现。</p>
<h4 id="1-正整数"><a class="markdownIt-Anchor" href="#1-正整数"></a> 1 正整数</h4>
<p>将整数散列最常用的方法是<strong>除留余数法</strong>，我们选择了大小为素数M的数组，对于任意正整数k，计算k除以M的余数k%M，这个散列函数能有效地将键散布在0~M-1范围内。之所以要选择一个素数M，是因为<code>如果M不是素数，我们可能无法利用键中所包含的所有信息</code>，这可能导致我们无法均匀地散列散列值。例如，如果键是十进制数而M是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">10^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>，我们只能用到键的后k位，这可能会产生一些问题，如加大了碰撞的可能性。举个例子，如果M=100，那么1012和1223212和2345612和12都会散列到索引为<strong>12</strong>的位置，无论键是什么样子的，只要低2位是12，它对应的索引就是12，这可能会增大了<strong>碰撞的可能性</strong>。</p>
<h4 id="2-浮点数"><a class="markdownIt-Anchor" href="#2-浮点数"></a> 2 浮点数</h4>
<p>如果键是0~1之间的实数，我们可以将它乘以M并四舍五入得到一个0至M-1之间的<strong>索引值</strong>。这个方法很容易理解，但它是有缺陷的，因为这种情况下键的高位起的作用更大，最低位对散列的结果没有影响。修正这个问题的办法是将键表示为<strong>二进制数</strong>然后再使用<strong>除留余数法</strong>。</p>
<h4 id="3-字符串"><a class="markdownIt-Anchor" href="#3-字符串"></a> 3 字符串</h4>
<p>字符串也可以使用除留余数法进行处理，如下面的代码就能够用除留余数法计算String s的散列值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();++i)&#123;</span><br><span class="line">    hash=(R*hash+s.charAt(i))%M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java的cahrAt函数返回一个char值，也就是一个<strong>非负16位整数</strong>。如果R比任何字符的值都大，这种计算就相当于将字符串当做一个<strong>N位的R进制值</strong>，并将它除以M并取余。</p>
<h4 id="4-组合键"><a class="markdownIt-Anchor" href="#4-组合键"></a> 4 组合键</h4>
<p>如果键的类型有多个整型变量，我们可以和String类型一样把它们混合起来，例如被查找的键的类型是Date，我们可以将它拆成几个独立的域:day,month和year，然后通过计算散列值，保证计算结果都在0~M-1范围内即可。</p>
<h4 id="5-java的规定"><a class="markdownIt-Anchor" href="#5-java的规定"></a> 5 JAVA的规定</h4>
<p><strong>每种数据类型都需要相应的散列函数</strong>。于是JAVA令所有数据类型都继承了一个能够返回一个32比特整数的hashCode()方法。<code>每一种数据类型的hashCode()</code>方法都必须和equals()方法一致。也就是说：如果a.equals(b)返回true，那么a.hashCode()的返回值必然和b.hashCode()的返回值相同，反之如果两个对象的hashCode()的方法的返回值不同，则这两个对象一定是不同的。但hashCode()相同两个对象也不一定相同，因为我们知道有<strong>碰撞</strong>的出现。</p>
<p>注意需要<strong>同时</strong>重写<strong>hashCode</strong>和<strong>equals</strong>两个方法，而不能之重写一个。</p>
<h4 id="6-将hashcode的返回值转化为一个数组索引"><a class="markdownIt-Anchor" href="#6-将hashcode的返回值转化为一个数组索引"></a> 6 将hashCode()的返回值转化为一个数组索引</h4>
<p>因为我们需要的是数组的索引而不是一个32位的整数，我们在实现中会将默认的hashCode()方法和除留余数法结合起来产生一个0~M-1的整数，方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x.hashCode() &amp; <span class="number">0x7fffffff</span>)%M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>x.hashCode() &amp; 0x7fffffff保证了结果为正数，%M得到对应的<strong>数组索引</strong>，在使用者的代码时我们一般会将数组大小M取为<strong>素数</strong>以充分利用原散列值的<strong>所有位</strong>。</p>
<h4 id="7-软缓存"><a class="markdownIt-Anchor" href="#7-软缓存"></a> 7 软缓存</h4>
<p>我们希望散列函数计算散列值是容易的，快速的，但如果散列值的计算很耗时，那么我们或许可以<strong>将每个键的散列值缓存起来</strong>，即在每个键中使用一个hash变量来保存它的hashCode()的返回值，相当于<strong>缓存</strong>使用。</p>
<p>第一次调用hashCode()方法，我们用散列函数计算对应的散列值，之后调用hashCode()会直接返回<strong>hash变量</strong>的值。</p>
<p>因为保证：<code>当散列函数确定，同一对象多次调用hashCode都会返回相同的hash值</code>，这是散列的<strong>一致性</strong>。</p>
<p>总的来说，要为一个数据类型实现一个优秀的散列方法需要满足三个条件：</p>
<ul>
<li>一致性：等价的键必然产生相等的散列值。</li>
<li>高效性：计算简便。</li>
<li>均匀性：均匀地散列所有的值。</li>
</ul>
<p>但是，在有性能要求时应该谨慎使用散列，因为糟糕的散列函数经常是<strong>性能问题的罪魁祸首</strong>。</p>
<h3 id="62-基于拉链法的散列表"><a class="markdownIt-Anchor" href="#62-基于拉链法的散列表"></a> 6.2 基于拉链法的散列表</h3>
<p>前面我们提到的散列函数能<strong>将键转化为数组索引</strong>。散列算法的第二步是<strong>碰撞处理</strong>，也就是处理两个或多个键的散列值相同的情况，一种直接的办法是将大小为M的数组中的每个元素指向<strong>一条链表</strong>，链表中的每个结点都存储了散列值为该元素的索引的键值对，这种方法也称之为<strong>拉链法</strong>。</p>
<p>因为发生冲突的元素都被存储在链表中，我们希望尽可能选择足够大的M，使得<strong>所有链表都尽可能短以保证高效的查找</strong>。因为基于拉链法的散列表查找分两步：1是根据散列值找到对应的链表，2是遍历链表找到对应的key。</p>
<p>拉链表的一种实现方法是使用我们前面构建的无序链表作为数组元素，这样也可以复用无序链表的put,get方法。</p>
<p>因为我们要用M条链表保存N个键，无论键在各个链表中的分布如何，链表的平均长度都是N/M。</p>
<p>标准索引用例基于拉链法的散列表如图3.4.3：</p>
<img src="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%A6%E5%8F%B7%E8%A1%A8/查找Blog图_26.jpg" alt="查找Blog图_1" style="zoom:20%;">
<p>基于拉链法的散列表的代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeparateChainingHashST</span> &lt;<span class="title">Key</span>,<span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;  <span class="comment">//键值对总数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M; <span class="comment">//散列表的大小</span></span><br><span class="line">    <span class="keyword">private</span>  SequentialSearchST&lt;Key,Value&gt;[] st;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeparateChainingHashST</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeparateChainingHashST</span><span class="params">(<span class="keyword">int</span> M)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建M条链表</span></span><br><span class="line">        <span class="keyword">this</span>.M=M;</span><br><span class="line">        st = <span class="keyword">new</span> SequentialSearchST[M];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">            st[i]=<span class="keyword">new</span> SequentialSearchST&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>)%M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  st[hash(key)].get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value value)</span></span>&#123;</span><br><span class="line">        st[hash(key)].put(key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        st[hash(key)].delete(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st[hash(key)].contains(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Queue&lt;Key&gt; queue=<span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;++i)&#123;</span><br><span class="line">            Queue&lt;Key&gt; tem=<span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">            tem= (Queue&lt;Key&gt;) st[i].keys();</span><br><span class="line">            <span class="keyword">for</span>(Key key:tem)&#123;</span><br><span class="line">                queue.enqueue(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-删除操作"><a class="markdownIt-Anchor" href="#1-删除操作"></a> 1 删除操作</h4>
<p>要删除散列表中的一个键值对，先用散列值找到含有该键的SequentialSearchST对象，然后调用该对象的delete方法即可。</p>
<h4 id="2-有序性相关的操作"><a class="markdownIt-Anchor" href="#2-有序性相关的操作"></a> 2 有序性相关的操作</h4>
<p>散列的最主要目的在于<strong>均匀地将键散布开来</strong>，因此在计算散列后<strong>键的顺序信息就丢失了</strong>。如果应用需要快速找到最大或者最小的键，或是查找某个范围内的键，或者其他有序性的操作，<strong>散列表都不是合适的选择</strong>，因为这些操作的运行时间是<strong>线性的</strong>。</p>
<p>基于拉链法的散列表的 实现简单，在键的顺序并不重要的应用中，它可能是<strong>最快的</strong>也是<strong>最广泛</strong>的实现。下面，我们介绍另一种解决碰撞冲突的有效方法。</p>
<h3 id="63-基于线性探测法的散列表"><a class="markdownIt-Anchor" href="#63-基于线性探测法的散列表"></a> 6.3 基于线性探测法的散列表</h3>
<p>实现散列表的另一种方式就是用<strong>大小为M</strong>的数组保存N个键值对，其中<strong>M&gt;N</strong>，我们需要依赖数组中的<strong>空位</strong>解决碰撞冲突。基于这种策略的所有方法被统称为<strong>开放地址散列表</strong>。</p>
<p>开放地址散列表中最简单的方法叫做<strong>线性探测法</strong>：当碰撞发生时(当一个键的散列值已经被另一个不同的键占用)，我们直接检查散列表的<strong>下一个位置</strong>(将索引值+1并<strong>取余</strong>，形成一个循环)。这样的线性探测可能会产生三种结果：</p>
<ul>
<li><strong>命中</strong>：该位置的键和被查找的键相同</li>
<li><strong>未命中</strong>：键为空(该位置没有键)</li>
<li><strong>继续查找</strong>，该位置的键和被查找的键不同</li>
</ul>
<p>我们首先用散列函数找到键在数组中的索引，检查其中的键和被查找的键是否相同，如果不同则继续查找(将索引+1，到达数组结尾折回数组的开头)，知道<strong>找到该键</strong>或者<strong>遇到一个空元素</strong>，如图3.4.6，我们将检查一个数组位置是否含有被查找的键的操作称作<strong>探测</strong>。</p>
<p>开放地址类的散列表的<strong>核心思想</strong>是：在实现中使用了<strong>并行数组</strong>，一条保存键，一条保存值。</p>
<p>图3.4.6</p>
<img src="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%A6%E5%8F%B7%E8%A1%A8/查找Blog图_27.jpg" alt="查找Blog图_1" style="zoom:20%;">
<p>基于线性探测的符号表的代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearProbingHashST</span> &lt;<span class="title">Key</span>,<span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N; <span class="comment">//键值对的总数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M=<span class="number">16</span>; <span class="comment">//线性探测表的大小</span></span><br><span class="line">    <span class="keyword">private</span> Key[] keys; <span class="comment">//键</span></span><br><span class="line">    <span class="keyword">private</span> Value[] vals; <span class="comment">//值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearProbingHashST</span><span class="params">()</span></span>&#123;</span><br><span class="line">        keys = (Key[]) <span class="keyword">new</span> Object[M];</span><br><span class="line">        vals = (Value[]) <span class="keyword">new</span> Object[M];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearProbingHashST</span><span class="params">(<span class="keyword">int</span> cap)</span></span>&#123;</span><br><span class="line">        keys= (Key[]) <span class="keyword">new</span> Object[cap];</span><br><span class="line">        vals= (Value[]) <span class="keyword">new</span> Object[cap];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>)%M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> cap)</span></span>&#123;</span><br><span class="line">        LinearProbingHashST&lt;Key,Value&gt; tem=<span class="keyword">new</span> LinearProbingHashST&lt;&gt;(cap);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(keys[i]!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                tem.put(keys[i],vals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        keys = (Key[]) <span class="keyword">new</span> Object[cap];</span><br><span class="line">        vals = (Value[]) <span class="keyword">new</span> Object[cap];</span><br><span class="line">        keys= tem.keys;</span><br><span class="line">        vals=tem.vals;</span><br><span class="line">        M=tem.M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N&gt;=M/<span class="number">2</span>)&#123;</span><br><span class="line">            resize(<span class="number">2</span>*M);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=hash(key);keys[i]!=<span class="keyword">null</span>;i=(i+<span class="number">1</span>)%M)&#123;</span><br><span class="line">            <span class="keyword">if</span>(key.equals(keys[i]))&#123;</span><br><span class="line">                vals[i]=val;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        keys[i]=key;</span><br><span class="line">        vals[i]=val;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=hash(key);keys[i]!=<span class="keyword">null</span>;i=(i+<span class="number">1</span>)%M)&#123;</span><br><span class="line">            <span class="keyword">if</span>(keys[i].equals(key))&#123;</span><br><span class="line">                <span class="keyword">return</span> vals[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=hash(key);keys[i]!=<span class="keyword">null</span>;i=(i+<span class="number">1</span>)%M)&#123;</span><br><span class="line">            <span class="keyword">if</span>(key.equals(keys[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!contains(key))&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=hash(key);</span><br><span class="line">        <span class="keyword">while</span>(!key.equals(keys[i]))&#123;</span><br><span class="line">            i=(i+<span class="number">1</span>)%M;</span><br><span class="line">        &#125;</span><br><span class="line">        keys[i]=<span class="keyword">null</span>;</span><br><span class="line">        vals[i]=<span class="keyword">null</span>;</span><br><span class="line">        i=(i+<span class="number">1</span>)%M;</span><br><span class="line">        <span class="keyword">while</span> (keys[i]!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            Key temKey =keys[i];</span><br><span class="line">            Value temValue=vals[i];</span><br><span class="line">            keys[i]=<span class="keyword">null</span>;</span><br><span class="line">            vals[i]=<span class="keyword">null</span>;</span><br><span class="line">            N--;  <span class="comment">//先删除再插入</span></span><br><span class="line">            put(temKey,temValue);</span><br><span class="line">            i=(i+<span class="number">1</span>)%M;</span><br><span class="line">        &#125;</span><br><span class="line">        N--; <span class="comment">//键值对数目减1</span></span><br><span class="line">        <span class="keyword">if</span>(N&gt;<span class="number">0</span> &amp;&amp; N==M/<span class="number">8</span>)&#123;</span><br><span class="line">            resize(M/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次查一个键，先计算它的散列值，从它的散列值开始顺序查找，<strong>如果找到则命中，如果遇到空元素则为命中</strong>。</p>
<h4 id="1-删除操作-2"><a class="markdownIt-Anchor" href="#1-删除操作-2"></a> 1 删除操作</h4>
<p>如何从基于线性探测的散列表中删除一个键？考虑直接将该键所在的位置设为null，发现是不行的，因为这破坏了<strong>同一键簇是连在一起的特性</strong>，使得在此位置之后的元素无法被查找。</p>
<p>例如，假设在轨迹图(3.4.6)的例子中，我们需要用这种方法删除键C，然后查找H，H的散列值为4，但它实际存储在这一簇键的结尾，也就是7号位置，如果我们将5号位置设为null，get方法将无法找到H。</p>
<p>因此，我们需要将簇中被删除键的<strong>右侧的所有键</strong>重新插入散列表。删除操作如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!contains(key))&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i=hash(key);</span><br><span class="line">    <span class="keyword">while</span>(!key.equals(keys[i]))&#123;</span><br><span class="line">        i=(i+<span class="number">1</span>)%M;</span><br><span class="line">    &#125;</span><br><span class="line">    keys[i]=<span class="keyword">null</span>;</span><br><span class="line">    vals[i]=<span class="keyword">null</span>;</span><br><span class="line">    i=(i+<span class="number">1</span>)%M;</span><br><span class="line">    <span class="keyword">while</span> (keys[i]!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        Key temKey =keys[i];</span><br><span class="line">        Value temValue=vals[i];</span><br><span class="line">        keys[i]=<span class="keyword">null</span>;</span><br><span class="line">        vals[i]=<span class="keyword">null</span>;</span><br><span class="line">        N--;  <span class="comment">//先删除再插入</span></span><br><span class="line">        put(temKey,temValue);</span><br><span class="line">        i=(i+<span class="number">1</span>)%M;</span><br><span class="line">    &#125;</span><br><span class="line">    N--; <span class="comment">//键值对数目减1</span></span><br><span class="line">    <span class="keyword">if</span>(N&gt;<span class="number">0</span> &amp;&amp; N==M/<span class="number">8</span>)&#123;</span><br><span class="line">        resize(M/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<p>在拉链法中，散列表的性能依赖于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mo>=</mo><mi>N</mi><mi mathvariant="normal">/</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">\alpha=N/M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>的，因为拉链法需要遍历一条链。</p>
<p>而线性探测法的性能也依赖于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mo>=</mo><mi>N</mi><mi mathvariant="normal">/</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">\alpha=N/M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>，但意义有所不同，我们将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>称为散列表的使用率，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>是表中<strong>已被占用空间的比例</strong>，它是不可能大于1的，因为M&gt;N。事实上，我们是不允许<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>达到1的，也就是散列表被沾满，此时<strong>未命中的查找</strong>导致无限循环。</p>
<p>为了保证性能，我们会动态调整数组的大小来保证使用率在1/8到1/2之间。</p>
<h4 id="2-键簇"><a class="markdownIt-Anchor" href="#2-键簇"></a> 2 键簇</h4>
<p>线性探测的平均成本取决于元素在插入数组后聚集成的<strong>一组连续的条目</strong>，也叫作<strong>键簇</strong>。显然，<strong>短小的键簇才能保证较高的效率</strong>。随着插入的键越来越多，这个要求越来越难满足，<strong>较长的键簇会越来越多</strong>，如图3.4.8。</p>
<p>研究表明：<code>当散列表快满的时候查找所需的探测次数是巨大的</code>，当使用率小于1/2探测预计次数只有1.5到2.5之间，因此，我们考虑<strong>动态调整散列表数组的大小</strong>。</p>
<img src="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%A6%E5%8F%B7%E8%A1%A8/查找Blog图_28.jpg" alt="查找Blog图_1" style="zoom:25%;">
<h3 id="64-调整数组大小"><a class="markdownIt-Anchor" href="#64-调整数组大小"></a> 6.4 调整数组大小</h3>
<p>我们可以使用<strong>resize</strong>方法保证使用率永远都不会超过1/2，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> cap)</span></span>&#123;</span><br><span class="line">    LinearProbingHashST&lt;Key,Value&gt; tem=<span class="keyword">new</span> LinearProbingHashST&lt;&gt;(cap);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(keys[i]!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            tem.put(keys[i],vals[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    keys = (Key[]) <span class="keyword">new</span> Object[cap];</span><br><span class="line">    vals = (Value[]) <span class="keyword">new</span> Object[cap];</span><br><span class="line">    keys= tem.keys;</span><br><span class="line">    vals=tem.vals;</span><br><span class="line">    M=tem.M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用resize方法保证散列表最多为<strong>半满状态</strong>。</p>
<p>拉链法和线性探测法的区别主要在于：<code>拉链法为每个键值对都分配了一小块内存(Node)</code>而<code>线性探测为整张表使用了两个很大的数组</code>。</p>
<p>​</p>
<p>通过对散列表的分析，期望散列表能够支持和数组大小无关的<strong>常数级别的查找和插入操作</strong>是可能的。对于任意的符号表实现，这个期望都是理论上的最优性能，但散列表<strong>并非就是万能的</strong>。因为：</p>
<ul>
<li>每种类型的键都需要一个<strong>优秀的散列函数</strong></li>
<li>性能保证来自于<strong>散列函数的质量</strong></li>
<li>散列函数的计算有可能<strong>复杂</strong>且<strong>昂贵</strong></li>
<li>难以支持<strong>有序性</strong>操作</li>
</ul>
<p>所以，选择以何种方式(无序链表？有序数组？二叉查找树，红黑树？散列表)实现我们的符号表还是要取决于我们具体应用的所需要的操作和对性能内存的限制。</p>
<h2 id="7-应用"><a class="markdownIt-Anchor" href="#7-应用"></a> 7 应用</h2>
<h3 id="71-选择符号表的哪种实现"><a class="markdownIt-Anchor" href="#71-选择符号表的哪种实现"></a> 7.1 选择符号表的哪种实现</h3>
<p>表3.5.1总结了本章多个命题的性质得到的各种符号表算法的性能特点，从表中可以知道，对于典型的应用程序，应该在<strong>散列表</strong>和<strong>二叉查找树</strong>之间进行选择。</p>
<img src="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%A6%E5%8F%B7%E8%A1%A8/查找Blog图_29.jpg" alt="查找Blog图_1" style="zoom:25%;">
<p>相对于二叉查找树而言，散列表的优点在于代码更加简单，且查找时间<strong>更优</strong>。二叉查找树相对于散列表的优点是在于<strong>抽象结构更简单</strong>，不需要设计散列函数，<strong>红黑树</strong>可以保证最坏情况下的性能且它能支持的操作更多(<strong>如有序性操作的rank，select，范围查找等</strong>)。</p>
<h3 id="72-用例"><a class="markdownIt-Anchor" href="#72-用例"></a> 7.2 用例</h3>
<p>符号表的使用非常的广泛，可以用作<strong>字典类</strong>，<strong>索引类</strong>等等，还有<strong>白名单</strong>和<strong>黑名单</strong>，<strong>反向索引</strong>等等</p>
<p>典型的字典类应用如图3.5.3</p>
<img src="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%A6%E5%8F%B7%E8%A1%A8/查找Blog图_30.jpg" alt="查找Blog图_1" style="zoom:25%;">
<p>典型的索引类应用如图3.5.4</p>
<img src="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%A6%E5%8F%B7%E8%A1%A8/查找Blog图_31.jpg" alt="查找Blog图_1" style="zoom:25%;">
<p>典型的反向索引如图3.5.5</p>
<img src="/2021/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%A6%E5%8F%B7%E8%A1%A8/查找Blog图_32.jpg" alt="查找Blog图_1" style="zoom:25%;">
<p>完结…</p>
<p>参考资料：《算法4》</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:1127959736@qq.com">luo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://luo41.top/2021/12/07/数据结构-符号表/">https://luo41.top/2021/12/07/数据结构-符号表/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://luo41.top">luo's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2021/12/05/ComSec%E4%BD%9C%E4%B8%9A11/"><span>ComSec作业11</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '32255e197922b1ab75ad',
  clientSecret: '9bbe47fc29096bda7c2e430895ef65fa58c8d7db',
  repo: 'zhengjianda.github.io',
  owner: 'zhengjianda',
  admin: 'zhengjianda',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(/background2.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 By luo</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="100" alpha="0.6" zIndex="-1" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>