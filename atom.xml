<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>luo&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/da903dd2d4a578c82b67facbd746bcc8</icon>
  
  <link href="https://luo41.top/atom.xml" rel="self"/>
  
  <link href="https://luo41.top/"/>
  <updated>2021-10-20T07:23:09.945Z</updated>
  <id>https://luo41.top/</id>
  
  <author>
    <name>luo</name>
    <email>1127959736@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>串行，并发与并行</title>
    <link href="https://luo41.top/2021/10/20/%E4%B8%B2%E8%A1%8C%EF%BC%8C%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/"/>
    <id>https://luo41.top/2021/10/20/%E4%B8%B2%E8%A1%8C%EF%BC%8C%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/</id>
    <published>2021-10-20T07:13:02.000Z</published>
    <updated>2021-10-20T07:23:09.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="串行并发与并行"><a class="markdownIt-Anchor" href="#串行并发与并行"></a> 串行，并发与并行</h2><p>最近看到一个问题 串行，并发与并行的区别，查阅了一些网上的资料和视频，谈谈自己的理解,不当之处，欢迎指正！</p><p>首先看两句话：</p><blockquote><ul><li>Concurrency is not Parallelism.  并发不是并行</li></ul></blockquote><blockquote><ul><li>Concurrency enables parallelism &amp; makes parallelism(and scaling and everything) easy. 并发允许去并行，并发让并行更容易</li></ul></blockquote><span id="more"></span><p>我的理解是，并发其实是一种<strong>处理问题的方法</strong>，可以让问题处理起来更高效，<strong>但不是必然</strong>。</p><p>关于并发和并行网络上有很多的例子，比如说小学初中常见的数学题目修路，路的规格是5000米×25米，处理这个问题的方法有很多，<strong>只给一个工程队干</strong>，这是一种<strong>串行</strong>的解决方法。分成两条2500×25米的路，分别给两个工程队干，这是一种<strong>并发</strong>的解决方法。</p><p><strong>串行</strong>就是很简单的一个工程队一段一段地修完整路，直到最后解决了修路的问题。</p><p><strong>并发</strong>就是我将这条路分给多个工程队干，至于各个工程队怎么干我不管，等到多个工程队各自完成任务，我这个问题也就解决了，并发相比串行来说，效率提高了不少，但是<strong>并发不是必然的</strong>，因为串行是可以解决问题的，只是我们需要提高效率，追求更快，才考虑通过<strong>并发</strong>去解决问题。</p><p>那么<strong>并行</strong>又是什么？当我们对问题进行了<strong>并发</strong>处理，把修路问题分给了多个工程队，如果多个工程队<strong>同时再施工现场修路</strong>，这就是<strong>并行</strong>，可以说<strong>并发是一种处理问题的思路</strong>，而并行是真正去<strong>实行这种方法</strong>(真正的同时有多支工程队在现场干活)了。</p><p>有下面的一些结论</p><ol><li><strong>当找不到一个问题如果并发的方法，也就不可能对该问题并行执行</strong>。</li></ol><p>还是拿修路为例，如果找不到把路分给多个工程队修的方案(并发)，又怎么会有多个工程队同时在施工现场施工呢(并行)？</p><ol start="2"><li><strong>并行的上限是由并发的方法设计决定的</strong>。</li></ol><p>以修路为例：<strong>并行的上限</strong>(最多有多少工程队能同时在现场施工)是由<strong>并发的方法</strong>(把这条路分给多少个工程队修)所决定的。</p><ol start="3"><li>并发是多个任务交替使用CPU，在只有一个CPU的情况下，同一时刻<strong>只有一个任务</strong>在跑，但任务之间切换非常快，给我们的感觉是<strong>多个任务同时跑</strong>，其实不是。(相当于只有一个工程队的情况)</li><li>只有并行才是真正意义上的多个任务<strong>同时</strong>跑。(<strong>多个CPU</strong>，多个工程队)</li><li>并行跑的多个任务如果是<strong>一个问题分解出来的</strong>，那么这些任务既是并发，又是并行。如果不是<strong>同一个问题</strong>分解出来的，那么是并行，不是并发。</li></ol><p>上面关于串行，并行，并发仅仅局限在单任务中，也是只有一条公路要修。</p><p>而真实计算机中的串行，并发，并行多发生在需要解决多任务问题。计算机中待解决的很多个任务，可以看成是多条待修的公路，而<strong>一个CPU就是一个工程队</strong>。</p><p>当只有单核CPU(单个工程队)的时候，首先可以确定是不可能有<strong>并行</strong>情况出现的。</p><p>单个工程队按照顺序依次修路，把公路A整条修完，再去修公路B，修完公路B，再去修公路C，直到所有的路修完。</p><p>就相当于计算机CPU，先把任务A做完，再把任务B<strong>做完</strong>，再把任务C做完，直到所有的任务完成。这种方式就是<strong>串行</strong>。</p><p>而虽然只有一个工程队，那我工程队今天去修公路A，没有修完，但是明天开始公路A需要保养几天，不能干活了。如果死死坚持串行的话，那工程队这几天不是没事干了嘛，太浪费资源了，所以这时候就可以这几天先修公路B嘛，等到公路A保养好了可以干活了，我再继续修公路A。</p><p>这就相当于CPU先把任务A需要CPU的地方处理完成了，在任务A使用I/O或其他资源，而CPU空闲的时候，CPU<strong>抽空</strong>去把任务B需要CPU部分的部分帮他处理了，这样就大大提高了CPU的利用率，这种方式就是<strong>并发</strong>。</p><p>而如果我有<strong>多个工程队</strong>，那干活的方式就灵活多变了，可以让多个工程队同时<strong>修一条路</strong>，修路这个任务既是<strong>并发，也是并行</strong>。也可以让多个工程队分别去修多条公路，这是<strong>并发，不是并行</strong>。</p><p>相当于有多个CPU，让多个CPU同时处理<strong>一个任务</strong>中多个需要CPU的子任务，<strong>是并行，也是并发</strong>。让多个CPU分别去处理多个任务，<strong>是并发，不是并行</strong>。</p><p>参考资料：</p><p><a href="https://www.bilibili.com/video/BV1N741177F5?from=search&amp;seid=17674790371197472246&amp;spm_id_from=333.337.0.0">B站 蒋炎岩 “操作系统：设计与实现</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;串行并发与并行&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#串行并发与并行&quot;&gt;&lt;/a&gt; 串行，并发与并行&lt;/h2&gt;
&lt;p&gt;最近看到一个问题 串行，并发与并行的区别，查阅了一些网上的资料和视频，谈谈自己的理解,不当之处，欢迎指正！&lt;/p&gt;
&lt;p&gt;首先看两句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Concurrency is not Parallelism.  并发不是并行&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Concurrency enables parallelism &amp;amp; makes parallelism(and scaling and everything) easy. 并发允许去并行，并发让并行更容易&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://luo41.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="操作系统" scheme="https://luo41.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Spring Autowired的一个小问题</title>
    <link href="https://luo41.top/2021/09/18/Spring-Autowired%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
    <id>https://luo41.top/2021/09/18/Spring-Autowired%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/</id>
    <published>2021-09-18T14:04:42.000Z</published>
    <updated>2021-09-18T17:08:48.782Z</updated>
    
    <content type="html"><![CDATA[<p>最近学习Spring框架：在我自己写代码的过程中，发现，如果@Autowired注解用在属性上的话，最好要将该属性setter的方法去掉，起初的原因是我想测试一下当有两个Bean的类型(Type)一致是，需要让@Autowired配合使用@Qualifier才能找到唯一的bean。首先看一下我的xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat222&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.luo.pojo.Cat&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;catName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog111&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.luo.pojo.Dog&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dogName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;yue1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.luo.pojo.Dog&quot;</span>&gt;</span>      <span class="comment">&lt;!-- 重点看这里，有两个Dog类型的bean --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dogName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;yue&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;people&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.luo.pojo.People&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;luo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我利用@Autowired 配合 @Qualifier 对dog进行自动装配：</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.luo.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;dog111&quot;)</span>   <span class="comment">//根据我的设想，这里@Qualifier(&quot;dog111&quot;),可以找到唯一的Bean</span></span><br><span class="line">    <span class="keyword">private</span>  Dog dog;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cat <span class="title">getCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCat</span><span class="params">(Cat cat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cat = cat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dog <span class="title">getDog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDog</span><span class="params">(Dog dog)</span> </span>&#123;   <span class="comment">//注意这里的set方法</span></span><br><span class="line">        <span class="keyword">this</span>.dog = dog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;People&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, cat=&quot;</span> + cat.toString() +</span><br><span class="line">                <span class="string">&quot;, dog=&quot;</span> + dog.toString() +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后我测试了一下可以不可以实现自动装配，结果报错了：</p><blockquote><p>Unsatisfied dependency expressed through bean property ‘dog’: No qualifying bean of type [com.luo.pojo.Dog] is defined: expected single matching bean but found 2: dog111,dog;</p></blockquote><p>报错信息大概就是说无法找到唯一匹配的bean，找到了两个匹配的bean, 分别dog111和dog，诶奇了怪了我不是用@Qualifier(“dog111”)指明了当有多个类型匹配时，取id=“dog111&quot;的那一个bean吗？怎么还会有冲突？</p><p>Debug无果后，想到@Autowired有两种使用方式，一种是<strong>直接使用在属性上</strong>，一种是<strong>使用在set方法上</strong>，于是将@Autowired和@Qualifier(“dog111”)使用在set方法上后，成功解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.luo.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;dok111&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  Dog dog;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cat <span class="title">getCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCat</span><span class="params">(Cat cat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cat = cat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dog <span class="title">getDog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>                            <span class="comment">//改到set方法上</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;dog111&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDog</span><span class="params">(Dog dog)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dog = dog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;People&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, cat=&quot;</span> + cat.toString() +</span><br><span class="line">                <span class="string">&quot;, dog=&quot;</span> + dog.toString() +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为什么会这样呢？在网上搜集了一下信息</p><ul><li>当注解写在成员变量(属性)上 就是spring通过读取xml配置返回一个bean</li><li>当注解写在set方法上，就是spring通过读取xml配置返回一个bean,然后再用这个bean里面的属性，注入到成员变量当中。</li></ul><p>那如果我同时写在属性和set方法上，会通过哪种方式呢？于是我进行了一下测试，将属性和set方法前都写上@Autowired和@Qualifier(“dog111”)，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.luo.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;dok111&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;dog111&quot;)</span></span><br><span class="line">    <span class="keyword">private</span>  Dog dog;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cat <span class="title">getCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCat</span><span class="params">(Cat cat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cat = cat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dog <span class="title">getDog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;dog111&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDog</span><span class="params">(Dog dog)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了set方法&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.dog = dog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;People&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, cat=&quot;</span> + cat.toString() +</span><br><span class="line">                <span class="string">&quot;, dog=&quot;</span> + dog.toString() +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后屏幕输出了<strong>调用了set方法</strong>，好像说明了当同时存在的时候，<strong>还是默认使用了set方法</strong>，先获取bean，再进行配置，这也解释了为什么我们最刚开始只在属性上写@Autowired和@Qualifier(“dog111”)会报错了，因为此时spring还是会通过set方法进行注入，而此时set方法发现两个类型相同，<strong>无法唯一匹配就报错了</strong>。</p><p>所以解决的方式有两个：</p><ul><li><strong>删除掉set方法，使用加在属性上的注解属性直接配置</strong></li><li><strong>给set方法前也加上注解</strong></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近学习Spring框架：在我自己写代码的过程中，发现，如果@Autowired注解用在属性上的话，最好要将该属性setter的方法去掉，起初的原因是我想测试一下当有两个Bean的类型(Type)一致是，需要让@Autowired配合使用@Qualifier才能找到唯一的bean。首先看一下我的xml文件&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;beans&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;xmlns&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;http://www.springframework.org/schema/beans&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;       &lt;span class=&quot;attr&quot;&gt;xmlns:xsi&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;       &lt;span class=&quot;attr&quot;&gt;xmlns:context&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;http://www.springframework.org/schema/context&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;       &lt;span class=&quot;attr&quot;&gt;xsi:schemaLocation&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;http://www.springframework.org/schema/beans&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;tag&quot;&gt;        https://www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;tag&quot;&gt;        http://www.springframework.org/schema/context&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;tag&quot;&gt;        https://www.springframework.org/schema/context/spring-context.xsd&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;bean&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;cat222&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;com.luo.pojo.Cat&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;catName&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;hao&amp;quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;bean&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;bean&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;dog111&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;com.luo.pojo.Dog&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;dogName&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;yue1&amp;quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;bean&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;bean&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;dog&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;com.luo.pojo.Dog&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;      &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 重点看这里，有两个Dog类型的bean --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;dogName&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;yue&amp;quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;bean&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;bean&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;people&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;com.luo.pojo.People&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;autowire&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;byType&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;name&amp;quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;luo&amp;quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;bean&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;context:annotation-config&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;beans&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后我利用@Autowired 配合 @Qualifier 对dog进行自动装配：&lt;/p&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="https://luo41.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>DNS基本工作原理</title>
    <link href="https://luo41.top/2021/08/11/DNS%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>https://luo41.top/2021/08/11/DNS%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</id>
    <published>2021-08-11T14:27:42.000Z</published>
    <updated>2021-10-23T11:44:41.632Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-需要dns-提供服务"><a class="markdownIt-Anchor" href="#1-需要dns-提供服务"></a> 1 需要DNS 提供服务</h3><p>我们知道，在计算机网络中，因为主机之间是需要通信的，所以很重要的一件事是找到<strong>一种方式去唯一性地识别一台主机</strong>，所以就有了主机MAC地址和IP地址，MAC地址又称为物理地址，计算机对于MAC地址和IP地址当然是乐于接受的，因为它们无非就是一串数字嘛，通过转换成01比特流能很好的在计算机之间传递这种MAC地址信息和IP地址信息。但计算机终究是给人用的，特别是对计算机不熟悉的普通大众来说，人们是记不住那么多的IP地址的，所以就出现了另一种主机名，<a href="http://xn--www-eo8e.example1.com">如www.example1.com</a>，就是大家平时所说的网址嘛，访问一个网站 <a href="http://www.example1.com">www.example1.com</a>，其实就是访问一台主机名为 <a href="http://www.example1.com">www.example1.com</a> 的服务器，这种识别主机的方式更容易被人们所接受。</p><p>尽管人们喜欢这种便于记忆的主机名标识方式，但是我们知道在计算机网络中，数据的传递还是要通过定长的，有着层次结构的IP地址，为了解决这两种不同的需求，我们就需要一种能进行主机名到IP地址转换的服务，这就需要**域名系统DNS(Domain Name System)**提供服务。</p><span id="more"></span><h3 id="2-dns工作原理"><a class="markdownIt-Anchor" href="#2-dns工作原理"></a> 2 DNS工作原理</h3><p>DNS提供了一种抽象，就像一个黑盒子，将网址输入黑盒，得到输出的IP地址，有了这层抽象，人们就不再需要每次都去关心我这个主机名对应哪个IP地址啊，只要设计好黑盒，需要时直接使用主机名，由DNS自动解析出IP地址即可。</p><p>所以问题就变成了如何实现这个提供服务的黑盒。</p><p>有一种<strong>最简单</strong>的设计就是在整个因特网中只使用一个DNS服务器，该服务器存储着所有的主机名和IP地址的映射关系，所有的查询都将发到这个服务器，同时该DNS服务器直接对查询的客户做出响应，这种设计的原理非常的简单，但是是不可行的，原因很简单，因特网的主机数量庞大，单个服务器是没有能力去处理这么多的查询，这种集中式的设计<strong>很容易崩溃</strong>。</p><p>所以现在DNS采用的是<strong>分布式的</strong>设计方案，DNS实现为一个分布式数据库，称为<strong>DNS服务器层次结构</strong>，如下图：</p><img src="/2021/08/11/DNS%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/1.png" style="zoom: 67%;"><p>实际上域名也是分级的，最顶级域名如我们平时常用的com, edu, cn，然后再一层一层分下去，从右到左，从最顶级到最低级。比如说 <a href="http://scnu.edu.cn">scnu.edu.cn</a> 这样一个网站，.cn是最顶级的域名，整个分配给了中国地区，然后政府再根据使用情况，划分出了一个子域名.edu作为教育网使用，教育部再划分出一个scnu给华南师范大学使用，一层一层分配。一个域名可以分配出多个子域名，比如还有gov.cn就是划分给政府部门使用的嘛，xxxx.edu.cn就是很多学校的域名了。</p><p>大致上，有4种类型的DNS服务器：</p><ol><li><p><strong>顶级域服务器</strong>，也称TLD(Top-Level Domain)服务器，如org，com，net，edu等等等等</p></li><li><p><strong>根DNS服务器</strong>，按照我们顶级域的划分，每个顶级域的划分都可以用一棵树表示，但是这些树好像没有联系起来，形成了森林，不利于整个DNS的管理，所以我们添加了一个<strong>根DNS服务器</strong>，让所有的顶级域服务器都变成它的子女，这样就形成了一棵<strong>DNS服务器树</strong>(好像没有这个专业名词哈哈，为了形象自己创造的)。</p></li><li><p><strong>权威DNS服务器</strong>，在因特网上具有可访问主机的<strong>每一个组织都必须提供公共可访问的DNS记录</strong>，这些DNS记录存着这些主机的名字和IP地址的映射关系，一个组织机构的权威DNS服务器就收藏着这些记录，比如说你华南师范大学嘛有这么多的主机连接在校园网中，你就必须提供一个权威DNS服务器收藏着你名下的各主机名和IP地址的对应关系，这样当有人查询你名下的一个主机名的IP地址时，权威DNS服务器能够给出响应。当然也不是非得华师就要自己手撸一个权威DNS服务器，可以向服务商买一个权威DNS服务器嘛，然后只要把记录写进服务器就好了。</p></li><li><p><strong>本地DNS服务器</strong>：本地DNS服务器起着代理的作用，当主机发出DNS请求时，该请求被发往本地DNS服务器，由本地DNS服务器转发到DNS服务器层次结构中。</p></li></ol><p>来看一个具体的例子，ps (图中的最近的DNS服务器即上面说到的本地DNS服务器,不同教材说法有差异)</p><img src="/2021/08/11/DNS%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/3.png" style="zoom: 100%;"><p>DNS的工作过程大致就如上图，注意上图①过程和②③④等过程的差别，客户端计算机询问最近的DNS服务器问“www.lab.glasscom.com的IP地址是多少？&quot;，最近的DNS服务器不知道，但是他没有直接返回客户端计算机说：“不知道”，而是作为一个<strong>代理</strong>，替客户端计算机去问“www.lab.glasscom.com的IP地址是多少?&quot;，查到了再告诉客户端计算机答案，有点送佛送到西那味，这种我们称为<strong>递归查询</strong>。而②③④过程所访问的服务器，他们也不知道“www.lab.glasscom.com的IP地址是多少？&quot;，他们不再帮本地DNS服务器查了，而是告诉本地DNS服务器：”我不知道，但是我告诉你，XXX知道，你问他去!&quot;，然后本地DNS再根据收到的信息去找下一个查，这种我们称为<strong>迭代查询</strong>。</p><p>下面是一个不仅本地DNS服务器使用<strong>递归查询</strong>，而且其他DNS服务器也是使用<strong>递归查询</strong>，都是老好人了…</p><img src="/2021/08/11/DNS%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/2.png" style="zoom: 80%;"><p>这就是DNS域名解析工作的大致原理了。</p><h3 id="3-dns缓存"><a class="markdownIt-Anchor" href="#3-dns缓存"></a> 3 DNS缓存</h3><p>每次访问一个主机都要通过DNS服务去查IP地址好麻烦啊，实际上，为了改善时延性能并减少在因特网上到处乱窜的DNS报文，DNS广泛地采用了<strong>缓存技术</strong>。</p><p>当访问过某个网站并得到其IP后，会将其域名(主机名)和IP缓存下来,下一次访问域名的时候，先查查缓存中有没有嘛，有就直接使用不需要去查了，提供了响应速度，当然了查询不到那还是得乖乖去找DNS求服务吧。</p><p>目前，计算机中DNS记录在本地有两种缓存方式，<strong>浏览器缓存</strong>和<strong>操作系统(OS)缓存</strong>，在浏览器中访问的时候，优先访问浏览器缓存，未命中则访问OS缓存，再找不到就去找本地DNS服务器咯。</p><ul><li><p><strong>浏览器缓存</strong>：指的是浏览器在获取网站域名的实际IP地址后会对IP进行缓存，减少延时，当然DNS缓存有一定的时间，过期就清除了。Google Chrome浏览器可以在地址栏输入chrome://net-internals/#dns，就可以看各域名的DNS缓存时间，很神奇，我输入这个网址时一个缓存也没有…。</p></li><li><p><strong>操作系统DNS缓存</strong>：存放在电脑里的缓存，windows系统下可以在cmd终端输入ipconfig/displaydns可以展示已经缓存的域名。ipconfig/flushdns 可以帮你马上清空已经缓存的记录，之所以要清空的话，因为有时因为一些恶意的病毒还是什么东西会存着错误的对应关系，需要清除。</p></li></ul><h3 id="4-dns服务和防火墙原理"><a class="markdownIt-Anchor" href="#4-dns服务和防火墙原理"></a> 4 DNS服务和防火墙原理</h3><p>通过上面我们知道，每次访问一个域名，如果本机没有存在缓存的话，那就得借用DNS服务去查找对应的IP地址，没有IP地址是无法访问目标主机的。</p><p>通过提供错误的DNS服务就是早期防火墙的基本原理，相当于给用户一个错误IP地址，防止用户进行不良的访问。</p><p>比如说用户B想访问G网站(G网站的IP地址为8.8.8.8），B只有G网站的域名而没有IP地址，这时候B就只能求助于DNS服务，而防火墙就相当于立在用户B主机和DNS解析服务器中间的一堵大墙，拦截DNS服务，告诉B说G网站的地址是3.3.3.3，从而遏制用户B的不良访问，这种也称为DNS污染。</p><p>有时候我们访问比如全球最大的同性交友网站  <a href="http://www.github.com">www.github.com</a> 不幸被墙，一个解决的方法就是手动将github网站的域名和IP地址添加到C:\Windows\System32\drivers\etc\hosts文件中，就像下面这样子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.30.252.131 github.com</span><br><span class="line">185.31.16.185 github.global.ssl.fastly.net</span><br></pre></td></tr></table></figure><p>关于hosts文件的话，hosts文件是一个没有拓展名的系统文件，用普通的记事本工具打开即可，hosts文件的作用就是将常用的网址域名和对应的IP地址的映射关系存放起来，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从hosts文件中寻找对应的IP地址，找到的话，就不再需要去寻求DNS域名解析服务咯，直接打开响应的网页，比如我们将github和他对应的IP地址写入hosts后，就不再需要DNS解析了，有时可以避免被墙。（但很奇怪，即使我将github和IP地址写入hosts后，有时候还是被墙）</p><p>而且hosts文件配置的映射是静态的，如果映射关系有所变化要手动修改，否则不能访问。</p><p>当然上面这个github网站配置是临时的，因为github的ip经常会变化，所以可以访问<a href="https://github.com.ipaddress.com/">https://github.com.ipaddress.com</a>查看最新的ip地址，将hosts文件中的github.com的ip地址改为最新的ip地址即可。（有时可能还需要先清除dns缓存，因为缓存可能有不正确的对应关系，导致得到不是最新的IP对应，访问失败）。</p><p>以上为自己的学习笔记，不当之处，请指正！</p><p>参考资料：</p><p>《计算机网络 自顶向下方法》第六版</p><p>《网络是怎样连接的》</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-需要dns-提供服务&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-需要dns-提供服务&quot;&gt;&lt;/a&gt; 1 需要DNS 提供服务&lt;/h3&gt;
&lt;p&gt;我们知道，在计算机网络中，因为主机之间是需要通信的，所以很重要的一件事是找到&lt;strong&gt;一种方式去唯一性地识别一台主机&lt;/strong&gt;，所以就有了主机MAC地址和IP地址，MAC地址又称为物理地址，计算机对于MAC地址和IP地址当然是乐于接受的，因为它们无非就是一串数字嘛，通过转换成01比特流能很好的在计算机之间传递这种MAC地址信息和IP地址信息。但计算机终究是给人用的，特别是对计算机不熟悉的普通大众来说，人们是记不住那么多的IP地址的，所以就出现了另一种主机名，&lt;a href=&quot;http://xn--www-eo8e.example1.com&quot;&gt;如www.example1.com&lt;/a&gt;，就是大家平时所说的网址嘛，访问一个网站 &lt;a href=&quot;http://www.example1.com&quot;&gt;www.example1.com&lt;/a&gt;，其实就是访问一台主机名为 &lt;a href=&quot;http://www.example1.com&quot;&gt;www.example1.com&lt;/a&gt; 的服务器，这种识别主机的方式更容易被人们所接受。&lt;/p&gt;
&lt;p&gt;尽管人们喜欢这种便于记忆的主机名标识方式，但是我们知道在计算机网络中，数据的传递还是要通过定长的，有着层次结构的IP地址，为了解决这两种不同的需求，我们就需要一种能进行主机名到IP地址转换的服务，这就需要**域名系统DNS(Domain Name System)**提供服务。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://luo41.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="DNS" scheme="https://luo41.top/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>传统加密技术</title>
    <link href="https://luo41.top/2021/07/26/%E4%BC%A0%E7%BB%9F%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/"/>
    <id>https://luo41.top/2021/07/26/%E4%BC%A0%E7%BB%9F%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/</id>
    <published>2021-07-25T16:50:38.000Z</published>
    <updated>2021-07-29T14:11:17.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cans3-classical-encryption-techniques传统加密技术"><a class="markdownIt-Anchor" href="#cans3-classical-encryption-techniques传统加密技术"></a> CANS3-CLASSICAL ENCRYPTION TECHNIQUES(传统加密技术)</h1><h2 id="1-symmetric-cipher-model"><a class="markdownIt-Anchor" href="#1-symmetric-cipher-model"></a> 1 SYMMETRIC CIPHER MODEL</h2><h3 id="11-五个基本成分"><a class="markdownIt-Anchor" href="#11-五个基本成分"></a> 1.1 五个基本成分</h3><p>对于一个对称加密的过程，有五个基本成分：</p><ul><li>明文 Plaintext 原始的可理解的消息或数据，是加密算法的输入</li><li>加密算法 Encryption algorithm 加密算法是对明文进行各种<strong>代替(substitutions)<strong>和</strong>置换(transformation)</strong>，以产生不可理解的密文</li><li>密钥 Secret key 密钥也是加密算法的输入，<strong>独立于</strong>明文和算法，算法根据所用的特定密钥而产生不同的输出，算法所进行的各种代替和置换也依靠密钥。</li><li>密文 Ciphertext 密文是加密算法的输出，直观看起来不可理解其代表的意识，依赖于<strong>明文</strong>和<strong>密钥</strong>，对于给定的相同的明文，不同的密钥将产生不同的密文。</li><li>解密算法 Decryption algorithm 本质上是加密算法的逆运算，输入为密文和密钥，输出<strong>原始明文</strong></li></ul><p>而对称密码对称的意思就是加密使用的密钥和解密使用的密钥是<strong>相同的</strong>。</p><span id="more"></span><h3 id="12-对称加密简化模型"><a class="markdownIt-Anchor" href="#12-对称加密简化模型"></a> 1.2 对称加密简化模型</h3><p>图3.1是对称加密的简化模型：</p><img src="/2021/07/26/%E4%BC%A0%E7%BB%9F%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/1.jpg" style="zoom: 20%;"><p>在一般的情况下，我们假设已知密文和加密/解密算法而破译消息是不实际的(<strong>impratical</strong>)，换而言之，我们并不需要对加密解密算法保密，最重要的是<strong>对密钥保密</strong>。使用对称密码，首要的安全问题就是<strong>密钥的保密性</strong>。</p><p>从图3.2理解对称加密的基本过程：</p><img src="/2021/07/26/%E4%BC%A0%E7%BB%9F%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/11.jpg" style="zoom: 15%;"><p>发送方产生明文消息X=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><msub><mi>X</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>X</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>X</mi><mi>M</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[X_{1},X_{2},....X_{M}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>，X的M个元素是某个字母表上的字母，传统上，字母表由26个大写字母组成，现在最常用的是二进制字母表{0,1}。加密时，先声成一个形如K=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><msub><mi>K</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>K</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>K</mi><mi>J</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[K_{1},K_{2},....K_{J}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.09618em;">J</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>的密钥,如果密钥是由信息的发送方产生的，那么密钥需要通过某些安全的渠道发送到接收方，另一种方法是<strong>由可信赖的第三方生成密钥</strong>再安全地<strong>分发</strong>给发送方和接收方。</p><p>前面提到，加密算法根据输入信息X和密钥K生成密文Y=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><msub><mi>Y</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>Y</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>Y</mi><mi>N</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[Y_{1},Y_{2},....Y_{N}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>，用数学公式可表示为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi><mo>=</mo><mi>E</mi><mo stretchy="false">(</mo><mi>K</mi><mo separator="true">,</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Y=E(K,X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span></span></p><p>表示密文Y是明文X的函数，什么样的函数？由<strong>密钥K</strong>决定。</p><p>解密的过程可表示为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>=</mo><mi>D</mi><mo stretchy="false">(</mo><mi>K</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X=D(K,Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span></span></p><h3 id="13-ctyptography"><a class="markdownIt-Anchor" href="#13-ctyptography"></a> 1.3 Ctyptography</h3><p>google了一下，Ctyptography的翻译是密码学，而cryptology的翻译也是密码学，在书里有：</p><blockquote><p>The areas of cryptography and cryptanalysis together are call <strong>crtptology</strong></p></blockquote><p>cryptanalysis是密码分析学，看了网上的一些翻译，Ctyptography译为密码编码学好像更好理解一点，这样<strong>密码编码学</strong>和<strong>密码分析学</strong>就统称为密码学。</p><p>Cryptography systems(密码编码学系统)有三个独立特征：</p><ul><li>The type of operations used for transforming plaintext to ciphertext 就是说是一种把明文转换为密文的运算，所以的加密算法都基于两个原理，代替(substitution)和置换(transposition)，代替是将明文中的每个元素(这个元素可以是位(bit)，字母(letter)等)映射成(<strong>mapped into</strong>)另一个元素。置换是将明文中的元素重新排列(rearrange)。运算的基本要求是不允许有信息丢失，也就是说所有的运算是<strong>可逆</strong>，通过密文和密钥可以解密出明文，并与原来加密前的明文完全一致。</li><li>The number of keys used 使用的密钥数 如果发送方和接收方使用相同的密钥，这种密码就称为对称密码(Symmetric)，又称单钥密码，传统密码。如果发收双方使用不同的密钥，这种密码就称为非对称密码(asymmetric)，双钥或公钥密码。</li><li>The way in which thee plaintext is processed 处理明文的方式 分组密码(<strong>block cipher</strong>)每次处理<strong>输入的一组元素</strong>，相应地<strong>输出一组元素</strong>。流密码(<strong>stream cipher</strong>)则是连续地处理输入元素，每次输出一个元素。</li></ul><h3 id="14-cryptanalysis-and-brute-force-attack"><a class="markdownIt-Anchor" href="#14-cryptanalysis-and-brute-force-attack"></a> 1.4 Cryptanalysis and Brute-Force Attack</h3><p>通常，攻击密码系统的典型目标是得到加密所使用的<strong>密钥</strong>，而不是仅仅恢复出单个密文对应的明文，攻击传统的密码系统有两种通用的方法</p><ul><li>Crytanalysis 密码分析学:  密码分析学攻击根据于算法的性质，明文的一般特征或某些<strong>明密文对</strong>，企图利用算法的特征推导出<strong>特定的明文</strong>和<strong>使用的密钥</strong>。</li><li>Brute-force attack 穷举攻击 攻击者对一条密文尝试<strong>所有可能的密钥</strong>，直到把它转换为<strong>可读的有意义的明文</strong>才算成功。平均而言，获得成功至少要尝试所有密钥的一半。</li></ul><p>如果<strong>密钥被推导出来了</strong>，那么影响是<strong>灾难性的(catastrophic)</strong>,意味着过去的和未来的所有使用该密钥加密的明文都将被推导出来，完全失去了加密的功能。</p><p>基于密码分析者知道信息的多少，表3.1概括了密码攻击的几种类型。</p><p>其中<strong>唯密文攻击</strong>(Ciphertext Only)难度最大，我们通常假设攻击者知道加密算法。最简单暴力的方法就是尝试遍所有密钥可能的穷举攻击，但是如果密钥空间非常大，这种方法就<strong>不切实际</strong>(impractic)，我们知道平均而言，获得成功至少要尝试所有密钥的一半。</p><p>因此，攻击者必须对密文本身分析，使用各种统计的方法。使用这种统计的方法，攻击者通常也需要对隐含的明文类型有所了解，是英文文本？可执行EXE文件？还是其他具有<strong>特定特征</strong>的文件。我的理解是，要根据对明文和密文的分析，<strong>大量</strong>排除掉那些不可能使用的密钥，<strong>减小密钥空间</strong>，当密钥空间小到一定程序时(也可以说我们已经分析到极限了，无法再通过分析的方法排除密钥)，再用穷举攻击去得到有意义的明文。</p><img src="/2021/07/26/%E4%BC%A0%E7%BB%9F%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/2.png" style="zoom: 67%;"><p>如图表3-1</p><p>**唯密文攻击(Ciphertext Only)**是最容易防范的，因为攻击者拥有的信息量最少。</p><p>与**已知明文攻击(Known Plaintext)**紧密相关的是可能词攻击(<strong>Probable-word attack</strong>)。如果攻击者处理的是一般的无固定格式的信息，那么他对信息的内容是一无所知的。但他如果处理的是一些特定的信息，比如特定的文件，一般这些文件的某些位置(比如说文件头部)是固定不变的，所以攻击者可能利用这些固定不变的字段。</p><p>如果攻击者能够通过某种方式获得信源系统，可以在发送方发送的信息中插入一段<strong>由他自己选择</strong>的信息，那么<strong>选择明文攻击(Chosen Plaintext)<strong>就有可能实现，攻击者当然会选择</strong>插入</strong>那些<strong>最有可能恢复出密钥的数据</strong>。</p><p>只有相对较弱的算法才抵挡不住唯密文攻击，一般地，<strong>加密算法起码要能经受得住已知明文攻击才行</strong>。</p><p><strong>unconditionally secure</strong> 无条件安全 ：如果一个密码体制满足条件，那就是：无论有多少可使用的密文，都不足以<strong>唯一地</strong>确定密文所对应的明文，则称该加密体制是<strong>无条件安全的</strong>。除了一次一密(one-time pad)之外，所有的加密算法都不是无条件安全的。</p><p>但是，尽管很难达到<strong>无条件安全</strong>，在挑选加密算法时，我们要尽量满足以下两个条件的算法：</p><ul><li>破译密码的代价超出了密文信息的价值</li><li>破译密码的时间超出密文信息的有效生命期</li></ul><p>满足以上两条标准的任意一条，则称为是<strong>计算上安全的(Computationally secure</strong>)。</p><p>需要提到的是，对称密码的所有分析方法都利用了这样的一个事实：<strong>明文的结构和模式(the traces of structure or pattern)在加密之后仍然保存了下来，并能在密文中找到一些蛛丝马迹</strong>。</p><h2 id="2-subtitution-techniques"><a class="markdownIt-Anchor" href="#2-subtitution-techniques"></a> 2 SUBTITUTION TECHNIQUES</h2><blockquote><p>所有的加密算法都基于两个原理，代替(substitution)和置换(transposition)，代替是将明文中的每个元素(这个元素可以是位(bit)，字母(letter)等)映射成(<strong>mapped into</strong>)另一个元素。</p></blockquote><p>如果把明文看成是二进制序列，那么代替就是用密文位串来代替明文位串。</p><h3 id="21-caesar-密码"><a class="markdownIt-Anchor" href="#21-caesar-密码"></a> 2.1 Caesar 密码</h3><p>凯撒密码是最早的代替密码，它的加密算法非常简单，就是简单地对字母表中的每个字母，用它之后的第3个字母来代替。</p><p>如：</p><p>明文：meet me after the toga party<br>密文：PHHW PH DIWHV WKH WRJD SDUWB</p><p>注意字母表是循环的，即紧随Z后的字母是A，我们列出所有的映射关系定义如下变换：</p><p>明文 a  b  c  d  e  f  g  h  i   j  k  l  m n  o   p   q   r  s  t   u  v  w  x   y  z<br>密文 D E  F G  H I  J  K L M N O P  Q R  S   T  U V W X Y  Z  A  B  C</p><p>为了方便列出加密算法的表达式，我们让每个字母等价与一个数值：</p><table><thead><tr><th>a</th><th>b</th><th>c</th><th>d</th><th>e</th><th>f</th><th>g</th><th>h</th><th>i</th><th>j</th><th>k</th><th>l</th><th>m</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td></tr></tbody></table><table><thead><tr><th>n</th><th>o</th><th>p</th><th>q</th><th>r</th><th>s</th><th>t</th><th>u</th><th>v</th><th>w</th><th>x</th><th>y</th><th>z</th></tr></thead><tbody><tr><td>13</td><td>14</td><td>15</td><td>16</td><td>17</td><td>18</td><td>19</td><td>20</td><td>21</td><td>22</td><td>23</td><td>24</td><td>25</td></tr></tbody></table><p>那么加密算法可以如下表达，对于每个明文字母p，代替称密文字母C</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>=</mo><mi>E</mi><mo stretchy="false">(</mo><mn>3</mn><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>p</mi><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mo stretchy="false">(</mo><mn>26</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C=E(3,p)=(p+3)\  mod (26)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord">2</span><span class="mord">6</span><span class="mclose">)</span></span></span></span></span></p><p>同时，移位量可以是任意的整数k，也就是说可以用它之后的第k个字母表示该字母，这样就得到了一般的Caesar算法：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>=</mo><mi>E</mi><mo stretchy="false">(</mo><mi>k</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>p</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mo stretchy="false">(</mo><mn>26</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C=E(k,p)=(p+k)\  mod (26)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord">2</span><span class="mord">6</span><span class="mclose">)</span></span></span></span></span></p><p>k的取值范围是1~25</p><p>解密算法是</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>=</mo><mi>D</mi><mo stretchy="false">(</mo><mi>k</mi><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>C</mi><mo>−</mo><mi>k</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mo stretchy="false">(</mo><mn>26</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p=D(k,C)=(C-k)\ mod (26)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord">2</span><span class="mord">6</span><span class="mclose">)</span></span></span></span></span></p><p>如果判断出给定的密文是凯撒密码，破译算法是容易的，因为密钥k只有25种可能，穷举攻击非常容易实现。</p><h3 id="22-monoalphabetic-ciphers"><a class="markdownIt-Anchor" href="#22-monoalphabetic-ciphers"></a> 2.2 Monoalphabetic Ciphers</h3><p>Caesar密码仅仅有25种可能的密钥，是远不够安全的，需要增大密钥空间。我们知道Caesar密码密钥k一旦确定，每一个字母都被加密成其后的第k个字母，但如果通过<strong>任意替代</strong>，密钥空间将会急剧增大。</p><ul><li><strong>permutation  排列</strong>：我们定义排列，有限元素的集合S的排列是S的所有元素的有序排放，且<strong>每个元素只出现一次</strong>，例如S={a,b,c}，则S有6个排列 abc,acb,bac,bca,cab,cba，显然，<strong>具有n个元素的集合有n!个排列方式</strong>。</li></ul><p>前面提到的Caesar</p><p>明文 a  b  c  d  e  f  g  h  i   j  k  l  m n  o   p   q   r  s  t   u  v  w  x   y  z<br>密文 D E  F G  H I  J  K L M N O P  Q R  S   T  U V W X Y  Z  A  B  C</p><p>如果每一个字母都可以对应26个字母中的任意一个字母，那么我们就有26!或大于4×<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>26</mn></msup></mrow><annotation encoding="application/x-tex">10^{26}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span>中可能的密钥，密钥空间大大增大，似乎可以抵挡穷举攻击了。这种方法就称为<strong>单表替代 Monoalphabetic Ciphers</strong></p><p>考虑以下的一段密文：</p><img src="/2021/07/26/%E4%BC%A0%E7%BB%9F%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/3.png"><p>首先我们把字母使用的相对频率统计出来，得到密文中个字母的相对频率(百分比)如下：</p><img src="/2021/07/26/%E4%BC%A0%E7%BB%9F%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/4.png"><p>与英文文本中字母的使用频率分布做比较(如下图)</p><img src="/2021/07/26/%E4%BC%A0%E7%BB%9F%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/12.jpg"><p>我们在前面提到：</p><blockquote><p>需要提到的是，对称密码的所有分析方法都利用了这样的一个事实：<strong>明文的结构和模式(the traces of structure or pattern)在加密之后仍然保存了下来，并能在密文中找到一些蛛丝马迹</strong>。</p></blockquote><p>我们所说的明文的结构和模式在加密之后仍然被保存了下来，字母出现的频率就是其中一个特征，明文的字母频率会保存在密文当中。</p><p>将明文和密文中的字母的出现频率做比较，我们可以得出初步的结论，密文字母中的P和Z可能相当于明文中的e和t，但是并不能完全确实P对于的是e还是t，Z对应的是e还是t，因为<strong>字母频率虽然保存了下来，但并不是完全一致的，是大致接近</strong>。原因是英语中各字母的出现频率是基于大量的英文文本统计得到的，而这里一小段密文可能个字母出现的频率会有所差异，当密文的长度足够长时，就会越接近。<br>S,U,O,M和H的相对频率也比较高，可能与明文中的字母a,h,i,n,o,r,s中某一个对应，以此类推。</p><p>此时如何进一步确定对应关系？</p><p>统计双字母组合(我们称一个双字母组合为<strong>digrams</strong>)是比较有效地工具，英语(明文)中最常用的一个字母组合为th，而在我们的密文中，用得最多的双字母组合是ZW，因此我们进一步估计Z对应明文t，W对应明文h，根据先前的假设，可以暂且认为P对应e，所以密文中的ZWP很可能就是the。</p><p>进一步观察明文序列，第一行中出现了子序列ZWSZ，根据我们已有的假设，它应该被翻译为th_t，根据我们的<strong>英语能力！！！</strong>，S很有可能是a,<strong>that!</strong>。</p><p>至此我们得到了以下的结果：<img src="/2021/07/26/%E4%BC%A0%E7%BB%9F%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/5.png"></p><p>继续以上类似的分析，测试就可以得到完整的明文，加上空格后如下：<img src="/2021/07/26/%E4%BC%A0%E7%BB%9F%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/6.png"></p><p><strong>单表替代密码</strong>改进了凯撒密码密钥空间小的问题，但是仍然容易被攻破，因为密文中<strong>仍然保留着原始明文的字母频率等一些统计学特征</strong>。解决的对策有对每个字母提供<strong>多种代替</strong>，一个明文单元变换称不同的密文单元，比如字母e可以替换成16,74,35,21，然后循环或者随机地选取其中一个同音词即可，但仍然<strong>存在明文的一个元素只能影响密文中一个元素</strong>的缺陷，明文的一些结构和模式还残留在密文中，使得密码分析者得以利用。</p><p>有两种主要的减少代替密码明文结构在密文中的<strong>残留度</strong>，一种是明文中的<strong>多个字母(multiple letters)<strong>一起加密，另一种是采用</strong>多表(multiple cipher alphabets)代替密码</strong>，后面会提及。</p><h3 id="23-playfair-cipher"><a class="markdownIt-Anchor" href="#23-playfair-cipher"></a> 2.3 Playfair Cipher</h3><blockquote><p>The best-known multiple-letter encryption cipher is the Playfair, which treats <strong>disgrams</strong> in the plaintext as <strong>single units</strong> and translates these units into ciphertext diagrams.</p></blockquote><p>Playfair 密码是最著名的多字母代替密码，它将明文中的<strong>diagrams</strong>,也就是双字母组合作为一个单元，并将其转换成密文中的<strong>diagram</strong>(双字母组合)。</p><p>Playfair算法基于一个由密钥词构成的5×5字母矩阵，假设使用的密钥词为monarchy，填充矩阵的方法是首先将密钥词从左至右，从上至下填在矩阵格子中(注意重复字母只填一次)，再将剩余的字母按字母表的顺序从左至右，从上至上填在矩阵剩下的格子里，字母I/J暂且当成一个字母。以密钥monarchy为例，填完矩阵如下：</p><table><thead><tr><th style="text-align:left">M</th><th>O</th><th>N</th><th>A</th><th>R</th></tr></thead><tbody><tr><td style="text-align:left">C</td><td>H</td><td>Y</td><td>B</td><td>D</td></tr><tr><td style="text-align:left">E</td><td>F</td><td>G</td><td>I/J</td><td>K</td></tr><tr><td style="text-align:left">L</td><td>P</td><td>Q</td><td>S</td><td>T</td></tr><tr><td style="text-align:left">U</td><td>V</td><td>W</td><td>X</td><td>Z</td></tr></tbody></table><p>对明文的双字母组合按如下的规则加密：</p><ol><li>如果该字母对的两个相同的，那么在它们之间加一个填充字母，比如x。例如balloon先把它变成ba lx lo on 这样四个字母对。</li><li>落在矩阵同一行的明文字母对中的字母均由其<strong>右边</strong>的字母来代替，每行的最右边一个字母就用该行的最左边的第一个字母代替，相当于一个<strong>循环</strong>，比如AR就变成RM。</li><li>落在矩阵同一列中的明文字母对中的字母均由其<strong>下方</strong>的字母来代替，每列中最下面的一个字母由每列的最上面字母代替，比如mu就变成CM。</li><li>其他的明文的字母对按以下的方式代替，该字母所在的行作为对应密文字母的行，另一字母的列作为对应密文字母所在的列，比如hs变成BP,ea变成IM(或JM)。</li></ol><p>Playfair密码相对于简单地单表密码进步在于，26个字母共有676种字母对组合，因此识别出单个字母对要困难得多，同时因为是两个字母加密得到两个字母。单个字母的<strong>相对频率特征</strong>(在密文中的残留度)在一定程度上减弱了，这样利用频率分析字母对就更困难一些。</p><p>虽然在一定程度上减弱了，但是它的密文仍然完好地保留了明文的大部分结构特征(<strong>频率特征</strong>)。</p><p>图3.6显示了Playfair密码和其他一些密码加密的有效性。标有&quot;明文&quot;的曲线画出了26个字母的频率分布(不区分大小写)，这也是<strong>任意单表代替密码的频率分布</strong>，因为单表代替密码的方式是一个明文字母对应一个密文字母，所以频率被完整保留了下来。</p><p>曲线代表的意思是：对文章中出现的每个字母计数，计数结果除以使用频率最高的字母e的出现次数，设e出现的频率为1，则t大约为9.056/12.702约为0.72。水平轴上的点对应着<strong>按使用频率递降</strong>的字母。</p><p>也表明了使用Playfair密码加密后文本的字母频率分布情况，曲线体现了加密后字母频率分布被<strong>隐藏</strong>的程度，单表代替密码，有了提高。</p><p>可以看到一条水平的线，该线表示，频率分布的信息完全被加密过程隐藏了，唯密文密码分析由字母频率去下手一无所获，因为每个字母出现的相对频率都是一样的。</p><img src="/2021/07/26/%E4%BC%A0%E7%BB%9F%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/15.jpg"><h3 id="24-hill-cipher"><a class="markdownIt-Anchor" href="#24-hill-cipher"></a> 2.4 Hill Cipher</h3><p>Hill密码属于<strong>多表代替密码(multiletter cipher)</strong>。</p><p>Hill密码需要一些线代代数的知识。定义方阵M，M有逆矩阵<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>M</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">M^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>满足M(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>M</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">M^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>)=(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>M</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">M^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>)M=I，其中I为单位矩阵。</p><p>Hill算法 该加密算法将m个连续地明文字母代替成m个密文字母，这是由m个线性等式决定的，在等式里每一个字母被指定为一个数值,例如m=3，系统可以描述为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>c</mi><mn>1</mn></msub><mtext> </mtext><msub><mi>c</mi><mn>2</mn></msub><mtext> </mtext><msub><mi>c</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msub><mi>p</mi><mn>1</mn></msub><mtext> </mtext><msub><mi>p</mi><mn>2</mn></msub><mtext> </mtext><msub><mi>p</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>k</mi><mn>11</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>k</mi><mn>12</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>k</mi><mn>13</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>k</mi><mn>21</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>k</mi><mn>22</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>k</mi><mn>23</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>k</mi><mn>31</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>k</mi><mn>32</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>k</mi><mn>33</mn></msub></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mn>26</mn></mrow><annotation encoding="application/x-tex">(c_{1}\ c_{2}\ c_{3} )=(p_{1}\ p_{2}\ p_{3})\begin{pmatrix} k_{11} &amp; k_{12} &amp; k_{13} \\ k_{21} &amp; k_{22} &amp; k_{23} \\ k_{31} &amp; k_{32} &amp;k_{33} \end{pmatrix}  mod \  26</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord">2</span><span class="mord">6</span></span></span></span></span></p><p>展开有：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>k</mi><mn>11</mn></msub><msub><mi>p</mi><mn>1</mn></msub><mo>+</mo><msub><mi>k</mi><mn>21</mn></msub><msub><mi>p</mi><mn>2</mn></msub><mo>+</mo><msub><mi>k</mi><mn>31</mn></msub><msub><mi>p</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mn>26</mn><mspace linebreak="newline"></mspace><msub><mi>c</mi><mn>2</mn></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>k</mi><mn>12</mn></msub><msub><mi>p</mi><mn>1</mn></msub><mo>+</mo><msub><mi>k</mi><mn>22</mn></msub><msub><mi>p</mi><mn>2</mn></msub><mo>+</mo><msub><mi>k</mi><mn>32</mn></msub><msub><mi>p</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mn>26</mn><mspace linebreak="newline"></mspace><msub><mi>c</mi><mn>3</mn></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>k</mi><mn>13</mn></msub><msub><mi>p</mi><mn>1</mn></msub><mo>+</mo><msub><mi>k</mi><mn>23</mn></msub><msub><mi>p</mi><mn>2</mn></msub><mo>+</mo><msub><mi>k</mi><mn>33</mn></msub><msub><mi>p</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mn>26</mn></mrow><annotation encoding="application/x-tex">c_{1}=(k_{11}p_{1}+k_{21}p_{2}+k_{31}p_{3}) \ mod \ 26 \\ c_{2}=(k_{12}p_{1}+k_{22}p_{2}+k_{32}p_{3}) \ mod \ 26 \\ c_{3}=(k_{13}p_{1}+k_{23}p_{2}+k_{33}p_{3}) \ mod \ 26</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord">2</span><span class="mord">6</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord">2</span><span class="mord">6</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord">2</span><span class="mord">6</span></span></span></span></span></p><p>或</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>=</mo><mi>P</mi><mi>K</mi><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mn>26</mn></mrow><annotation encoding="application/x-tex">C=PK \ mod \ 26</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord">2</span><span class="mord">6</span></span></span></span></span></p><p>C和K是长度为3的行向量，分别代表密文和明文，K为3×3的矩阵，代表加密密钥，运算按模26执行。</p><p>举书里的例子，明文为“paymoremoney&quot;，加密密钥为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mtext> </mtext><mo>=</mo><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>17</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>17</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>5</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>21</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>18</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>21</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>19</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">K\ = \begin{pmatrix}17 &amp; 17 &amp; 5 \\21 &amp; 18 &amp; 21\\2  &amp; 2 &amp;19\end{pmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace"> </span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">7</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord">1</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">7</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">8</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord">1</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">9</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>明文以三个字母为一组，用向量表示，比如前三个字母用向量表示为(15 2 24)，那么(15 0 24) K = (303 303 531) mod 26 =(17 17 11)=RRL，照此方式转换余下字母，可得整段明文对应的密文为RRLMWBKASPDH。</p><p>解密则需要矩阵K的逆矩阵<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>K</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">K^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>，表示为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>=</mo><mi>D</mi><mo stretchy="false">(</mo><mi>K</mi><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo><mo>=</mo><mi>C</mi><msup><mi>K</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mn>26</mn></mrow><annotation encoding="application/x-tex">P=D(K,C) = CK^{-1} \ mod \ 26</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.864108em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord">2</span><span class="mord">6</span></span></span></span></span></p><p><strong>同Playfair密码相比</strong>，Hill密码的优点是完全隐蔽了单字母频率特性，因为Hill密码是m个明文字母影响m个密文字母。<strong>如果用的密钥矩阵越大，隐藏的频率信息就越多</strong>。</p><p>Hill密码能<strong>很好地抵挡唯密文攻击</strong>，但是它容易被<strong>已知明文攻击破解</strong>。考虑以下的例子，假设明文&quot;hillcipher&quot;经过一个2×2的Hill密码加密生成HCRZSSXNSP，因此我们知道hi=(7,8)被加密为HC=(7,2)，有(7 8)K mod 26 =(7 2) 同理 (11 11)K mod 26 = (17 25)；以此类推，由前两个明密文对，可得</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>7</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>17</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>25</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mo>=</mo><mtext> </mtext><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>7</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>8</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>11</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>11</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mi>K</mi><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mn>26</mn></mrow><annotation encoding="application/x-tex">\begin{pmatrix}7 &amp; 2 \\17&amp; 25\end{pmatrix}=\ \begin{pmatrix}7 &amp; 8 \\11&amp; 11\end{pmatrix}K \ mod \ 26</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">7</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace"> </span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">7</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">8</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord">2</span><span class="mord">6</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>7</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>8</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>11</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>11</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mi mathvariant="normal">的</mi><mi mathvariant="normal">逆</mi><mi mathvariant="normal">矩</mi><mi mathvariant="normal">阵</mi><mi mathvariant="normal">为</mi><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>25</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>22</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>23</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{pmatrix}7 &amp; 8 \\11&amp; 11\end{pmatrix}的逆矩阵为\begin{pmatrix}25 &amp; 22 \\1&amp; 23\end{pmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">7</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">8</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">逆</span><span class="mord cjk_fallback">矩</span><span class="mord cjk_fallback">阵</span><span class="mord cjk_fallback">为</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord">5</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span></span></span></span></p><p>弱弱问一句，有没有看官知道逆矩阵怎么用LATEX书写出来…</p><p>因此</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mo>=</mo><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>25</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>22</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>23</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>7</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>17</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>25</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mo>=</mo><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>549</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>600</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>398</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>577</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mn>26</mn><mo>=</mo><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>8</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>5</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">K=\begin{pmatrix}25 &amp; 22 \\1  &amp; 23\end{pmatrix}\begin{pmatrix}7 &amp; 2 \\17 &amp; 25\end{pmatrix}= \begin{pmatrix}549 &amp; 600 \\398 &amp; 577\end{pmatrix}mod \ 26 =\begin{pmatrix}3 &amp;2 \\8 &amp;5 \end{pmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord">5</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">7</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span><span class="mord">4</span><span class="mord">9</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span><span class="mord">9</span><span class="mord">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">6</span><span class="mord">0</span><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span><span class="mord">7</span><span class="mord">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord">2</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span></span></span></span></p><p>得到了密钥K，可以由剩下的明密文对去验证。</p><h3 id="25-polyalphabetic-ciphers"><a class="markdownIt-Anchor" href="#25-polyalphabetic-ciphers"></a> 2.5 Polyalphabetic Ciphers</h3><p>对简单单表代替的改进方法是在明文消息中采用不同的单表代替，这种方法我们一般称之为<strong>多表代替密码</strong>。所以这些方法都有以下的共同特征：</p><ol><li>采用<strong>相关的单表代替规则集</strong>。</li><li>密钥决定变换的具体规则。</li></ol><h4 id="vigenere-密码"><a class="markdownIt-Anchor" href="#vigenere-密码"></a> Vigenere 密码</h4><p>Vigenere代替规则由26个Caesar密码的代替表组成，其中每一个代替表是对明文字母表移位0~25次后得到的代替单表。<strong>每个密码由一个密钥字母来表示</strong>。</p><p>可以那个如下的方式表述Vigenere密码，假设明文序列为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>=</mo><msub><mi>p</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>p</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>p</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">P=p_{0},p_{1},...,p_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>,密钥由序列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mo>=</mo><msub><mi>k</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>k</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>k</mi><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">K=k_{0},k_{1},...k_{m-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>构成，其中m&lt;n。密码序列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>=</mo><msub><mi>C</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>C</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">C=C_{0},C_{1},...C_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>，计算如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>=</mo><msub><mi>C</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>C</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>E</mi><mo stretchy="false">(</mo><mi>K</mi><mo separator="true">,</mo><mi>P</mi><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mo>=</mo><mo stretchy="false">(</mo><msub><mi>p</mi><mn>0</mn></msub><mo>+</mo><msub><mi>k</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mn>26</mn><mo separator="true">,</mo><mo stretchy="false">(</mo><msub><mi>p</mi><mn>1</mn></msub><mo>+</mo><msub><mi>k</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mn>26....</mn><mo stretchy="false">(</mo><msub><mi>p</mi><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>k</mi><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mn>26</mn><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><msub><mi>p</mi><mi>m</mi></msub><mo>+</mo><msub><mi>k</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mn>26</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><msub><mi>P</mi><mrow><mn>2</mn><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>k</mi><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mn>26</mn></mrow><annotation encoding="application/x-tex">C=C_{0},C_{1},C_{2}...C_{n-1}=E(K,P) \\=(p_{0}+k_{0})\ mod\ 26,(p_{1}+k_{1})\ mod \ 26 .... (p_{m-1}+k_{m-1})\ mod \ 26,\\(p_{m}+k_{0})\ mod\ 26,...(P_{2m-1}+k_{m-1})\ mod \ 26</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord">2</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord">2</span><span class="mord">6</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord">2</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord">2</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord">2</span><span class="mord">6</span></span></span></span></span></p><p>注意<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">p_{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>对应的密钥字母为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">k_{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，开始新一轮的循环。</p><p>所以，加密过程的一般方程为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>p</mi><mi>i</mi></msub><mo>+</mo><msub><mi>k</mi><mrow><mtext> </mtext><mi>i</mi><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>m</mi></mrow></msub><mo stretchy="false">)</mo><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mn>26</mn></mrow><annotation encoding="application/x-tex">C_{i}=(p_{i}+k_{\ i\ mod \ m})\ mod \ 26</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mspace mtight"><span class="mtight"> </span></span><span class="mord mathdefault mtight">i</span><span class="mspace mtight"><span class="mtight"> </span></span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">d</span><span class="mspace mtight"><span class="mtight"> </span></span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord">2</span><span class="mord">6</span></span></span></span></span></p><p>与Caesar密码的加密过程的表达式类似，<strong>本质上</strong>，每一个明文字母根据相应的密钥字母进行着Caesar密码加密。</p><p>解密过程也与Caesar密码类似：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>C</mi><mi>i</mi></msub><mo>−</mo><msub><mi>k</mi><mrow><mtext> </mtext><mi>i</mi><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>m</mi></mrow></msub><mo stretchy="false">)</mo><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mn>26</mn></mrow><annotation encoding="application/x-tex">p_{i}= (C_{i}-k_{\ i \ mod \ m})\ mod \ 26</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mspace mtight"><span class="mtight"> </span></span><span class="mord mathdefault mtight">i</span><span class="mspace mtight"><span class="mtight"> </span></span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">d</span><span class="mspace mtight"><span class="mtight"> </span></span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord">2</span><span class="mord">6</span></span></span></span></span></p><p><strong>加密一条消息需要与消息一样长的密钥</strong>。所以通常，密钥是一个<strong>密钥词</strong>的重复，比如密钥词为deceptive，那么消息&quot;we are discovered save yourself&quot;将被这样加密</p><img src="/2021/07/26/%E4%BC%A0%E7%BB%9F%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/7.png"><p>用表格来表述，有：<img src="/2021/07/26/%E4%BC%A0%E7%BB%9F%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/14.jpg"></p><p>这种密码的强度在于<strong>每个明文字母对应着多个密文字母</strong>，且<strong>每个密文字母使用唯一的密钥字母</strong>，因此字母出现的频率信息被屏蔽了。</p><p>破译Vigenere密码的关键在于<strong>能否判断密钥词的长度</strong>。</p><p>很关键的一点，如果<strong>两个相同的明文序列之间的距离是密钥词长度的整数倍</strong>，那么<strong>产生的密文序列也是相同的</strong>。因为明文序列相同，距离是密钥词长度的整数倍，所以对应的密钥字母相等，这样产生的密文序列也一定相同。</p><p>实际上，如果密钥长度是m，那么密码实际上包含了m个单表代替。以DECEPTIVE作为密钥词，那么处在位置1,10,19,…的字母的加密实际上是凯撒密码(单表加密)，因为他们都加上D，mod 26。因此，如果我们得到了密钥的长度m，我们可以将密文拆成多个凯撒密码加密(单表代替)，然后利用单表代替加密没有消除的频率特征分布进行攻击，破译密码。</p><h4 id="vernam-cipher"><a class="markdownIt-Anchor" href="#vernam-cipher"></a> Vernam CIPHER</h4><p>Vernam密码其运算基于二进制数据而非字母，该加密过程可以简明的描述为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub><mo>=</mo><msub><mi>p</mi><mi>i</mi></msub><mo>⊕</mo><msub><mi>k</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_{i}=p_{i}\oplus k_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>其中<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是明文第i个二进制位，<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">k_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是密钥的第i个二进制位，<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是密文的第i个二进制位，使用的是异或运算。</p><p>根据异或运算的性质，解密过程为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub><mo>=</mo><msub><mi>c</mi><mi>i</mi></msub><mo>⊕</mo><msub><mi>k</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_{i}=c_{i}\oplus k_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>这种加密技术的<strong>本质在于构造密钥的方式</strong>。</p><img src="/2021/07/26/%E4%BC%A0%E7%BB%9F%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/8.png"><p>Vernam也是一种流密码(<strong>Stream Ciphers</strong>)。流密码的定义简单来说将明文看成字符串或比特流，并逐字符或逐比特进行加密。</p><blockquote><p>A stream cipher is one that encrypts a digital stream ont bit or one byte at a time。</p></blockquote><h3 id="26-one-time-pad"><a class="markdownIt-Anchor" href="#26-one-time-pad"></a> 2.6 One-Time pad</h3><p>One-Time pad为一次一密。是对Vernam密码的改进方案，从而达到了<strong>最完善的安全性</strong>。</p><p>One-Time pad使用与消息(明文)<strong>一样长</strong>且<strong>无重复</strong>的<strong>随机密钥流</strong>来加密消息，另外，密钥只对一个消息进行加解密，之后就丢弃不用了。因此，每一条新消息都需要一个与其等长的新密钥流，这就是著名的一次一密。它是不可攻破的(<strong>unbreakable</strong>)。</p><p>如果密码分析者得到了密文，假设出了两个密钥，破译出明文，但他没有理由认为哪一个明文是正确的。因此这种<strong>密码是不可破</strong>的。</p><p>一次一密的安全性<strong>完全取决于密钥的随机性</strong>。如果构成密钥的字符流是真正随机地，那么构成密文的字符流也是真正随机的，因此分析者没有任何攻击密文的模式和规律可用。</p><p>理论上，One-Time pad提供了完美的安全性，但在实际中，存在两个基本的难点</p><ul><li>产生大规模<strong>随机密钥</strong>是有困难的。</li><li>密钥的分配和保护。每一条发送的消息，都需要提供给发送方和接收方<strong>等长</strong>的密钥，存在着庞大的密钥分配问题。</li></ul><p><strong>一次一密</strong>是<strong>唯一</strong>的<strong>具有完美保密</strong>(perfect secrecy)的密码机制。</p><p>任何满足perfect secrecy的加密系统都需要满足两个前提：</p><ol><li>密钥空间足够大，至少等于明文空间</li><li>一个密钥只能用于一次加密</li></ol><p>但实际上perfect secrecy的加密系统的不切实际的(impractical)，原因就在于以上说的两个难点。</p><p>在理想状况下，除非是获得了<strong>密钥比特流</strong>，否则这个密码是不可破的，然而密钥流也必须以某种<strong>独立，安全的信道提供给发送方和接收方双方</strong>，但如果待传递的<strong>密钥流很长</strong>，造成的&quot;通信流量&quot;很大，这就成为了一个障碍，相应的出于实用的原因，密钥流可以以算法程序(这里称为比特流生成算法，算法以密钥K为input，获得<strong>密钥比特流</strong>作为output)的方式实现，从而双方都可以生成密钥比特流，在这种方法中，两个用户<strong>只需要共享生成密钥</strong>，就可以各自生成密钥流。</p><img src="/2021/07/26/%E4%BC%A0%E7%BB%9F%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/11.png"><h2 id="3-transposition-techniques"><a class="markdownIt-Anchor" href="#3-transposition-techniques"></a> 3 TRANSPOSITION TECHNIQUES</h2><p>到目前为止，前面我们所讨论的都是将明文字母代替为密文字母，与之非常不同的一种加密方法是对明文进行<strong>置换</strong> Transposition，这种密码称为置换密码。</p><p>最简单的例子是栅栏(fence)技术,按照对角线的顺序写出明文，而按行的顺序读出作为密文。例如，假设用密钥为<strong>2</strong>的栅栏技术加密信息“meet me after the toga party&quot; 可写为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m.e.m.a.t.r.h.t.g.p.r.y</span><br><span class="line">.e.t.e.f.e.t.e.o.a.a.t</span><br></pre></td></tr></table></figure><p>根据行读出作为密文，加密后的信息为<strong>MEMATRHTGPRYETEFETEOAAT</strong></p><p>再比如使用密钥为8的V型栅栏密码加密明文“Don’t deny something easily, maybe you’re just in a bad mood today”(不要轻易否认一切事情，你可能今天只是心情不好！)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">D............. e.............m.............u.............o.............</span><br><span class="line">.o........... m.t........... .a...........j.s ..........m.o.............</span><br><span class="line">..n......... o...h.........y...y......... ...t.........&#x27;...d............</span><br><span class="line">...‘....... s.....i.......l.....b ......e..... .......d ..... ..........</span><br><span class="line">....t ..... .......n.....i.......e.....r.......i.....a....... t..........</span><br><span class="line">..... ...y......... g...s ........ ...’.........n...b.......... o...！....</span><br><span class="line">......d.n........... .a........... y.u........... . .............d.y....</span><br><span class="line">.......e.............e............. o.............a...............a......</span><br></pre></td></tr></table></figure><p>按行读出密文位：DEMUOOMTAJSMONOHYY T’D’SILBE D T NIERIAT YGS 'NBO!DN AYU  DYEEOAA</p><p>因为形状像V，也称位V型栅栏密码</p><p>一个更复杂的方案是把消息一行一行地写成矩形块，然后按列读出，把列的次序打乱，列的次序就是算法的密钥。例如：</p><img src="/2021/07/26/%E4%BC%A0%E7%BB%9F%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/9.png"><p>明文为&quot;attackpostponeduntiltwoamxyz&quot;，按行写入矩阵，然后按密钥给出的各列次序，依次读出各列作为密文，最终密文为TTNAAPTMTDUOAODWCDIXKNLYPETZ</p><p><strong>单纯的置换密码</strong>因为有着与原始明文相同的字母频率特征而容易被识别，因为置换只是将位置打乱，并没有将各元素改变。</p><p>多次置换密码使得消息更难被重构起来，我们可以用前面得到的密文TTNAAPTMTDUOAODWCDIXKNLYPETZ作为明文，做再一次的置换，得到新的密文，如图：</p><img src="/2021/07/26/%E4%BC%A0%E7%BB%9F%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/10.png"><p>这样操作后，分析者攻击它要困难得多了~</p><p>终于写完了(这玩意居然写了我一天？！)</p><p><strong>仅仅是初学者的学习笔记</strong>，很多东西还没有学到而且对新学的东西认识也还很浅，如有错误，欢迎指正！！！！</p><p>参考资料 《密码编码学与网络安全》第八版</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;cans3-classical-encryption-techniques传统加密技术&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cans3-classical-encryption-techniques传统加密技术&quot;&gt;&lt;/a&gt; CANS3-CLASSICAL ENCRYPTION TECHNIQUES(传统加密技术)&lt;/h1&gt;
&lt;h2 id=&quot;1-symmetric-cipher-model&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-symmetric-cipher-model&quot;&gt;&lt;/a&gt; 1 SYMMETRIC CIPHER MODEL&lt;/h2&gt;
&lt;h3 id=&quot;11-五个基本成分&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#11-五个基本成分&quot;&gt;&lt;/a&gt; 1.1 五个基本成分&lt;/h3&gt;
&lt;p&gt;对于一个对称加密的过程，有五个基本成分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;明文 Plaintext 原始的可理解的消息或数据，是加密算法的输入&lt;/li&gt;
&lt;li&gt;加密算法 Encryption algorithm 加密算法是对明文进行各种&lt;strong&gt;代替(substitutions)&lt;strong&gt;和&lt;/strong&gt;置换(transformation)&lt;/strong&gt;，以产生不可理解的密文&lt;/li&gt;
&lt;li&gt;密钥 Secret key 密钥也是加密算法的输入，&lt;strong&gt;独立于&lt;/strong&gt;明文和算法，算法根据所用的特定密钥而产生不同的输出，算法所进行的各种代替和置换也依靠密钥。&lt;/li&gt;
&lt;li&gt;密文 Ciphertext 密文是加密算法的输出，直观看起来不可理解其代表的意识，依赖于&lt;strong&gt;明文&lt;/strong&gt;和&lt;strong&gt;密钥&lt;/strong&gt;，对于给定的相同的明文，不同的密钥将产生不同的密文。&lt;/li&gt;
&lt;li&gt;解密算法 Decryption algorithm 本质上是加密算法的逆运算，输入为密文和密钥，输出&lt;strong&gt;原始明文&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而对称密码对称的意思就是加密使用的密钥和解密使用的密钥是&lt;strong&gt;相同的&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://luo41.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="CANS" scheme="https://luo41.top/tags/CANS/"/>
    
    <category term="密码学" scheme="https://luo41.top/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>CIA and OSI SECURITY ARCHITECTURE</title>
    <link href="https://luo41.top/2021/07/24/CIA-and-OSI-SECURITY-ARCHITECTURE/"/>
    <id>https://luo41.top/2021/07/24/CIA-and-OSI-SECURITY-ARCHITECTURE/</id>
    <published>2021-07-24T13:18:52.000Z</published>
    <updated>2021-07-25T17:13:25.888Z</updated>
    
    <content type="html"><![CDATA[<p>写这篇文章的原因：考完试后经过半个月的补觉和躺平，本菜狗终于想起来<s>要学习了</s>(不是)，《密码编码学与网络安全》简称CANS之前其实看过一二章，然后再次看的时候，完全不记得以前看过了(淦)，算了算了重新开始看吧，写博客单纯记录自己学习的过程和尽量避免<strong>学完就忘</strong>(dalao们不要见笑，原谅我这个菜狗的水平hh)，如有错误，敬请指出！！！</p><span id="more"></span><h2 id="1-cia三元组和一些安全概念"><a class="markdownIt-Anchor" href="#1-cia三元组和一些安全概念"></a> 1 CIA三元组和一些安全概念</h2><blockquote><p>The cybersecurity definition introduces <strong>three key objectives</strong> that are <strong>the heart</strong> of information and network secutiry.</p></blockquote><p>大概就是说计算机安全定义了最核心的三个关键目标，如下：</p><ul><li><p><strong>Confidentiality 机密性</strong><br>又包括了两个方面：</p><ul><li><p>Data confidentiality 数据机密性 ，原书给的定义是：</p><blockquote><p>Assures that private or confidential information is not made available or disclosed to <strong>unauthorized</strong> individuals.</p></blockquote><p>意思大概就是说 <strong>数据机密性</strong>保证未经授权的个人不得获取或披露私人的或机密的信息。</p></li><li><p>Privacy 个人隐私：</p><blockquote><p>Privacy: assures that individuals control or influence what information related to them may be collected and stored and by whom and to whom that information may be disclosed</p></blockquote><p>意思大概就是说 保证个人控制或影响与他们相关的哪些信息是可能被收集和存储的，以及这些信息可能由谁或向谁公开。</p><p>举个例子，学生的分数信息在一些国家受到法律的保护，他们认为学生分数的机密性非常重要，学生分数仅仅能被学生自己，父母和需要这些信息完成工作的学校员工得到，这就需要保证学生分数的机密性，防止被<strong>未经授权的个人获取和泄露</strong>。</p></li></ul></li><li><p><strong>Integrity 完整性</strong><br>数据完整性防止对信息的不恰当修改或破坏，包括确保信息的不可否认性(nonrepudiation)和真实性(data authenticity)。</p><p><strong>不可否认性</strong>就是通过某种机制，防止发送方或接收方否认传输或接收过某条信息。发送方有<strong>信息已经送达的证明</strong>(接收方你不能否认你没收到信息~)，而接收方有信息<strong>发送方的身份证明</strong>(发送方你不能否认你发过了该信息，因为该信息有你的身份证明)。</p><p>而<strong>真实性</strong>(这里指的是信息的真实性，与后面实体的真实性还有所区别)：保证信息是真实的，不是虚假的，就是信息就是如同信息所说的那样。(比如说信息写着某某病人对什么食物过敏，那这个病人就是真的对该食物过敏)</p><blockquote><p>Data authenticity also means that a digital object is indeed <strong>what it claims to be</strong> or what it is claimed to be.</p></blockquote></li></ul><p>完整性的例子：医院的数据库存储着病人的过敏信息，在保证<strong>完整性</strong>的前提下，医生能够信任这些信息是<strong>正确的</strong>和<strong>最新的</strong>。现假设一个护士对该信息进行了不恰当的修改，或者一个黑客对该数据库进行破坏，插入了虚假的信息，在完整性机制的保证下，数据库需要<strong>快速恢复到可以信赖</strong>的状态，保证数据库存储的信息是<strong>正确的</strong>，<strong>值得信赖的</strong>。</p><ul><li><strong>Availability</strong> 可用性 确保系统工作的及时性和不对授权用户拒绝服务</li></ul><blockquote><p>Availability assures that systems <strong>work promptly</strong> and service is <strong>not denied to authorized user.</strong></p></blockquote><p>可用性的例子就比较多了，比如一台服务器瘫痪了导致用户不能访问计算机资源，比如上面那个数据库的例子，该数据库所在的服务器瘫痪了，医生无法访问数据库可能会造成一定的麻烦，所以服务器要保证可用性。</p><p>这就是CIA三元组，CIA三元组对于安全目标的定义已经比较清晰和全面了，但有时候还需要一些补充的安全概念，呈现更完整的安全定义，如：</p><ul><li><p>Authenticity 真实性 书里写的是(being genuine,being able to be verified and trusted) 大概就是说安全主体是真实的，可验证的，可信赖的。对传输信息来说，就是要保证<strong>信息</strong>和<strong>信息源</strong>是正确的，信息源是正确的，我的理解是，也就是能验证说 <strong>用户(信息源)就是他声称的那个人</strong>。比如有个人跟你说他是张三~，嗯你把他身份证拿来一看，哦<strong>确实是张三</strong>，他没欺骗你(这里排除拿假身份证的情况)。还有就是系统的每个输入是否均来自可信任的信源。信息是正确的就是上面的data Authenticity。</p></li><li><p>Accountability 可追溯性 这一安全概念要求<strong>实体的行为可以唯一性地追溯到该实体</strong>，该属性支撑事后恢复以及后续的如法律诉讼等。</p><img src="/2021/07/24/CIA-and-OSI-SECURITY-ARCHITECTURE/1.jpg" style="zoom: 25%;"></li></ul><h2 id="2-the-osi-security-architecture"><a class="markdownIt-Anchor" href="#2-the-osi-security-architecture"></a> 2 THE OSI SECURITY ARCHITECTURE</h2><p>为了有效地评价安全需求，以及对各种安全的产品和政策进行评价和选择，OSI安全架构给出了一种系统的定义方法。</p><p>OSI安全架构主要关注安全攻击，安全机制和安全服务，简短地定义如下</p><ul><li><p>安全攻击：可以简单地理解<strong>任何危机信息系统安全的行为</strong></p><blockquote><p>Security attack: Any action that compromises the security of information owned by an organization.</p></blockquote></li><li><p>安全机制 用来<strong>检测</strong>，<strong>阻止</strong>攻击和从被攻击状态<strong>恢复到正常状态</strong>的过程(或实现该过程的设备)</p><blockquote><p>Security mechanism: A process(or a device incorporating such a process) that designed to <strong>detect</strong>, <strong>prevent</strong>, or <strong>recover</strong> from a security attack</p></blockquote></li><li><p>安全服务 <strong>加强数据处理系统</strong>和<strong>信息传输的安全性</strong>的一种处理过程或通信服务，目的在于<strong>利用一种或多种安全机制对安全攻击进行反攻击</strong>。</p><p>安全攻击，安全机制和安全攻击一些类型如下图：</p></li></ul><img src="/2021/07/24/CIA-and-OSI-SECURITY-ARCHITECTURE/2.jpg" style="zoom: 50%;"><h3 id="21-threat-and-attack"><a class="markdownIt-Anchor" href="#21-threat-and-attack"></a> 2.1 Threat and Attack</h3><ul><li>威胁：破坏安全的<strong>潜在</strong>(potential)可能，在环境，行为事件允许的情况下，会破坏安全。</li><li>攻击: 对系统安全的攻击，有意违反安全服务和侵犯系统安全策略的<strong>恶毒(malicious)行为</strong>。</li></ul><h3 id="22-security-attack"><a class="markdownIt-Anchor" href="#22-security-attack"></a> 2.2 Security Attack</h3><p>安全攻击分为被动攻击(Passive Attack)和主动攻击(Active Attack)。</p><p>被动攻击试图<strong>获取或利用</strong>系统的信息但<strong>不影响系统资源</strong>。</p><blockquote><p>A passive attack attempts to <strong>learn or make use of information</strong> from system <strong>but does not affect system resources</strong>.</p></blockquote><p>而主动攻击试图去改变系统资源或影响系统运行。</p><blockquote><p>An active attack attempts to alter system resources or affect their operation.</p></blockquote><h4 id="221-passive-attack"><a class="markdownIt-Anchor" href="#221-passive-attack"></a> 2.2.1 Passive Attack</h4><p>被动攻击的本质是对传输进行<strong>窃听(eavesdropping)<strong>和</strong>监测(monitoring)</strong>。攻击者的目的是获得传输的信息。<strong>信息内容的泄露</strong>和<strong>流量分析</strong>都属于被动攻击。</p><ul><li><p><strong>The release of message content 信息内容的泄露</strong> 比如说你打电话，电子邮件消息和传输的文件，开腾讯会议会议内容都可能含有敏感的机密的信息，我们需要防止这些传输内容的泄露。</p></li><li><p><strong>Traffic analysis 流量分析</strong> 假设我们已经使用方法隐藏了消息内容，比如对传输的消息进行加密(encrtption)，这样攻击者即使截获了消息也无法从消息中<strong>直接</strong>获得信息。但是攻击者依然可以观察到这些消息的一些模式，比如传输消息的频率和长度，通信主机的身份和位置。利用这些信息攻击者可以来判断通信中的某些性质。书中原文：</p><blockquote><p>If we had encryption protection in place,an opponent might <strong>still</strong> be able to <strong>observe the pattern of these messages</strong>. The opponent could determine the <strong>location and identity of communicatio hosts</strong> and could observe <strong>the frequency and length of messages</strong> being exchanged.</p></blockquote></li></ul><p>被动攻击由于并不修改数据，所以信息流正常的发送和送达，双方都没有意识到有第三方正在获取和观察流量模型，因此很难去察觉到。</p><blockquote><p>The message traffic is sent and received in an apparently normal fashion and <strong>neither the sender nor receiver is aware that a third party has read the message or observed the traffic pattern</strong>.</p></blockquote><p>因此对于被动攻击，重点在于<strong>预防</strong>，而不是检测。</p><h4 id="222-active-attack"><a class="markdownIt-Anchor" href="#222-active-attack"></a> 2.2.2 Active Attack</h4><p>主动攻击包括对数据流进行修改(<strong>modification</strong>)或伪造数据量(the creation of a <strong>false</strong> stream)。具体分为四类：<strong>replay</strong>,<strong>masquerade</strong>,<strong>modification of messages</strong>，<strong>denial of service</strong></p><ol><li><strong>masquerade</strong> 伪装是指实体假装成其他实体，违背了前面提到的<strong>真实性(Authenticity)</strong>(那个人拿着张三的身份证，但其实他不是张三)，无权限的实体可以通过伪装成有权限的实体来获得<strong>权力</strong>，然后进行其他的操作，比如修改数据(modification of messages)，所以伪装攻击通常还包含其他形式的主动攻击。</li><li><strong>replay</strong>: 重放包括对数据单元的捕获(<strong>被动攻击</strong>)和对捕获后的数据单元进行重传，以<strong>获得未经授权的效果</strong>。我的理解是A给B发送数据，但C没有权限给B发送数据，然后C把A发送给B的数据捕获了，然后可能进行一些自己想要的修改，再重放给B，B此时依旧认为是A给他发送的数据，C就达到了给B发送数据的目的(该行为本是未被授权的)。</li><li><strong>modification  of messages</strong> 消息修改指的是<strong>未经授权地修改合法消息的一部分</strong>，或者是<strong>延迟消息的传输</strong>，<strong>改变消息的顺序</strong>。比如说原来的消息是&quot;luo is vegetable dog&quot;(luo是菜狗)，被修改为&quot;luo is not vegetable dog&quot;(luo不是菜狗)。再比如说&quot;Allow <strong>John</strong> to read confidential file accounts&quot;修改为&quot;Allow <strong>Fred Brown</strong> to read confidential file accounts&quot;。从而带来一些麻烦，比如说luo是菜狗居然变成了luo不是菜狗，麻烦大了…</li><li><strong>denial of service</strong> 拒绝服务破坏了可用性(availability)，这种攻击可能针对的是具体的目标，比如某个服务器拒绝提供服务，另一种形式是破坏了整个网络，使网络失效。</li></ol><p>主动攻击难以做到绝对的预防，所以对于主动攻击，重点在于<strong>检测并从攻击造成的破坏或延迟中恢复回来</strong>。</p><p>下图说明了在CS机制交互过程中，各种攻击是如何实现的。</p><img src="/2021/07/24/CIA-and-OSI-SECURITY-ARCHITECTURE/0.jpg" style="zoom: 50%;"><p>如(b)图机制适用于被动攻击，包括窃听和流量分析，在Client和Server正常通信的过程中，Attacker窃听和检测该过程，实现被动攻击。其他也是类似</p><h3 id="23-security-services"><a class="markdownIt-Anchor" href="#23-security-services"></a> 2.3 SECURITY SERVICES</h3><blockquote><p>A security service is a capability that <strong>supports one or more of the seurity requirements</strong>(confidentiality,integrity,availability,authenticity,and accountability).</p><p>Security services implement security policies and are implemented by <strong>security mechanisms</strong></p></blockquote><p>我的简单理解是 安全服务支持一个或多个安全需求的功能(就是前面说的机密性，完整性，可用性，真实性和可追溯性)。</p><p>安全服务实现安全策略，并由安全机制去实现安全服务。</p><p>一些比较重要的安全服务包括认证，访问控制，数据保密性，数据完整性和不可否认性。</p><ol><li><p>Authentication 认证服务<br>认证服务用来保证通信的真实性(<strong>authentic</strong>)。对于单条信息而言，认证服务功能向接收方<strong>保证消息确实来自其所声称的发送方</strong>。对于正在进行的通信，比如终端和主机连接，在初始化的时候，<strong>认证服务保证两个实体都是可信的</strong>，也就是前面说的每个实体都是他们所声称的实体(What is claim to be)，其次，<strong>认证服务保证该连接不受第三方的干扰</strong>(干扰指的是第三方能够伪装成两个合法实体中的一个进行非授权的传输或接收)</p><p>两个特殊的认证服务</p><ul><li>Peer entity authentication 对等实体认证</li><li>Data origin authentication 数据源认证 为数据的来源提供确认。</li></ul></li><li><p>Access Control 访问控制<br>访问控制是<strong>限制和控制</strong>那些通过通信连接对主机和应用进行访问 的一种能力，为此，<strong>每个试图获得访问控制的实体必须被识别或认证后，才能获得相应的访问权限</strong>。保证的是<strong>真实性</strong>。</p></li><li><p>Data Confidentiality 数据机密性</p></li></ol><p>​     数据机密性服务保证数据机密性，主要是防止传输的数据遭到被动攻击，造成私人信息和机密信息的泄露。</p><ol start="4"><li><p>Data Integrity 数据完整性<br>数据完整性服务保证数据的完整性。简单地理解，如果是在通信中，就是保证<strong>收到的消息和发出的消息是一致的</strong>。如果是上面提到的数据库系统的数据完整性的话，就要保证数据库的信息是<strong>正确的</strong>且<strong>可以信赖的</strong>，对于非法修改做出反应和及时恢复(恢复就要用到一些机制)。</p></li><li><p>Nonrepudiation 不可否认性</p><p>不可否认性服务保证不可否认性。 <strong>防止发送方和接收方否认传输或接收过某条信息</strong>。</p><blockquote><p>发送方有<strong>信息已经送达的证明</strong>(接收方你不能否认你没收到信息~)，而接收方有信息<strong>发送方的身份证明</strong>(发送方你不能否认你发过了该信息，因为该信息有你的身份证明)。</p></blockquote></li><li><p>Availability Service 可用性服务</p><p>保证可用性…处理由拒绝服务攻击引起的安全问题，依赖于对系统资源的合适管理和控制，同时还需要其他的安全服务配合，比如认证(以防止未授权的坏人破坏系统资源从而破坏可用性)。<br>系统是可用的当系统资源可被授权实体请求访问或使用。</p></li></ol><h3 id="24-security-mechanisms"><a class="markdownIt-Anchor" href="#24-security-mechanisms"></a> 2.4 SECURITY MECHANISMS</h3><p>…书里这里说本书会到处覆盖安全机制，暂时不多说，只是简单罗列，好吧…后面看到再说</p><ul><li><p>Cryptographic algorithms 加密算法 运用数学算法将数据转换为<strong>不可知</strong>的形式，再通过密钥等方法还原。分为<strong>可逆加密算法</strong>和<strong>不可逆加密算法</strong>。</p></li><li><p>Data integrity 数据完整性  怎么又是它，嗯其实差不多意思，就是用以保证数据完整性的各种机制</p></li><li><p>Digital signature 数字签名 附加在数据单元之后的一种数据，是对数据单元的密码变化，使得接收方可以证明数据源和数据完整性，防止<strong>伪造</strong></p></li><li><p>Traffic padding 流量填充 在数据流空隙中填充若干位，以防止<strong>流量分析</strong>，改变了数据流的模式(pattern)。</p></li><li><p>Routing control 路由控制 能够为某些数据选择特殊的物理上安全的路线。</p></li><li><p>Notarization 公证 利用可信的第三方来保证数据交换的某些性质</p></li><li><p>Access control  跟上同，只不过这里是机制。</p></li></ul><p>参考资料 《密码编码学与网络安全》----原理与实践(第八版)</p><p><strong>vegetable dog-------&gt;me</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;写这篇文章的原因：考完试后经过半个月的补觉和躺平，本菜狗终于想起来&lt;s&gt;要学习了&lt;/s&gt;(不是)，《密码编码学与网络安全》简称CANS之前其实看过一二章，然后再次看的时候，完全不记得以前看过了(淦)，算了算了重新开始看吧，写博客单纯记录自己学习的过程和尽量避免&lt;strong&gt;学完就忘&lt;/strong&gt;(dalao们不要见笑，原谅我这个菜狗的水平hh)，如有错误，敬请指出！！！&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://luo41.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="CANS" scheme="https://luo41.top/tags/CANS/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络运输层</title>
    <link href="https://luo41.top/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    <id>https://luo41.top/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/</id>
    <published>2021-06-18T07:16:59.000Z</published>
    <updated>2021-06-19T01:24:17.438Z</updated>
    
    <content type="html"><![CDATA[<p>本文巨长且干货极少，<strong>阅读请谨慎</strong>！！！！</p><h2 id="1-运输层协议概述"><a class="markdownIt-Anchor" href="#1-运输层协议概述"></a> 1 运输层协议概述</h2><h3 id="11-为什么需要运输层"><a class="markdownIt-Anchor" href="#11-为什么需要运输层"></a> 1.1 为什么需要运输层？</h3><p>和之前介绍的层次一样，在开始之前，我们需要<strong>先知道为什么需要运输层</strong>？</p><p>我们知道现代操作系统，都是支持&quot;多任务&quot;的操作系统。“多任务&quot;简单的说就是操作系统可以同时运行多个任务，比如你可以一边在用浏览器上网，一边打开网易云听歌，一边用Word赶作业。</p><p>那么操作系统如何实现这种”多任务“呢？答案就是操作系统轮流让各个任务交替执行,但是因为CPU太快了，给我们的感受就是所有任务都在同时执行。对于操作系统而言，一个任务就是一个<strong>进程(Process)</strong>,</p><p>这里提到<strong>进程</strong>，我们知道，计算机网络体系结构中的<strong>物理层</strong>，<strong>数据链路层</strong>以及<strong>网络层</strong>它们要解决的问题是在网络互联的情况下，如何<strong>实现主机到主机的通信</strong>。</p><p>然而，真正在计算机网络中进行的通信是<strong>位于通信两端主机中的进程</strong>之间的通信，是一台主机中的<strong>一个进程</strong>和另一台主机中的<strong>另一个进程</strong>在交换数据(也就是通信)。</p><span id="more"></span><p>IP协议能把分组送到目的主机，但是这个分组只是停留在目的主机的网络层而不知道交付给主机中的哪一个进程，而运输层就是来解决<strong>交付给哪个进程的问题</strong>。</p><p>从运输层的角度看：</p><blockquote><p><strong>通信的真正端点并不是主机而是主机中的进程</strong>。</p></blockquote><p>比如说在一台主机上经常有多个进程<strong>同时分别</strong>和另一台主机上的多个进程通信。例如，你在使用浏览器查找某网站的信息时，你的主机应用层运行浏览器客户进程。如果你在浏览网页的同时，还使用了电子邮件给网站发送反馈意见，那么你的主机的应用层还要运行电子邮件的客户进程。</p><h3 id="12-运输层的一些功能"><a class="markdownIt-Anchor" href="#12-运输层的一些功能"></a> 1.2 运输层的一些功能</h3><h4 id="121-复用和分用"><a class="markdownIt-Anchor" href="#121-复用和分用"></a> 1.2.1 复用和分用</h4><p>如图5-1 主机A的应用进程AP1和主机B的应用进程AP3通信，<strong>与此同时</strong>，主机A应用进程AP2也和对方的应用进程AP4通信。比如说你和朋友在微信聊天，这时突然你要传输一个大文件给朋友，微信实现不了，所以你打开了QQ向朋友传大文件，QQ传输文件的同时，你继续和朋友聊天。</p><p>这表明了运输层有很重要的功能<strong>复用(multiplexing)<strong>和</strong>分用(demultiplexing)</strong>。</p><ul><li><p><strong>复用</strong>指发送方<strong>不同的应用进程</strong>都可以使用<strong>同一个运输协议</strong>传送数据。</p></li><li><p><strong>分用</strong>指接收方的运输层在剥去报文的首部后<strong>能够把这些数据正确交付目的应用进程</strong>。</p><img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_1.jpg" style="zoom: 25%;"></li></ul><h4 id="122-运输层提供应用进程间的逻辑通信"><a class="markdownIt-Anchor" href="#122-运输层提供应用进程间的逻辑通信"></a> 1.2.2 运输层提供应用进程间的逻辑通信</h4><blockquote><p>运输层提供应用进程间的<strong>逻辑通信</strong></p></blockquote><p><strong>逻辑通信</strong>的意思是：从应用层来看，只要把应用层的报文交给下面的<strong>运输层</strong>，运输层就可以把这报文传送到对方的运输层(应用层根本不管对方有多远，报文怎么发过去的，下层协议怎么实现的，就只是告诉运输层，你帮我把报文送到某某的运输层，本机运输层就一定可以将报文送到)，就好像这种通信就是<strong>沿着水平方向直接传送数据</strong>，但事实上我们知道，<strong>两个运输层之间根本不存在这样一条水平方向的物理链路</strong>，报文的传送还是要沿着图中的虚线方向经过多个层次才能传送到目的主机的运输层。</p><p>逻辑通信的意思是”好像是这样通信，事实上并非如此“。</p><p>这里就可以看出网络层和运输层的区别了：</p><blockquote><p>网络层为<strong>主机</strong>之间提供了逻辑通信，而运输层为应用<strong>进程</strong>之间提供端到端的逻辑通信。</p></blockquote><p>如图5-2：</p><img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_2.jpg" style="zoom: 25%;"><h4 id="123-提供可靠和不可靠两种信道"><a class="markdownIt-Anchor" href="#123-提供可靠和不可靠两种信道"></a> 1.2.3 提供可靠和不可靠两种信道</h4><p>我们知道，数据链路层提供的是<strong>无差错传输</strong>，不是<strong>可靠运输</strong>，网络层IP数据报首部中的检验和字段，只检验首部是否出现差错而不检查数据部分。</p><p>根据应用程序的不同需求，运输层可以使用两种不同的运输协议，即<strong>面向连接的TCP</strong> 和 <strong>无连接的UDP</strong>。 当运输层采用<strong>面向连接的TCP</strong>协议时，尽管下面的网络是不可靠的，但这种逻辑通信信道就相当于<strong>一条全双工的可靠信道</strong>。但当运输层采用<strong>无连接的UDP协议</strong>时，这种逻辑通信信道就仍然是<strong>不可靠信道</strong>。</p><h3 id="13-运输层的两个主要协议"><a class="markdownIt-Anchor" href="#13-运输层的两个主要协议"></a> 1.3 运输层的两个主要协议</h3><p>**(1)用户数据报协议UDP **: User Datagram Protocol</p><p><strong>(2)传输控制协议TCP</strong>:  Transmission Control Protocol</p><p>图5-3给出了这两种协议在协议栈的位置</p><img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_3.jpg" style="zoom: 25%;"><p>在TCP/IP体系中，根据所使用的协议是TCP或UDP，分别称两个对等运输实体在通信时<strong>传送的数据单位</strong>为<strong>TCP报文段(segment)<strong>或</strong>UDP用户数据报</strong>。</p><p>UDP在传送数据之前<strong>不需要先建立连接</strong>，目的主机的运输层收到UDP报文后，<strong>不需要给出任何确认</strong>。虽然UDP不提供可靠服务，但在某些应用下，UDP是非常有效的工作方式，因为UDP比较快，效率高。比如说<strong>视频通信</strong>，在通信中，一些视频帧的丢失我们是可以接受的，但我们要保证的是通信的流畅度和延迟低。</p><p>TCP则提供<strong>面向连接的服务</strong>，在传送数据之<strong>前先建立连接</strong>，数据传送<strong>结束后要释放连接</strong>。<strong>TCP不提供广播或多播服务</strong>。正因为TCP要提供<strong>可靠的</strong>，<strong>面向连接</strong>的运输服务，因此不可避免地增加了许多的开销。</p><p>表5-1 给出了一些应用和应用层协议主要使用的运输层协议</p><img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_4.jpg" style="zoom: 20%;"><h3 id="14-运输层的端口"><a class="markdownIt-Anchor" href="#14-运输层的端口"></a> 1.4 运输层的端口</h3><h4 id="141-什么是端口"><a class="markdownIt-Anchor" href="#141-什么是端口"></a> 1.4.1 什么是端口？</h4><p>前面我们提到了<strong>复用</strong>和<strong>分用</strong>：</p><blockquote><ul><li><p><strong>复用</strong>指发送方<strong>不同的应用进程</strong>都可以使用<strong>同一个运输协议</strong>传送数据。</p></li><li><p><strong>分用</strong>指接收方的运输层在剥去报文的首部后<strong>能够把这些数据正确交付目的应用进程</strong>。</p></li></ul></blockquote><p>举一个日常生活中复用和分用的简单的例子，假定一个学校向其他学校发出的信都由该学校的收发室负责寄出，这相当学校里的每个院系都要<strong>复用</strong>这个收发室，而当学校收发室收到信后，根据信的收件地址，将信具体送给对应的院系，这叫是<strong>分用</strong>。</p><p>运输层上的复用和分用功能也是类似的。应用层所有的应用进程都可以通过运输层再传送到网络层，这就是<strong>复用</strong>，运输层就相当于<strong>收发室</strong>，而运输层收到IP层发送给各应用的数据后，必须分别交付指明的各应用进程，这就是<strong>分用</strong>。那么运输层如何找到对应的各应用进程呢？答案是<strong>给应用层的每个应用进程赋予一个非常明确的标志</strong>。</p><p>我们知道，在单个计算机中的进程我们是用<strong>进程标识符</strong>来标志的。然而不同的操作系统使用的进程标识符格式是不同的，为了使运行不同的操作系统的计算机的应用进程能够实现通信，需要用一种<strong>统一的方法来标识进程</strong>，而这种方法与特定操作系统必须无关。</p><p>但是，把一个特定机器上运行的特定进程，指明为互联网通信上的最后终点还是<strong>不可行</strong>的，因为我们知道，进程的创建和撤销是<strong>动态的</strong>，新建一个进程就会给出一个新的进程号，通信的一方几乎无法识别对方机器上的进程，我们往往需要利用目的主机提供的功能来识别终点，而不需要知道具体实现这个功能的进程是哪一个。</p><p>解决问题的方法就是在<strong>运输层使用协议端口号(protocol port number)</strong>，也通常成为<strong>端口(port)</strong>。也就是说，我们不直接把目的主机上的某个进程作为终点(事实上也无法这样做，因为源主机无法识别进程)，而只要将所传送的报文送到目的主机上<strong>某个合适的端口</strong>，至于最后交付给目的进程，就由TCP或UDP来实现。</p><p>注意<strong>软件端口和硬件端口的区别</strong>：</p><blockquote><p>在这种<strong>协议栈层间的抽象的协议端口</strong>是<strong>软件端口</strong>。而在路由器或交换机上的<strong>硬件端口</strong>是不同硬件设备之间的接口。<strong>软件端口</strong>相当于是应用层的各种协议进程与运输实体进行层间交互的一种<strong>地址</strong>。</p></blockquote><h4 id="142-端口的工作原理"><a class="markdownIt-Anchor" href="#142-端口的工作原理"></a> 1.4.2 端口的工作原理</h4><p>当运输层收到IP层交上来的运输层报文时，就可以根据其首部中的<strong>目的端口号</strong>把数据交付应用层中的<strong>目的应用进程</strong>。</p><p>TCP/IP 的运输层用一个<strong>16位端口号</strong>来标志一个端口，注意的是：<strong>端口号只具有本地意义</strong>，它只是为了标志<strong>本计算机</strong>应用层中各个进程在和运输层交互的一个接口。在不同的计算机中，相同的端口号是<strong>没有关联的</strong>。</p><p>由此可见，两个计算机中的进程要互相通信，不仅仅必须知道目的主机的IP地址(<strong>网络层以下的层需要依靠IP地址找到目的主机</strong>)，而且要知道对方的<strong>端口号</strong>(运输层要依据端口号找到目的主机中的应用进程)。</p><p>举一个寄信的例子，我们给某人写信，必须写上他的住所地址(为了找到他的家庭地址，<strong>相当于IP地址</strong>)，还要写上收件人的名字(相当于<strong>端口号</strong>)，因为一个住所可能有多个人住，只有写上收件人的姓名，才知道把信给谁。</p><h4 id="143-运输层端口的分类"><a class="markdownIt-Anchor" href="#143-运输层端口的分类"></a> 1.4.3 运输层端口的分类</h4><p>运输层的端口号分为下面的两大类。</p><p><strong>(1) 服务器端使用的端口号</strong>：服务器使用的端口号又分为两类，分别是：</p><ul><li><strong>熟知端口号</strong>或<strong>系统端口号</strong>： 数值为0~1023，LANA把这些端口号指派给了TCP/IP最重要的一些应用程序，让所有用户都知道。如表5-2：</li><li><strong>登记端口号</strong>：数值为1024~49151 为没有熟知端口号的应用程序使用的，需防止重复。</li></ul><p><strong>(2)</strong> <strong>客户端使用的端口号</strong>：数值为49152~65535。这类端口号仅在用户进程运行时才<strong>动态选择</strong>，又叫做<strong>短暂端口号</strong>。这类端口号留给客户进程选择<strong>暂时使用</strong>，通信结束后，这个端口号就可以供其他客户进程使用。</p><img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_5.jpg" style="zoom: 20%;"><h2 id="2-用户数据报协议udp"><a class="markdownIt-Anchor" href="#2-用户数据报协议udp"></a> 2 用户数据报协议UDP</h2><h3 id="21-udp-概述"><a class="markdownIt-Anchor" href="#21-udp-概述"></a> 2.1 UDP 概述</h3><p><strong>UDP</strong>的主要特点是：</p><p>(1) UDP是<strong>无连接</strong>的 发送数据之前不需要建立连接，当然结束时也不需要释放连接。</p><p>(2) UDP使用<strong>尽最大努力交付</strong>，同样是<strong>不可靠交付</strong>。</p><p>(3) UDP是<strong>面向报文</strong>的。发送方的UDP对应用程序交下来的报文，在<strong>添加首部后就向下交付IP层</strong>。UDP对应用层交下来的报文，<strong>不合并，也不拆分</strong>，<strong>保留这些报文的边界</strong>。也就是说，应用层交给UDP多长的报文，UDP照样发送，即一次发送一个报文。<br>如图5-4所示，接收方的UDP对IP层交上来的UDP用户数据报，在<strong>去除首部后就原封不动地交付上层</strong>的应用进程，也就是说，UDP一次交付一个完整的报文。<br>这就要求应用程序必须选择<strong>合适大小的报文</strong>，如果报文太长，IP层在传送时可能要进行分片，这降低了IP层的效率，如果太短，IP数据报的首部的相对长度太大，这也降低了IP层的效率。</p><img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_6.jpg" style="zoom: 20%;"><p>(4) UDP<strong>没有拥塞控制</strong>：网络中出现的拥塞不会使源主机的发送速率降低。对于很多实时应用比如IP电话，实时视频会议要求源主机以恒定的速率发送数据，并且允许在网络发生拥塞时丢失一些数据，但不能有太大的时延，UDP是非常适合的。但这样也有可能引起网络产生严重的拥塞问题。</p><p>(5) UDP支持<strong>一对一，一对多，多对一和多对多的交互通信</strong>。</p><p>(6) UDP的<strong>首部开销小</strong>，只有8个字节。</p><h3 id="22-udp的首部格式"><a class="markdownIt-Anchor" href="#22-udp的首部格式"></a> 2.2 UDP的首部格式</h3><p>如图5-5，用户数据报UDP有两个字段：<strong>数据字段</strong>和<strong>首部字段</strong>。首部字段很简单，只有8个字节，由<strong>四个字段</strong>组成，<strong>每个字段的长度都是两个字节</strong>，各字段的意义如下：</p><ul><li><strong>源端口</strong>：源端口号，在需要对方回信时选用，不需要可用全0</li><li><strong>目的端口</strong>：目的端口号，这在终点交付报文时必须使用。</li><li><strong>长度</strong> UDP用户数据报的长度，最小值为8(<strong>仅有首部</strong>的情况)</li><li><strong>检验和</strong>： 检测UDP用户数据报在传输中是否有错，有错就丢弃。</li></ul><img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_7.jpg" style="zoom: 20%;"><p>当运输层从IP层收到UDP数据报时，就根据数据报中的<strong>目的端口</strong>，把UDP数据报通过相应的端口，上交到目的应用进程，如图5-6：</p><img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_8.jpg" style="zoom: 20%;"><p>如果接收方UDP发现收到的报文的<strong>目的端口不正确</strong>，也就是不存在对应于该端口号的应用进程，就丢弃该报文，并由网际控制报文协议ICMP发送&quot;<strong>端口不可达</strong>&quot;差错报文给发送方。比如我们熟悉的traceroute实现原理就是发送一个不可交付的UDP报文，该报文故意使用一个非法的<strong>UDP端口</strong>，结果ICMP就返回<strong>端口不可达</strong>差错报文，达到跟踪路径的目的。</p><p>UDP用户数据报首部检验和的计算：</p><p>UDP用户数据报首部中计算检验和时，要在UDP用户数据报之前添加<strong>12字节的伪首部</strong>。所谓“伪首部”并<strong>不是</strong>UDP用户数据报<strong>真正的首部</strong>，只是在计算检验和时临时添加到UDP用户数据包前面，得到一个<strong>临时的UDP数据报</strong>，再根据这个数据报去<strong>计算检验和</strong>，伪首部仅仅是为了计算检验和。</p><p>UDP计算校验和的方法和计算IP数据报首部检验和的方法相似，不同的是IP数据报的检验和<strong>只检验IP数据报的首部</strong>，而UDP的检验和是<strong>把首部和数据部分一起都检验</strong>。</p><p>具体的检验方法是：</p><p>在发送方，先将检验和字段置为全0，再把伪首部已经UDP用户数据报看成是由许多16位的字串连接起来的。如果UDP用户数据报的数据部分<strong>不是偶数个字节</strong>，则要填入一个全0字节。(注意，此字节不发送，只是为了求检验和)，然后按<strong>二进制反码计算出这些16位字的和</strong>，将<strong>和</strong>的<strong>二进制反码</strong>写入检验和字段后，就发送UDP用户数据报。</p><p>在接收方，把收到的UDP用户数据报连通伪首部(以及可能的填充全0字节)一起，按二进制反码求这些16位字的和，当无差错时其结果应为全1(求反码时为全0)，否则就表明有差错出现。</p><p>接收方一遇到差错，就丢弃这个UDP用户数据报(也可以上交应用层，但附上出现了差错的警告)。</p><p>如图5-7给出了一个<strong>计算UDP检验和的例子</strong>：</p><img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_9.jpg" style="zoom: 20%;"><h2 id="3-传输控制协议tcp概述"><a class="markdownIt-Anchor" href="#3-传输控制协议tcp概述"></a> 3 传输控制协议TCP概述</h2><p>好复杂的协议，头大…算了算了一步步学吧~</p><h3 id="31-tcp最主要的特点"><a class="markdownIt-Anchor" href="#31-tcp最主要的特点"></a> 3.1 TCP最主要的特点</h3><ol><li><p>TCP是<strong>面向连接的运输层协议</strong>：应用程序在使用TCP协议之前，必须先建立TCP连接，传送数据完毕后，必须释放已经建立的TCP连接。</p></li><li><p>每一条TCP连接只能有两个<strong>端点(endpoint)</strong>。每一条TCP连接只能是<strong>点对点</strong>的。</p></li><li><p>TCP提供<strong>可靠交付</strong>的服务。通过TCP连接传送的数据，<strong>无差错</strong>，<strong>不丢失</strong>，<strong>不重复</strong>，<strong>并且按序到达</strong>。</p></li><li><p>TCP提供<strong>全双工通信</strong>。TCP允许通信双方的<strong>应用进程在任何时候都能发送数据</strong>，TCP连接的两端都设有<strong>发送缓存</strong>和<strong>接收缓存</strong>，用来临时存放双向通信的数据。在发送时，应用程序在把数据传送给TCP的缓存后，就可以做自己的事，而<strong>TCP在合适的时候再把数据发送出去</strong>。在接收时，TCP把收到的数据放入缓存，上层的应用进程在合适的时候读取缓存中的数据。</p></li><li><p><strong>面向字节流</strong> UDP是面向报文，而TCP是面向字节流的。<strong>流(stream)<strong>指的是</strong>流入到进程或从进程流出的字节序列</strong>。含义是：虽然应用程序和TCP的交互是一次一个数据块(大小不等)，但TCP把应用程序交付下来的数据<strong>仅仅</strong>看成一连串<strong>无结构的字节流</strong>。TCP并不知道传送的字节流的含义，也<strong>不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系</strong>。例如，发送方应用程序交给发送方TCP共10个数据块，接收方的TCP可能只用了4个数据块就把收到的字节流交付上层的应用程序，因为应用程序和TCP<strong>交互的数据块大小可以不等</strong>。但从<strong>字节流</strong>的角度来看，<strong>接收方收到的字节流必须和发送方发出的字节流是完全一样的</strong>，接收方有能力识别收到的字节流，把它还原成有意义的应用层数据，交付上层。</p><p>如图5-8 ：</p><img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_10.jpg" style="zoom: 33%;"></li></ol><p>从图5-8可以看出，TCP和UDP在发送报文时所采用的方式完全不同，TCP是面向<strong>字节流</strong>的，TCP并不关心应用进程一次把多长的报文发送到TCP缓存中，而是根据对方给出的<strong>窗口</strong>和当前网络拥塞的程度决定<strong>一个报文段应包含多少个字节</strong>，而UDP是<strong>面向报文的</strong>，只负责将从应用进程收到的报文添加首部后交付给IP层，所以UDP发送的报文长度是应用进程给出了。TCP可以<strong>灵活地控制报文的长度</strong>，如果TCP缓存的数据块太长，可以划分短一些再传送。如果太短，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。</p><h3 id="32-tcp的连接"><a class="markdownIt-Anchor" href="#32-tcp的连接"></a> 3.2 TCP的连接</h3><p>TCP把<strong>连接</strong>作为<strong>最基本的抽象</strong>。</p><p>前面提到，每一条TCP连接有两个<strong>端点</strong>。那么，<strong>TCP连接的端点</strong>是什么？不是主机，不是主机的IP地址，不是应用进程，也不是运输层的协议端口，而是<strong>套接字(socket)<strong>或</strong>插口</strong>。根据RFC793的定义：端口号<strong>拼接到(concatenated with)</strong> IP地址即构成了套接字。因此，套接字的表示方法是在点分十分制的IP地址后面写上端口号，中间用冒号或逗号隔开。例如，若IP地址是192.3.4.5而端口号是80，那么得到的套接字就是(192.3.4.5:80)。有：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">套</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">字</mi><mi>s</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi><mo>=</mo><mo stretchy="false">(</mo><mi>I</mi><mi>P</mi><mi mathvariant="normal">地</mi><mi mathvariant="normal">址</mi><mi mathvariant="normal">：</mi><mi mathvariant="normal">端</mi><mi mathvariant="normal">口</mi><mi mathvariant="normal">号</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">套接字socket=(IP地址：端口号)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord cjk_fallback">套</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">字</span><span class="mord mathdefault">s</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord cjk_fallback">地</span><span class="mord cjk_fallback">址</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">端</span><span class="mord cjk_fallback">口</span><span class="mord cjk_fallback">号</span><span class="mclose">)</span></span></span></span></span></p><p><strong>每一条TCP连接唯一地被通信两端的两个端点(即两个套接字)所确定</strong>。即：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>C</mi><mi>P</mi><mi mathvariant="normal">连</mi><mi mathvariant="normal">接</mi><mo>:</mo><mo>:</mo><mo>=</mo><mo stretchy="false">{</mo><mi>s</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>e</mi><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>s</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>e</mi><msub><mi>t</mi><mn>2</mn></msub><mo stretchy="false">}</mo><mo>=</mo><mo stretchy="false">{</mo><mo stretchy="false">(</mo><mi>I</mi><msub><mi>P</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>p</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>I</mi><msub><mi>P</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>p</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">TCP连接 ::= \{socket_1,socket_2\}=\{(IP_1,port_1),(IP_2,port_2)\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord cjk_fallback">连</span><span class="mord cjk_fallback">接</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">s</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">}</span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">IP_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">IP_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>分别为通信两个主机的IP地址，而<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">port_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>o</mi><mi>r</mi><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">port_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>分别是两个端点主机中的端口号。</p><p>再强调一遍，<strong>TCP连接的端点是个很抽象的套接字(即IP地址：端口号)</strong>。同时，同一个IP地址可以有多个不同的TCP连接，同一个端口号也可以出现在多个不同的TCP连接中。</p><h2 id="4-可靠传输的原理"><a class="markdownIt-Anchor" href="#4-可靠传输的原理"></a> 4 可靠传输的原理</h2><p>我们知道，TCP提供的是<strong>可靠传输</strong>，那么采用什么样的适当措施才能使得两个运输层之间的通信变得可靠？</p><p>首先<strong>理想的传输条件有以下两个特点</strong>：</p><ul><li>一 传输信道<strong>不出现差错</strong>。</li><li>二 不管发送方以多快的速度发送数据，接收方<strong>总是来得及处理</strong>收到的数据。</li></ul><p>在这样的理想传输条件下，不需要采取任何措施就能够实现<strong>可靠传输</strong>。然而实际的网络都不具备一下的两个条件，所以需要使用一些可靠传输协议，当出现差错时让发送方重传出现差错的数据(<strong>实现特点一</strong>)，同时在接收方来不及处理收到的数据时，及时告知发送方降低发送数据的速度(<strong>实现特点二</strong>)。实现了这两个特点，就实现了可靠传输。下面就是具体讲<strong>如何去达到这两个特点</strong>：</p><h3 id="41-停止等待协议"><a class="markdownIt-Anchor" href="#41-停止等待协议"></a> 4.1 停止等待协议</h3><p>运输层传送的协议的<strong>数据单元</strong>叫做<strong>报文段</strong>，网络层传送的协议数据单元叫做<strong>IP数据报</strong>。但下面为了讨论方便，把传送的数据单元都称为<strong>分组</strong>，而不考虑数据是在哪一个层次上传送的。</p><p><strong>停止等待</strong>就是每发完一个分组就停止发送，<strong>等待</strong>对方的<strong>确认</strong>，<strong>收到确认后再发送</strong>下一个分组。</p><h4 id="411-无差错情况"><a class="markdownIt-Anchor" href="#411-无差错情况"></a> 4.1.1 无差错情况</h4><p>停止等待协议可以用5-9来说明。图5-9(a)是传输分组中没有出现差错的情况。A发送完分组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,就暂停发送，等待B的确认。B收到了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>就向A确认。A收到了B对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的确认后，就继续发送下一个分组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">M_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,然后就暂停发送，收到B对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">M_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的确认后，再发送<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">M_{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_11.jpg" style="zoom: 33%;"><h4 id="412-出现差错"><a class="markdownIt-Anchor" href="#412-出现差错"></a> 4.1.2 出现差错</h4><p>图5-9(b)是分组在传输过程中出现差错的情况。B收到了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,但是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>检测出了差错，就丢弃<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,其他什么也不做(<strong>并不通知A收到有差错的分组</strong>)，另一种情况是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>在传输过程中丢失了，这时B什么也不知道。在这两种情况下，<strong>B都不会发任何消息</strong>。</p><p><strong>可靠传输</strong>是这样设计的：A只要超过了一段时间没有收到B的确认，就认为刚才发送的<strong>分组丢失</strong>了(有可能被接收到了，但出错了，A一律看成是丢失了)，因此A重传前面发送的分组，这就是<strong>超时重传</strong>。如何确定A要等待多长的时间才重传？我们在A每发送完一个分组时，设置一个<strong>超时计时器</strong>，如果在超时计时器到期之前收到了对方的确认，就<strong>撤销</strong>已经设置的超时计时器，如果超时计时器到期之前没有收到对方的确认，就重传分组。</p><p>这里需要注意的一些点是：</p><ul><li><strong>一</strong>，A在发送完一个分组后，<strong>必须暂时保留已发送的分组的副本</strong>，因为分组可能会丢失，需要重传，只有收到相应的分组确认后才可以清除分组的副本。</li><li><strong>二</strong>，分组和确认分组都必须进行<strong>编号</strong>，这样才能明确是哪一个发送出去的分组收到了确认，而哪一个分组还没有收到确认。</li><li><strong>三</strong>，超时计时器设置的重传时间<strong>应当比数据在分组传输的平均往返时间更长一些</strong>，以防止正常确认报文还未到达A，A就开始重传了，造成了不必要的重传。</li></ul><h4 id="413-确认丢失和确认迟到"><a class="markdownIt-Anchor" href="#413-确认丢失和确认迟到"></a> 4.1.3 确认丢失和确认迟到</h4><p>图5-10(a)说明的是另一种情况，A发送的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>分组顺利到达了B，且没有差错，B按协议向A发送一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>收到确认分组，但是该确认分组在传输的过程中丢失了，此时A并不知道<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是丢失了，还是出错了，还是B的确认报文丢失了，因此A在超时计时器到底后就重传<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,假设传输顺利，B此时又收到了一遍<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,这是B会采取两个行动：</p><ul><li><strong>一</strong> <strong>丢弃</strong>这个重复的分组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,不向上交付。</li><li><strong>二</strong> <strong>向A重新发送确认</strong>，因为A之所以重传就表示A没有收到对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的确认，所以需要再确认一遍。</li></ul><img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_12.jpg" style="zoom: 20%;"><p>图5-10(b)也是一种可能出现的情况。传输过程中没有出现差错，但B对分组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的确认迟到了。A会收到重复的确认。对重复的确认的处理很简单：<strong>收下了重复的确认分组就丢弃</strong>。在这过程中，B也会收到重复的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,但B会丢弃重复的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，但每次收到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>都<strong>重传确认分组</strong>。</p><p>这种可靠传输，A最终总是可以收到对所有发出的分组的确认，这样我们就可以<strong>在不可靠的传输网络上实现可靠的通信</strong>。</p><p>像上述的这种可靠传输协议常称为<strong>自动重传请求ARQ(Automatic Repeat reQuest)</strong>。意思是重传的请求是自动进行的，接收方不需要请求发送方重传某个出错的分组。(靠的是发送方自己设置的<strong>超时计时器</strong>)。</p><h4 id="414-信道利用率"><a class="markdownIt-Anchor" href="#414-信道利用率"></a> 4.1.4 信道利用率</h4><p><strong>停止等待协议</strong>的优点就是它的实现简单，但缺点是信道的利用率太低了。如图5-11，假定在A和B之间有一条直通的信道来传送分组。</p><img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_13.jpg" style="zoom: 33%;"><p>假定A发送分组需要的时间是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>D</mi></msub></mrow><annotation encoding="application/x-tex">T_{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>D</mi></msub></mrow><annotation encoding="application/x-tex">T_{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>等于分组长度除以数据传输速率。再假定分组正确到达B后，B处理分组的时间忽略不计，即时立即发回确认。假定B发送确认分组需要时间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">T_{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，如果A处理确认分组的时间也忽略不计，那么A在经过时间**(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>D</mi></msub></mrow><annotation encoding="application/x-tex">T_{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>+RTT+<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">T_{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><strong>)后才发送下一个分组。这里的</strong>RTT<strong>为</strong>往返时间**。因为仅仅有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>D</mi></msub></mrow><annotation encoding="application/x-tex">T_{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的时间用来传送有用的数据，因此信道利用率U为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mo>=</mo><msub><mi>T</mi><mi>D</mi></msub><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><msub><mi>T</mi><mi>D</mi></msub><mo>+</mo><mi>R</mi><mi>T</mi><mi>T</mi><mo>+</mo><msub><mi>T</mi><mi>A</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U=T_{D}/(T_{D}+RTT+T_{A})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>为了提高传输效率，发送方可以不使用<strong>低效率</strong>的停止等待协议，而是采用<strong>流水线传输</strong>。如图5-12，流水线传输就是发送方可以连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认，这样可以使得信道上一直有数据不间断地在传送。当使用流水线传输时，就需要使用<strong>连续ARQ协议</strong>和<strong>滑动窗口协议</strong>。</p><img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_14.jpg" style="zoom: 33%;"><h3 id="42-连续arq协议"><a class="markdownIt-Anchor" href="#42-连续arq协议"></a> 4.2 连续ARQ协议</h3><p>图5-13(a)表示发送方维持的<strong>发送窗口</strong>，它的意思是：位于发送窗口内的5个分组都可以连续发送出去，而不需要等待对方的确认，通过这种方式，<strong>信道利用率</strong>就提高了。</p><img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/29.jpg" style="zoom: 20%;"><p>如图5-13，分组发送是按照分组序号从小到大发送的。连续的ARQ协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。如图5-13(b)表示发送方收到了对第1个分组的确认，于是就把发送窗口向前移动一个分组。</p><p>接收方一般是采用<strong>累积确认</strong>的方式，也就是说，接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，<strong>对按序到达的最后一个分组发送确认</strong>，表明<strong>到这个分组为止的所有分组都已正确收到</strong>了。</p><p><strong>累积确认</strong>的优点是：即使<strong>确认丢失了也不必重传</strong>，信道利用率比停止等待协议要高。但缺点是不能向发送方反映出接收方已经正确收到的所有分组的信息。</p><p>举一个累积确认的例子，如果发送方发送了前5个分组，而中间的第3个分组丢失，这时接收方只能对前两个分组发出确认，而发送方没有收到后面三个分组的确认，只要重传后面三个分组。这也叫做<strong>Go-back-N</strong>（回退N)。</p><h2 id="5-tcp报文段的首部格式"><a class="markdownIt-Anchor" href="#5-tcp报文段的首部格式"></a> 5 TCP报文段的首部格式</h2><p>我们知道，TCP是面向字节流的，但TCP传送的数据单元是<strong>报文段</strong>。一个TCP报文段分为<strong>首部</strong>和<strong>数据</strong>两部分。</p><p>TCP报文段首部的<strong>前20个字节是固定的</strong>，后面有4n字节是根据需要而增加的选项(n为整数）。因此，<strong>TCP首部的最小长度是20字节</strong>。</p><img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_15.jpg" style="zoom: 33%;"><p>首部固定部分各字段的意义如下：</p><ol><li><p><strong>源端口</strong>和<strong>目的端口</strong>：一个端口16位，各占两个字节，分别写入源端口号和目的端口号。实现前面提到的<strong>分用</strong>功能。</p></li><li><p><strong>序号</strong> 占4个字节，序号范围是[0,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{32}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>]，共<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>(即4294967296)个序号。序号增加<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{32}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>后，下一个序号就又回到。也就是说，序号使用mod <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>运算。<br>我们说过，TCP是<strong>面向字节流</strong>的。在一个TCP连接中传送的字节流中的<strong>每一个字节</strong>都<strong>按顺序编号</strong>。整个要传送的字节流的起始序号需要在连接建立时设置。首部中的<strong>序号字段</strong>就是指<strong>本报文段</strong>所发送的数据的<strong>第一个字节的序号</strong>。比如说，一报文段的序号字段值是301，而携带的数据共有100个字节(表面该数据报有100个字节流那么长)，这就表明：本报文段的第一个字节的序号是301，最后一个字节的序号是400，所以下一个报文段的序号字段值为401。该字段也称<strong>报文段序号</strong>。</p></li><li><p><strong>确认号</strong>：占4个字节，是<strong>期望收到对方下一个报文段的第一个数据字节的序号</strong>(也就是报文的序号)。比方说B正确收到了A发送过来的一个报文段，序号字段为501，而数据长度为200字节，那么表明B正确收到了A发送的到序号700为止的数据。所以B期望收到A的下一个报文的序号是701，所以B在发送给A的确认报文段中把<strong>确认号设置为701</strong>。<br>总之，我们需要明白：</p><blockquote><p>若确认号 = N，就表明：到序号N-1为止的所有数据<strong>都已正确收到</strong>。</p></blockquote></li><li><p><strong>数据偏移</strong>：占4位，指出TCP报文段的数据起始处距TCP报文段的起始处有多远，实际上也就是指出<strong>TCP报文的首部长度</strong>。因为首部中还有选项字段，所以得通过该字段确定数据部分在哪个位置开始。<br>注意，数据偏移的单位是<strong>32个字(4字节)</strong>，4位表示最大十进制数为15，所以数据偏移的最大值是60个字节，也就是TCP首部长度最大是60字节，也就是选项字段最大为40字节。</p></li><li><p><strong>保留</strong> 6位，保留为今后使用，但目前全置为0。</p><p>下面为**6个控制位 **(6)~(11)</p></li><li><p><strong>紧急URG(URGent)</strong>: 当URG=1时，表明<strong>紧急指针字段有效</strong>，告诉系统此报文段中有紧急数据，需要尽快传送，相当于说要优先传送这些数据，不要按原来的排队顺序来传送，这时发送方TCP就会将紧急数据插入到本报文段数据的<strong>最前面</strong>。</p></li><li><p><strong>确认ACK(ACKnowledgment)</strong>: 仅当ACK=1时<strong>确认号字段</strong>才有效。当ACK=0时，确认号无效。TCP规定，在<strong>连接建立后</strong>所有传送的报文段都必须<strong>把ACK置1</strong>。</p></li><li><p><strong>推送PSH(PuSH)</strong>: 我们前面提到了TCP协议在发送端和接收端都有<strong>缓存</strong>，数据放入缓存，而什么时候发送和什么时候接收给上层要等<strong>合适</strong>的时机，但有时候两个应用进程进行交互式的通信，在一端的应用进程希望在键入一个命令后就<strong>立即能够收到对方的响应</strong>，而不是还需要停在缓存在等待合适的时机。在这种情况下，TCP就可以使用推送字段，发送方TCP把PSH置为1，并立即创建一个报文段发送出去。接收方TCP收到PSH=1的报文段，就尽快地<strong>交付给上层应用进程</strong>，而<strong>不再等到整个缓存都填满了再向上交付</strong>。</p></li><li><p><strong>复位RST(ReSeT)</strong> 当RST=1时，表明TCP连接中出现了严重错误，必须<strong>释放连接</strong>，再重新建立运输连接。RST置1还用来拒绝一个非法的报文段或拒绝打开连接。</p></li><li><p><strong>同步SYN(SYNchronization)</strong>：在连接建立时用来同步序号。当SYN=1时而ACK=0时，表明这是一个<strong>连接请求报文段</strong>。对方若同意建立连接，则应在响应的报文段使SYN=1和ACK=1。因此，SYN置为1就表示这是一个<strong>连接请求</strong>或<strong>连接接受报文</strong>。</p></li><li><p><strong>终止FIN(FINis)</strong>:：用来释放一个连接。当FIN=1时，表示该报文段的发送方的数据已发送完毕，并要求释放运输连接。</p></li><li><p><strong>窗口</strong> 占2个字节。窗口值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mi mathvariant="normal">，</mi><msup><mn>2</mn><mn>16</mn></msup><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0，2^{16}-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>之间的一个整数。窗口指的是发送本报文段的一方的<strong>接收窗口</strong>。窗口值告诉对方：从本报文段首部的确认号算起，接收方目前运行对方发送的数据量(<strong>以字节为单位</strong>)，之所以这么做是因为接收方<strong>接收缓存</strong>是有限的，如果接收的数据超过了缓存，会出现分组丢失。</p><p>举个例子，A发送了一个报文段，确认号为701，窗口字段是1000。意思就是告诉对方：“从701号算起，我的接受缓存还能接受1000个字节的数据”。</p><blockquote><p>窗口字段明确指出了现在允许对方发送的数据量，经常需要根据实际缓存可接收空间而变化。</p></blockquote></li><li><p><strong>检验和</strong>：占2字节，检验的范围和UDP一样，<strong>包括首部和数据</strong>这两部分。检验方法与UDP检验和类似，只是一些字段需要改变。如伪首部中的第四个字段需要改成6，第五个字段UDP长度应改为TCP长度。</p></li><li><p><strong>紧急指针</strong>：2个字节，仅当URG=1时才有意义，指出了本报文段中紧急数据的字节数，指出了紧急数据的末尾在报文段中的位置。值得注意的是，<strong>窗口为0也可以发送紧急数据</strong>。</p></li><li><p><strong>选项</strong> 长度可变，前面提到，最长可达40字节</p></li></ol><h2 id="6-tcp可靠传输的实现"><a class="markdownIt-Anchor" href="#6-tcp可靠传输的实现"></a> 6 TCP可靠传输的实现</h2><p>为了方便理解，<strong>假定数据传输只在一个方向进行</strong>，即A发送数据，B给出确认。</p><h3 id="61-以字节为单位的滑动窗口"><a class="markdownIt-Anchor" href="#61-以字节为单位的滑动窗口"></a> 6.1 以字节为单位的滑动窗口</h3><p>TCP的滑动窗口是<strong>以字节为单位的</strong>。假定A收到了B发来的确认报文段，告诉窗口是<strong>20字节</strong>，而确认号是31，也就是说B期望收到的下一个报文的序号字段为31，并且序号30之前的报文已经收到了。根据信息，A构造出字节的<strong>发送窗口</strong>，如图5-15：</p><img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_16.jpg" style="zoom: 33%;"><p>发送窗口表示：在没有收到B的确认的情况下，A可以连续把窗口内的数据都发送出去，需要再强调一遍：<strong>凡是已经发送出去的数据，但还没有收到确认，这些数据都必须暂时保留，以便在超时重传时使用</strong>。</p><p>发送窗口里面的序号表示允许发送的序号，在介绍TCP报文字段时提到，<strong>接收方会把自己的接收窗口数值放在窗口字段中发送给对方</strong>。因此，<strong>A的发送窗口一定不能超过B的接收窗口的值</strong>，否则会出现接收方处理不过来而导致某些报文段的丢失。</p><p>发送窗口的位置由<strong>窗口前沿</strong>和<strong>后沿</strong>的位置共同确定。发送窗口后沿的变化情况有两种：<strong>不动</strong>就表示没有收到新的确认，<strong>前移</strong>就表示收到了新的确认了。发送窗口前沿一般是<strong>不断向前移动</strong>的，但也有可能<strong>不动</strong>的，可能是因为没有收到新的确认而对方的接收窗口大小也保持不变，也可能是收到新的确认报文了，但是窗口大小变小了。</p><img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_17.jpg" style="zoom: 33%;"><p>如图5-16，要描述一个发送窗口的状态需要三个指针，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub><mi mathvariant="normal">，</mi><msub><mi>P</mi><mn>2</mn></msub><mi mathvariant="normal">，</mi><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_{1}，P_{2}，P_{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>指针都指向字节的序号，三个指针指向的部分的意义如下：</p><p>小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的是已发送并已收到确认的部分，而大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的是不允许发送的部分。</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>-<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=A的发送窗口。</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>-<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=<strong>已发送</strong>但<strong>未收到确认</strong>的字节数。</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>-<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=<strong>允许发送</strong>但<strong>尚未发送</strong>的字节数。</p><p>再观察B的<strong>接受窗口</strong>，B的接收窗口的大小是20。如图，到30号为止的数据是已经发送过确认，并且已经交付主机了。所以B不再保留这些数据，接收窗口内的序号31~50是允许接收的。如图5-16，B收到了序号为32和33的数据，但并没有收到序号为31的数据，我们前面有提到，B只能对按序收到的数据中的最高序号给出确认，因此B发送的确认报文段中的确认号<strong>还是31</strong>。</p><p>假定B之后收到了序号为31的数据，并把序号31<sub>33的数据交付主机，然后B就删除这些数据，把接收窗口向前移动3个序号，同时给A**发送确认**。窗口仍然为20，但**确认号变为34**。A收到B的确认后，将发送窗口向前滑动3个序号，指针$P_{2}$暂时不动，A现在可发送的序号范围是42</sub>53。</p><img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_18.jpg" style="zoom: 25%;"><p>之后A继续发送序号42~53的数据，指针<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>向前移动和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">P_{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>重合，此时发送窗口内的序号都已经使用完了，但还没有收到确认，可用窗口为0，<strong>停止发送</strong>，等待接收方发出确认。</p><img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_19.jpg" style="zoom: 25%;"><h3 id="62-窗口与缓存的关系"><a class="markdownIt-Anchor" href="#62-窗口与缓存的关系"></a> 6.2 窗口与缓存的关系</h3><p>前面提到，发送方和接收方都存在有缓存，<strong>发送方的应用进程把字节流写入TCP的发送缓存，接收方的应用进程从TCP的接收缓存中读取字节流</strong>。进一步讨论<strong>窗口</strong>和<strong>缓存</strong>的关系。如图5-19：</p><img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_20.jpg" style="zoom: 25%;"><p><strong>发送缓存</strong>用来暂存：</p><ul><li><strong>发送应用程序传送给发送方TCP准备发送的数据</strong></li><li><strong>TCP已经发送但尚未收到确认的数据</strong></li></ul><p>已被确认的数据会从发送缓存中删除。</p><p><strong>接收缓存</strong>用来暂存：</p><ul><li><strong>按序到达的，但尚未被应用程序接收读取的数据</strong></li><li><strong>未按序到达的数据</strong></li></ul><p>接收应用程序来不及读取收到的数据，接收缓存就被逐渐被填满，直到接收窗口为0。如果接收应用程序能够非常及时快速地读取缓存中的数据，接收窗口就可以增大。</p><p>对于缓存和窗口，还要强调以下三点：</p><ul><li><strong>在同一时刻，A的发送窗口并不是总是和B的接收窗口一样大</strong>。原因是：我们知道A的发送窗口是根据B发送的报文的窗口字段来确定的，而B发送的报文的窗口字段虽然是根据<strong>接收窗口</strong>的大小确定的，但是通过网络传送窗口报文组需要经历一段的<strong>时间滞后</strong>，所以导致A的发送窗口并不总是和B的接受窗口一样大。</li><li>TCP通常对不按序到达的数据先临时存放在接收窗口中，等到字节流中所缺少的字节收到时，再<strong>按序交付上层的应用程序</strong>。</li><li>TCP要求接收方需要有<strong>累计确认</strong>的功能，这样可以减小传输开销。接收方可以在<strong>合适</strong>的时候<strong>发送确认</strong>，也可以在自己有数据要发送时把确认信息顺便<strong>捎带</strong>上，称为<strong>捎带确认</strong>。</li></ul><h3 id="63-超时重传时间的选择"><a class="markdownIt-Anchor" href="#63-超时重传时间的选择"></a> 6.3 超时重传时间的选择</h3><p>前面提到，TCP的发送方在规定的时间内没有收到确认就要重传已发送的报文段，概念是很简单的，但是如何<strong>确认重传的时间选择</strong>却成为了TCP最复杂的问题之一。</p><p>如果把超时重传设计<strong>设置得太短</strong>，就会引起很多报文段的<strong>不必要重传</strong>。<strong>设置得太长</strong>，又使网络的空闲时间增大，<strong>降低了传输效率</strong>。</p><p>TCP采用了一种自适应的算法，它记录一个报文段发出的时间，以及受到相应的确认的时间。这两个时间之差就是<strong>报文段的往返时间RTT</strong>。TCP保留了RTT的一个<strong>加权平均往返时间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">RTT_{s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></strong>,又称为<strong>平滑的往返时间</strong>，因为是对众多往返时间的加权平均，所以结果更加<strong>平滑</strong>。</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">RTT_{s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>具体的计算是：第一次测量RTT样本时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">RTT_{s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>就为所测量到的RTT的样本值，以后每测量到一个新的RTT样本，就按下面公示重新计算新的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">RTT_{s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">新</mi><mi mathvariant="normal">的</mi><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mi mathvariant="normal">旧</mi><mi mathvariant="normal">的</mi><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mi>α</mi><mo>×</mo><mo stretchy="false">(</mo><mi mathvariant="normal">新</mi><mi mathvariant="normal">的</mi><mi>R</mi><mi>T</mi><mi>T</mi><mi mathvariant="normal">样</mi><mi mathvariant="normal">本</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">新的RTT_{s}=(1-\alpha) × (旧的RTT_{s})+\alpha × (新的RTT样本)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">新</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">旧</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">新</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord cjk_fallback">样</span><span class="mord cjk_fallback">本</span><span class="mclose">)</span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>的取值由标准推荐。</p><p>前面我们说到，超时计时器设置的**超时重传时间RTO(RetransmissionTime-Out)**应略大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">RTT_{s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。具体计算还需要看协议的标准。</p><h3 id="64-选择确认sack"><a class="markdownIt-Anchor" href="#64-选择确认sack"></a> 6.4 选择确认SACK</h3><p>这里还需要解决一个问题，就是收到的报文段无差错，只是未按序号，中间还<strong>缺少一些序号的数据</strong>。那么能否<strong>只传送缺少的数据而不重传已经正确到达接收方的数据</strong>？<strong>选择确认</strong>就是用来处理这种情况的可行方法。</p><p>举个例子说明**选择确认(Selective ACK)**的工作原理。如图5-21，可以看出，序号1<sub>1000收到了，但序号1001</sub>1500没有收到，1501~3000收到了，但是3001到3500又缺少了，再后面序号4501起都没有收到。</p><img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_21.jpg" style="zoom: 25%;"><p>接收方收到了和前面的字节流不连续的两个字节块，如果这些<strong>字节的序号都在接收窗口之内</strong>，那么接收方就先收下这些数据，并把这些信息告诉发送方，<strong>使发送方不要再重复发送这些已经收到的数据</strong>了。</p><p>从图5-21可看出，和前后字节不连续的每一个字节快都有<strong>两个边界</strong>，左边界和右边界。在图中用四个指针标记这些边界。第一个字节块的左边界<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">L_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=1501,但右边界<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">R_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=3001而不是3000，这表明<strong>左边界</strong>指出字节块的第一个字节的序号，但<strong>右边界减1</strong>才是字节块中的最后一个序号。</p><p>RFC 2018规定：</p><ul><li>如果要使用选择确认，那么在建立 TCP 连接时，就要在 TCP 首部的<strong>选项中</strong>加上“<strong>允许 SACK</strong>”的选项，而双方必须都事先商定好。</li><li>如果使用选择确认，那么原来首部中的“确认号字段”的用法仍然不变。只是以后在 TCP 报文段的首部中都增加了 SACK 选项，以便报告收到的不连续的字节块的边界。</li><li>由于首部选项的长度最多只有 40 字节，而指明一个边界就要用掉 4 字节，因此在选项中最多只能指明4个字节块的边界信息。(只能是因为40个字节还需要有的字节用来指明<strong>允许SACK</strong>等)</li></ul><p>大多数的实现还是重传<strong>所有未被确认的数据块</strong>。</p><h2 id="7-tcp的运输连接管理"><a class="markdownIt-Anchor" href="#7-tcp的运输连接管理"></a> 7 TCP的运输连接管理</h2><p>我们知道，TCP是<strong>面向连接</strong>的协议，运输连接是用来传送TCP报文的。TCP运输连接的<strong>建立和释放</strong>是每一次面向连接的通信中必不可少的。</p><p>因此，运输连接分为三个阶段：<strong>连接建立，数据传送，连接释放</strong>。运输连接的管理就是使运输连接的建立和释放都能正常地进行。</p><p>连接建立过程中要解决以下<strong>三个问题</strong>：</p><ul><li>要使每一方能够确知对方的存在。</li><li>要允许双方协商一些参数（如<strong>最大报文段长度</strong>，<strong>最大窗口大小</strong>，<strong>服务质量</strong>等）。</li><li>能够对运输实体资源（如缓存大小，连接表中的项目等）进行分配。</li></ul><h3 id="71-tcp的连接建立"><a class="markdownIt-Anchor" href="#71-tcp的连接建立"></a> 7.1 TCP的连接建立</h3><p>TCP连接的建立都是采用<strong>客户服务器</strong>方式。主动发起连接建立的应用进程叫做<strong>客户(cilent)</strong>，被动等待连接建立的应用进程叫做<strong>服务器(server)</strong>。</p><p>TCP的建立连接的过程叫做<strong>握手</strong>。握手需要再客户和服务器之间交换三个TCP报文段，称为<strong>三次握手</strong>，如图5-28：</p><img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_27.jpg" style="zoom: 25%;"><p>主机A运行TCP客户程序，B运行TCP服务器程序。最初两端的TCP进程均处于**CLOSED(关闭)**状态。<strong>A主动打开连接</strong>，<strong>B被动打开连接</strong>。</p><p>最开始，B的TCP服务器进程先创建<strong>传输控制块TCB</strong>，准备接受客户进程的连接请求，服务器进程处于**LISTEN(收听)**状态，等待客户的连接请求，如有，作出响应。</p><p>A的TCP客户进程也是首先创建<strong>传输控制模块TCB</strong>。然后，在打算建立TCP连接的时候，<strong>向B发出连接请求报文段</strong>，此时首部中的同步位<strong>SYN=1</strong>,表明这是一个连接请求报文，同时选择一个初始序号<strong>seq=x</strong>。注意，TCP规定，SYN=1的报文段<strong>不能携带数据</strong>，但是要<strong>消耗掉一个序号</strong>。发送完连接请求报文后，TCP客户进程就进入了(SYN-SENT)，也就是<strong>同步已发送</strong>状态。</p><p>B收到连接请求报文段后，如果同意建立连接，则向A<strong>发送确认</strong>， B 在确认报文段中应使 SYN=1, ACK=1,表明这是一个<strong>连接接受报文</strong>，其确认号ack = x+1(<strong>表明下一个想接收到的报文的序号为x+1</strong>，自己选择的序号 seq =y。这是TCP服务器进程进入了SYN-RCVD，也就是<strong>同步收到</strong>状态。</p><p>TCP客户进程收到B的确认后，还要向B再给出确认。其确认报文的ACK=1,确认号ack=y+1,seq=x+1。同时,A的TCP通知上层应用进程，告诉<strong>连接已经建立</strong>了，可以发数据了。注意，TCP的标准规定ACK报文段可以携带数据，但<strong>如果不携带数据则不消耗序号</strong>，这种情况下一个数据报文的序号仍然是seq=x+1。发送完报文后,A进入ESTABLISHED，也就是<strong>已建立连接</strong>状态。B收到A的确认后，也进入已建立连接状态，通知上层TCP连接已经确立。</p><h3 id="72-为什么连接建立a最后还要发送一次确认"><a class="markdownIt-Anchor" href="#72-为什么连接建立a最后还要发送一次确认"></a> 7.2 为什么连接建立，A最后还要发送一次确认？</h3><p>主要是为了防止<strong>已失效的连接请求报文段</strong>突然传送到了B，产生错误。假定A发出的第一个连接请求报文段在某些网络结点长时间滞留了，A等待超时计时器时间走完没有收到确认，于是再次发起连接请求，请求成功，A和B正常同时并完成了连接的释放。过了一段时间，第一次滞留在网络中的连接请求报文到达了B，这本来是一个早已失效的报文段了，但B收到此失效的连接请求报文段后，以为是A又发出了一次新的连接请求，于是B会正常地向A发送确认报文。如果我们的协议是<strong>B只要发出确认，新的连接就建立了</strong>，那么A这时候就会很莫名其妙，我没有发出连接请求啊，因此A不会理睬B的确认，也不会向B发送数据，但B却误以为新的运输连接已经建立，一直处于等待状态，B因此浪费了许多的资源。</p><h3 id="73-tcp的连接释放"><a class="markdownIt-Anchor" href="#73-tcp的连接释放"></a> 7.3 TCP的连接释放</h3><p>数据传输后，<strong>通信双方</strong>都可以释放连接。连接释放前，A和B都处于已建立连接(ESTABLISHED)状态，如图5-29。</p><img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_28.jpg" style="zoom: 25%;"><p>A的应用进程先向其TCP发出连接释放报文段，<strong>并停止再发送数据</strong>，主动关闭TCP连接。A把连接释放报文段首部的终止控制位FIN=1，其序号为seq=u。这时A进入FIN-WAIT-1 <strong>终止等待1</strong>状态，等待B的确认。</p><p>B收到连接释放报文段后立即发出确认号，确认号是ack=u+1，而整个报文段自己的序号seq=v，然后B就进入了CLOSE-WAIT <strong>关闭等待</strong>状态。TCP服务器进程这时通知高层应用进程。从A到B这个方向的连接就释放了，TCP连接处于<strong>半关闭</strong>状态，也就是<strong>A已经没有数据要发送了，但B若发送数据，A仍要接收</strong>。</p><p>A收到来自B的确认后，就进入了 FIN-WAIT-2 <strong>终止等待2</strong>状态，等待B发出的连接释放报文段。</p><p>若B已经没有要向A发送的数据了，其应用进程就通知TCP释放连接。这时B发出的连接释放报文段同样使FIN=1，ACK=1，seq等于对应的序号w，ack=u+1(与上一个确认报文相同，因为A早已经不再发送数据了)。发送完后，B就进入了LAST-ACK <strong>最后确认</strong>状态，等待A的确认。</p><p>A收到B的连接释放报文段后，必须发出确认，在确认报文段中把ACK置1，确认号ack=w+1，而自己的序号是seq=u+1，之后进入到TIME-WAIT <strong>时间等待</strong>状态。</p><p>现在的TCP连接还没有释放掉，必须经过<strong>时间等待计时器(TIME-WAIT timer)<strong>设置的时间2MSL，A才进入到CLOSED状态。时间MSL叫</strong>最长报文段寿命</strong>(Maximum Segment Lifetime)。</p><p>为什么A在TIME-WAIT状态必须等待2MSL的时间呢？有两个理由：</p><ul><li>第一，为了保证A发送的最后一个ACK报文段能够到达B。因为这个ACK报文段可能会丢失，因而B会超时重传连接断开报文字段，A就能在2MSL时间内收到这个报文段，重传一次确认。</li><li>第二，防止前面提到的<strong>已失效的连接请求报文段</strong>出现在本连接中，A在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失，保证下一个新的连接中不会出现这种旧的连接请求报文段。</li></ul><h2 id="8-tcp的流量控制"><a class="markdownIt-Anchor" href="#8-tcp的流量控制"></a> 8 TCP的流量控制</h2><h3 id="81-利用滑动窗口实现流量控制"><a class="markdownIt-Anchor" href="#81-利用滑动窗口实现流量控制"></a> 8.1 利用滑动窗口实现流量控制</h3><p>一般来说，我们总是希望数据传输得更快一些，但如果发送方把数据发送得过快，接收方就可能来不及接收，造成了数据的丢失。所谓**流量控制(flow control)**就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发送拥塞。<strong>利用滑动窗口</strong>机制可以很方便地在TCP连接上实现流量控制。</p><p>如图5-22流量控制举例：</p><img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_22.jpg" style="zoom: 25%;"><p>A向B发送数据，在连接建立时，B告诉A：“<strong>我的接收窗口rwnd=400(字节，不是报文段)”</strong>，因此，<strong>发送方的发送窗口不能超过接收方给出的接收窗口的数值</strong>。</p><p>假设每一个报文段为100字节长，数据报文段序号的初始值设为1。</p><p>从图中注意到，接收方的主机B进行了<strong>三次流量控制</strong>。第一次把窗口减小到rwnd=300，第二次减到rwnd=100，最后减到rwmd=0，即不允许发送方再发送数据了。这种暂停的状态将持续到主机B重新发出一个新的窗口值为止。</p><p>现在我们需要考虑一种情况：在图5-22中,B向A发送了零窗口的报文段不久后，B的接收缓存有了一些存储空间，于是B向A发送了rwnd=400的报文段，告诉A“<strong>现在有空间了，你可以继续发送数据了</strong>”，然而非常非常不幸运的是，这个报文段<strong>居然丢失了</strong>，A就一直等一直等等收到B发送的非零窗口的通知，而B心想：“<strong>我都告诉你有空间了，咋还不发数据</strong>”，也在一直等一直等。如果没有其他措施，这种互相等待的死锁局面将一直延续下去。</p><p>为了解决这个问题，TCP为每一个连接设有一个<strong>持续计时器(persistence timer)</strong>。只要TCP连接的一方<strong>收到对方的零窗口通知</strong>，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口<strong>探测报文段</strong>，而对方就在确认这个探测报文段时给出现在的<strong>接收窗口值</strong>。如果接收窗口为0，那么收到这个报文段的一方就<strong>重新设置</strong>持续计时器，如果不是0，就打破了死锁的僵局。</p><h3 id="82-tcp-的传输效率"><a class="markdownIt-Anchor" href="#82-tcp-的传输效率"></a> 8.2 TCP 的传输效率</h3><p>前面提到了，应用进程把数据传送到TCP的发送缓存后，剩下的发送任务就由TCP来控制了，可以用<strong>不同的机制来控制TCP报文段的发送时机</strong>。</p><ul><li><p>第一种机制是 TCP 维持一个变量，它等于最大报文段长度<strong>MSS</strong>。只要缓存中存放的数据达到MSS字节时，就组装成一个TCP报文段发送出去。</p></li><li><p>第二种机制是由<strong>发送方的应用进程指明要求发送报文段</strong>，即TCP支持的推送(push)操作。</p></li><li><p>第三种机制是发送方的一个<strong>计时器</strong>期限到了，这时就把当前已有的缓存数据装入报文段(<strong>但长度不能超过MSS</strong>)发送出去。</p></li></ul><p><strong>交互式程序中的效率</strong>：</p><p>发送方发送1字节的数据，同时要求服务器端回显这1字节数据。服务器确认后，再发回这1字节数据。则效率：1B/(41B的报文+40B的确认(<strong>20IP首部+20TCP首部+无数据</strong>)+41B的回显报文+40B的确认)<br>办法：</p><ul><li>使用捎带确认: <strong>适当推迟发回确认报文，并尽量使用捎带确认的方法</strong>。</li><li>Nagle算法：若发送方的应用程序把数据逐个送到TCP发送缓存，发送方将第一个数据字节发送出去，收到确认后，再把缓存中的数据数据组装成一个报文段发送出去。原则是：<strong>只有收到对前一个报文段的确认，才继续发送下一个报文段</strong>。</li></ul><h2 id="9-tcp的拥塞控制"><a class="markdownIt-Anchor" href="#9-tcp的拥塞控制"></a> 9 TCP的拥塞控制</h2><h3 id="91-拥塞控制的一般原理"><a class="markdownIt-Anchor" href="#91-拥塞控制的一般原理"></a> 9.1 拥塞控制的一般原理</h3><p>在计算机网络中的带宽，交换结点中的缓存等都是网络的资源。在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏–产生<strong>拥塞(congestion)</strong>。</p><ul><li>出现资源拥塞的条件：对于资源需求的总和 &gt; 可用资源</li><li>如果网络中许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。</li></ul><h4 id="911这里辨别一下拥塞控制和流量控制的关系"><a class="markdownIt-Anchor" href="#911这里辨别一下拥塞控制和流量控制的关系"></a> 9.1.1这里辨别一下<strong>拥塞控制</strong>和<strong>流量控制</strong>的关系：</h4><p>拥塞控制与流量控制的关系密切，但也存在差别。<strong>拥塞控制</strong>是<strong>防止过多的数据注入到网络中</strong>，这样可以<strong>使网络中的路由器或链路不致过载</strong>。拥塞控制是一个<strong>全局性</strong>的过程，涉及到网络中所有的主机，所有的路由器以及与降低网络传输性能有关的所有因素。</p><p>而<strong>流量控制往往是指点对点通信量的控制</strong>，是个<strong>端到端</strong>的问题，流量控制所要做的就是<strong>抑制发送端发送</strong>数据的速率，<strong>以便使接收端来得及接收</strong>。</p><p>举个例子，设某个光纤网络的链路传输速率为1000Gbit/s。一台巨型计算机向一台个人一点以1Gbit/s的速率传送文件。（<strong>端到端</strong>）显然，网络本身的带宽资源是足够的，不存在拥塞的问题，但必须进行流量控制，因为个人电脑不如巨型计算机快。</p><p>而如果有另一个网络，链路传输速率为1Mbit/s，而有1000台大型计算机连接在网络上。假定其中的500台计算机分别向其余的500台计算机以100kbit/s的速率发送文件，很明显<strong>网络的资源已经不够了</strong>，整个网络的输入负载已经超过了网络所能承受的。</p><h4 id="912-理想拥塞控制和实际拥塞控制对比"><a class="markdownIt-Anchor" href="#912-理想拥塞控制和实际拥塞控制对比"></a> 9.1.2 理想拥塞控制和实际拥塞控制对比</h4><p>如图5-23：</p><img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_23.jpg" style="zoom: 25%;"><p>横坐标是<strong>提供的负载(offered load)</strong>,代表单位时间内输入给网络的分组数目，也称为<strong>输入负载</strong>或<strong>网络负载</strong>。纵坐标是<strong>吞吐量(throughput)</strong>,代表单位时间内从网络<strong>输出</strong>的分组数目。</p><p>具有理想拥塞控制的网络，在吞吐量饱和之间，网络吞吐量应等于提供的负载，所以吞吐量曲线是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn><msup><mn>5</mn><mi mathvariant="normal">。</mi></msup></mrow><annotation encoding="application/x-tex">45^{。}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord"><span class="mord">5</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.363em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">。</span></span></span></span></span></span></span></span></span></span></span></span>的斜线，但当提供的负载超过某一个<strong>限度</strong>时，网络资源受限，吞吐量不再增长而保持为水平线，提供的负载有一部分将会丢失了。虽然如此，但是在这种理想的拥塞控制作用下，网络的吞吐量仍然维持在其所能达到的最大值。</p><p>但是，实际网络的情况就不一样了，随着提供的负载增大，网络的吞吐量的增长速率在逐渐减小，也就是说，在网络吞吐量还未达到饱和时，就有一部分输入负载被丢弃了。并当<strong>网络的吞吐量</strong>明显地小于<strong>理想的吞吐量</strong>时，网络就进入了<strong>轻度拥塞</strong>的状态。当提供的负载达到某一数值，网络的吞吐量反而下降了，这时网络就进入了<strong>拥塞状态</strong>。当提供的负载继续增大，网络的吞吐量将下降到0，无法工作，进入了所谓的<strong>死锁状态</strong>。</p><h4 id="913-开环控制和闭环控制"><a class="markdownIt-Anchor" href="#913-开环控制和闭环控制"></a> 9.1.3 开环控制和闭环控制</h4><ul><li>开环控制方法就是在设计网络时<strong>事先将有关发生拥塞的因素考虑周到</strong>，力求网络在<strong>工作时不产生拥塞</strong>。</li><li>闭环控制是基于反馈环路的概念。属于闭环控制的有以下几种措施：<ol><li>监测网络系统以便<strong>检测到拥塞在何时、何处</strong>发生。</li><li>将拥塞发生的<strong>信息传送</strong>到可采取行动的地方。</li><li><strong>调整网络</strong>系统的运行以解决出现的问题。</li></ol></li></ul><h3 id="92-tcp的拥塞控制方法"><a class="markdownIt-Anchor" href="#92-tcp的拥塞控制方法"></a> 9.2 TCP的拥塞控制方法</h3><p>TCP进行拥塞控制的算法有四种，即<strong>慢开始(slow-start)</strong>，<strong>拥塞避免(congestion avoidance)</strong>，<strong>快重传(fast retransmit)<strong>和</strong>快恢复(fast recovery)</strong></p><p>首先介绍一些概念:</p><p><strong>发送方</strong>维持一个叫做**拥塞窗口cwnd(congestion window)**的状态变量。拥塞窗口的大小取决于网络的拥塞程序，并动态地变化。<strong>发送方让自己的发送窗口等于拥塞窗口</strong>。</p><p><strong>接收端窗口rwnd</strong>：  这是接收端根据其目前的接收缓存大小所许诺的最新的窗口值，是来自接收端的流量控制。接收端将此窗口值放在 TCP 报文的首部中的窗口字段，传送给发送端。</p><p>发送方控制拥塞窗口的原则是：只要网络不出现拥塞，拥塞窗口就可以再<strong>增大一倍</strong>，以转发更多的分组。但只要出现拥塞或有可能出现拥塞，就<strong>把拥塞窗口减小一些</strong>，以缓解拥塞。发送方如何知道网络发生了拥塞？<strong>判断网络拥塞的依据就是出现了超时</strong>(其实并不准确，后面会解释)。</p><p><strong>发送窗口的上限值</strong>：发送端的发送窗口的上限值应当取为接收端窗口 rwnd和拥塞窗口cwnd 这两个变量中较小的一个，即应按以下公式确定：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">发</mi><mi mathvariant="normal">送</mi><mi mathvariant="normal">窗</mi><mi mathvariant="normal">口</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">上</mi><mi mathvariant="normal">限</mi><mi mathvariant="normal">值</mi><mo>=</mo><mi>M</mi><mi>i</mi><mi>n</mi><mo stretchy="false">[</mo><mi>r</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo separator="true">,</mo><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">发送窗口的上限值=Min[rwnd,cwnd]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">发</span><span class="mord cjk_fallback">送</span><span class="mord cjk_fallback">窗</span><span class="mord cjk_fallback">口</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">上</span><span class="mord cjk_fallback">限</span><span class="mord cjk_fallback">值</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span></span></p><p>当 rwnd &lt; cwnd 时，是接收端的接收能力限制发送窗口的最大值。当 cwnd &lt; rwnd 时，则是网络的拥塞限制发送窗口的最大值。</p><h4 id="921-慢开始算法原理"><a class="markdownIt-Anchor" href="#921-慢开始算法原理"></a> 9.2.1 慢开始算法原理</h4><p><strong>慢开始</strong>算法的思路：<strong>由小到大</strong>逐渐增大<strong>发送窗口</strong>，也就是说，<strong>由小到大逐渐增加拥塞窗口数值</strong>，原因很简单，因为刚开始我们并不知道网络的负荷情况，所以先发较少的数据探测一下，具体规定为：</p><ul><li>在主机刚刚开始发送报文段时可先将拥塞窗口cwnd设置为一个最大报文段 MSS 的数值。</li><li>在每收到一个对新的报文段的确认后，将拥塞窗口增加至多一个 MSS 的数值。</li><li>用这样的方法逐步增大发送端的拥塞窗口 cwnd，可以使分组注入到网络的速率更加合理。</li></ul><p>下面举例说明<strong>慢开始算法的原理</strong>： 如图5-24</p><img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_24.jpg" style="zoom: 25%;"><p><strong>报文段的个数</strong>作为<strong>窗口大小的单位</strong>。</p><p>当TCP连接进行初始化时，将拥塞窗口cwnd=1，发送第一个报文段<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，接收方收到后确认<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,发送方收到对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的确认后，把cwnd从1增大到2，于是发送方接着发送<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">M_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">M_{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>两个报文段，接收方都收到后发回对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">M_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">M_{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的确认。发送方每收到一个<strong>对新报文段的确认</strong>，就使发送方的拥塞窗口加1，因此发送方收到两个确认后，cwnd就从2增大到4了，可以发之后的四个报文段了。</p><p>因此使用慢开始算法后，<strong>每经过一个传播轮次(transmission round)，拥塞窗口cwnd就加倍。</strong> 如图5-24，一个传播轮次所经历的时间其实就是往返时间RTT，这里还需要注意RTT不是恒定的数值，一个传播轮次的时间更加具体的说是：cwnd所允许发送的报文段<strong>都连续发送</strong>出去，<strong>并全部收到了确认</strong>经历的<strong>总时间</strong>。</p><h4 id="922-慢开始门限ssthresh"><a class="markdownIt-Anchor" href="#922-慢开始门限ssthresh"></a> 9.2.2 慢开始门限ssthresh</h4><p>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个<strong>慢开始门限ssthresh</strong>状态变量。慢开始门限的用法是：</p><ul><li>当cwnd&lt;ssthresh时，使用上述的慢开始算法</li><li>当cwnd&gt;ssthresh时，停止使用慢开始算法而改用拥塞避免算法</li><li>当cwnd=ssthresh，两种算法都可以使用</li></ul><h4 id="923-拥塞避免算法原理"><a class="markdownIt-Anchor" href="#923-拥塞避免算法原理"></a> 9.2.3 拥塞避免算法原理</h4><p><strong>拥塞避免</strong>算法的思路是让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口+1，而不是像慢开始算法那样加倍增长，也叫<strong>加法增大(Additive Increase)</strong>，cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p><img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_25.jpg" style="zoom: 25%;"><p>如图5-25，在慢开始算法下，当拥塞窗口cwnd增长到慢开始门限值ssthresh时，就改为执行拥塞避免算法，拥塞窗口按线性规律增长，<strong>使得网络比较不容易出现拥塞</strong>，但并非不是完全能够避免了拥塞。</p><p>当拥塞窗口cwnd=24时，网络中出现了超时，如图中的点2，表明已经出现了网络拥塞，发送方于是调整门限ssthresh=cwnd/2=12，重新设置拥塞窗口cwnd=1，重新进入慢开始阶段，当拥塞窗口到达了新的门限12时，就继续改为执行<strong>拥塞避免</strong>算法。</p><p>我们说到<strong>网络中出现了超时，就表明已经出现了网络拥塞</strong>，这个只是大多数的情况下，这么说其实并不准确，有时个别报文段在网络中丢失了，但实际上并不是网络拥塞造成的，这会导致发送方错误地重新设置慢开始门限，把拥塞窗口cwnd设置为1，<strong>因而降低了传输效率</strong>。(因为网络并没有拥塞，还不需要去控制拥塞窗口。)</p><h4 id="924-快重传"><a class="markdownIt-Anchor" href="#924-快重传"></a> 9.2.4 快重传</h4><p>怎么去解决上面说 的这种误会呢？采用快重传算法可以使发送方<strong>尽早知道发生了个别报文段的丢失</strong>。</p><p>快重传算法首先<strong>要求接收方不要等待自己发送数据时才捎带确认</strong>，而是<strong>立即发送确认</strong>。这样做可以让发送方及早知道有报文段没有到达接收方。快重传算法规定，<strong>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段</strong>。这样就不会出现超时，发送方也就不会误以为出现了网络拥塞。</p><img src="/2021/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82/运输层_26.jpg" style="zoom: 25%;"><h4 id="925-快恢复"><a class="markdownIt-Anchor" href="#925-快恢复"></a> 9.2.5 快恢复</h4><p>如图在5-25中的点4，发送方一连收到3个对同一个报文段的重复确认，知道现在<strong>只是</strong>丢失了个别的报文段。于是不启动慢开始，而是执行<strong>快恢复</strong>算法。这是，发送方调整门限值ssthresh=cwnd/2=8，同时设置拥塞窗口cwnd=ssthresh=8，开始执行<strong>拥塞避免</strong>算法。</p><h2 id="10-总结jiade"><a class="markdownIt-Anchor" href="#10-总结jiade"></a> 10 总结(jiade)</h2><p>终于终于写完了~~~，真是<strong>又臭又长</strong>，TCP的东西实在是太多了，还有好多细节没有写到。</p><p>总结一下</p><p>我们从<strong>为什么需要运输层</strong>说起，提到了真正在计算机网络中进行的通信是<strong>位于通信两端主机中的进程</strong>之间的通信，IP协议以下层协议只能把分组送到目的主机，而运输层就是来解决<strong>交付给哪个进程的问题</strong>，紧接着介绍了运输层的功能，包括<strong>复用</strong>和<strong>分用</strong>，以及<strong>提供应用进程间的逻辑通信</strong>，运输层提供了两种信道，<strong>可靠信道</strong>，对应TCP协议，<strong>不可靠信道</strong>，对应UDP协议，之后介绍了<strong>端口</strong>----用于给应用层的每个应用进程赋予一个非常明确的标志。之后介绍了UDP协议，主要特点是<strong>无连接</strong>，<strong>不可靠</strong>，<strong>面向报文</strong>，<strong>无拥塞控制</strong>。</p><p>然后就开始了漫长的TCP协议学习…</p><p>TCP的主要特点是<strong>面向连接</strong>，<strong>点到点的</strong>(连接的端点是<strong>套接字</strong>)，<strong>可靠的</strong>，<strong>全双工通信</strong>，<strong>面向字节流</strong>。</p><p>这是我们第一次遇到<strong>可靠交付</strong>的情况，所以我们介绍了<strong>可靠传输的原理</strong>，知道了<strong>理想的传输条件有以下两个特点</strong>：</p><blockquote><ul><li>一 传输信道<strong>不出现差错</strong>。</li><li>二 不管发送方以多快的速度发送数据，接收方<strong>总是来得及处理</strong>收到的数据。</li></ul></blockquote><p>实现了这两个特点，就实现了可靠传输，然后就开始具体学习如何实现这两个特点，学习可靠传输的原理，首先是<strong>停止等待协议</strong>，因为<strong>停止等待协议</strong>信道利用率太低，又引入了更高效率的<strong>ARQ连续协议</strong>。</p><p>然后就在可靠传输原理上，学习TCP可靠传输的实现，介绍了<strong>滑动窗口</strong>和<strong>超时重传时间</strong>，之后是<strong>TCP</strong>的运输连接，<strong>三次握手</strong>和<strong>四次挥手</strong>，最后介绍了TCP的流量控制和拥塞控制。</p><p>真的真的结束了，感觉对运输层的理解还是<strong>形成不了体系</strong>，所以本篇博客只是<strong>自己</strong>对课程学习的一些笔记和总结，大部分内容参考自**《计算机网络》**第七版，谢希仁编著。</p><p>如有出错(非常大可能会出错哈哈)，欢迎指正！</p><p>完…</p><p>应该不会有人看到这吧哈哈哈哈哈~~~~~~  (溜了溜了)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文巨长且干货极少，&lt;strong&gt;阅读请谨慎&lt;/strong&gt;！！！！&lt;/p&gt;
&lt;h2 id=&quot;1-运输层协议概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-运输层协议概述&quot;&gt;&lt;/a&gt; 1 运输层协议概述&lt;/h2&gt;
&lt;h3 id=&quot;11-为什么需要运输层&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#11-为什么需要运输层&quot;&gt;&lt;/a&gt; 1.1 为什么需要运输层？&lt;/h3&gt;
&lt;p&gt;和之前介绍的层次一样，在开始之前，我们需要&lt;strong&gt;先知道为什么需要运输层&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;我们知道现代操作系统，都是支持&amp;quot;多任务&amp;quot;的操作系统。“多任务&amp;quot;简单的说就是操作系统可以同时运行多个任务，比如你可以一边在用浏览器上网，一边打开网易云听歌，一边用Word赶作业。&lt;/p&gt;
&lt;p&gt;那么操作系统如何实现这种”多任务“呢？答案就是操作系统轮流让各个任务交替执行,但是因为CPU太快了，给我们的感受就是所有任务都在同时执行。对于操作系统而言，一个任务就是一个&lt;strong&gt;进程(Process)&lt;/strong&gt;,&lt;/p&gt;
&lt;p&gt;这里提到&lt;strong&gt;进程&lt;/strong&gt;，我们知道，计算机网络体系结构中的&lt;strong&gt;物理层&lt;/strong&gt;，&lt;strong&gt;数据链路层&lt;/strong&gt;以及&lt;strong&gt;网络层&lt;/strong&gt;它们要解决的问题是在网络互联的情况下，如何&lt;strong&gt;实现主机到主机的通信&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;然而，真正在计算机网络中进行的通信是&lt;strong&gt;位于通信两端主机中的进程&lt;/strong&gt;之间的通信，是一台主机中的&lt;strong&gt;一个进程&lt;/strong&gt;和另一台主机中的&lt;strong&gt;另一个进程&lt;/strong&gt;在交换数据(也就是通信)。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://luo41.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://luo41.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="运输层" scheme="https://luo41.top/tags/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络物理层</title>
    <link href="https://luo41.top/2021/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <id>https://luo41.top/2021/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%89%A9%E7%90%86%E5%B1%82/</id>
    <published>2021-06-12T00:43:55.000Z</published>
    <updated>2021-07-15T04:51:51.191Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-物理层的基本概念"><a class="markdownIt-Anchor" href="#1-物理层的基本概念"></a> 1 物理层的基本概念</h3><h4 id="需要物理层需要做些什么"><a class="markdownIt-Anchor" href="#需要物理层需要做些什么"></a> 需要物理层需要做些什么？</h4><p>需要指出，物理层考虑的是怎样才能在连接<strong>各种计算机的传输媒体</strong>上<strong>传输数据比特流</strong>，而不是指某种具体的传输媒体。</p><p>可以说，<strong>物理层提供了一层抽象</strong>，上层的数据链路层和网络层<strong>只需要知道物理层传输的是比特流</strong>，而不去考虑物理层用何种方式去传输比特流。</p><p>为什么要提供这样的一层抽象？因为现有的计算机网络中的硬件设备和传输媒体的种类非常繁多，而通信手段也有很多不同的方式，<strong>物理层的作用正是要尽可能地屏蔽掉这些传输媒体和通信手段的差异和复杂性</strong>，使得物理层上面的数据链路层感觉不到这些差异，这样就可以使得数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体和通信手段是什么，大大降低了复杂性。</p><p>此外，数据在计算机内部多采用<strong>并行传输方式</strong>，而数据在通信线路上的传输方式一般都是<strong>串行传输</strong>，也就是逐个比特按照时间顺序传输，因此，物理层还要完成<strong>传输方式的转换</strong>。</p><span id="more"></span><h3 id="2-数据通信的基础知识"><a class="markdownIt-Anchor" href="#2-数据通信的基础知识"></a> 2 数据通信的基础知识</h3><p>物理层<strong>需要传输比特流</strong>，如何传输比特流？这就需要引出一些<strong>数据通信的基础知识</strong>。</p><h4 id="21-数据通信系统的模型"><a class="markdownIt-Anchor" href="#21-数据通信系统的模型"></a> 2.1 数据通信系统的模型</h4><p>如图2-1 一个数据通信系统可划分为三个部分，即<strong>源系统</strong>(或叫做发送端，发送方)，<strong>传输系统</strong>(或传输网络)和<strong>目的系统</strong>(接收端，接收方)。</p><img src="/2021/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%89%A9%E7%90%86%E5%B1%82/3.jpg" style="zoom:30%;"><p><strong>源系统</strong>一般包括以下两个部分：</p><ul><li><strong>源点(source)</strong>: 源点设备产生要传输的数据，例如，我们从计算机的键盘输入汉字或者通过麦克风说话，计算机将这些信息产生输出的数字比特流。源点有称为<strong>源站</strong>，或<strong>信源</strong>。</li><li><strong>发送器</strong>： 通常源点生成的数字比特流还要通过<strong>发送器编码</strong>后才能够在传输系统中进行传输。典型的发送器有<strong>调制器</strong>，将信号变为<strong>适合</strong>传输系统传输的信号。</li></ul><p><strong>目的系统</strong>一般也包括以下两个部分：</p><ul><li><p><strong>接收器</strong>：接受传输系统传送过来的信号，并把它转换为能够被目的设备处理的<strong>信号</strong>。典型的接收器有<strong>解调器</strong>。发送器和接受器的功能是相反的，发送器将<strong>信号</strong>转变为<strong>适合传输系统</strong>传输的信息，而接受器将<strong>传输系统的信号</strong>转变为能被目的设备处理的<strong>信号</strong>。</p></li><li><p><strong>终点(destination)</strong>：终点设备从接收器获取传送来的<strong>数字比特流</strong>，然后把信息输出，例如把汉字在计算机屏幕上显示出来，将声音从扬声器中传出。终点又称为<strong>目的站</strong>或<strong>信宿</strong>。</p></li></ul><p><strong>传输系统</strong>可以是简单的传输线，也可以是连接在<strong>源系统</strong>和<strong>目的系统</strong>之间的<strong>复杂网络系统</strong>。</p><p><strong>一些常用的术语</strong>“</p><ul><li><strong>消息(message)</strong>：通信的目的是传送信息<strong>消息</strong>，常见的信息有<strong>话音</strong>，<strong>文字</strong>，<strong>图像</strong>，<strong>视频</strong>。</li><li><strong>数据(data)</strong>： 数据是<strong>运送消息的实体</strong>。</li><li><strong>信号(signal)</strong>: 则是数据的电气或电磁的表现。(书上的定义，不太懂)。我感觉可以简单地理解为<strong>信号也是消息的载体</strong>。但是信号有不同的特性，比如<strong>烽火狼烟</strong>属于的是<strong>光信号</strong>，我们可以从<strong>光信号</strong>中获取到敌人入侵了的消息。我们说话时，别人获取的是<strong>声信号</strong>，然后知道我们的意图(消息)。</li></ul><p>信号可分为<strong>模拟信号</strong>和<strong>数字信号</strong> 如图：</p><ul><li><strong>模拟信号</strong>，也称<strong>连续信号</strong>： 代表着消息的参数的取值是连续的。</li><li><strong>数字信号</strong>，也称<strong>离散信号</strong>： 代表消息的参数的取值是离散的。不同波形表示数字信号时，代表着不同离散数值的基本波形就称为<strong>码元</strong>。在使用二进制编码时，只有两种不同的码元，一种代表0状态一种代表1状态。</li></ul><h4 id="22-信道的几个基本概念"><a class="markdownIt-Anchor" href="#22-信道的几个基本概念"></a> 2.2 信道的几个基本概念</h4><h5 id="221-通信交互的三种基本方式"><a class="markdownIt-Anchor" href="#221-通信交互的三种基本方式"></a> 2.2.1 通信交互的三种基本方式</h5><p>在数据通信的很多情况下，我们要使用<strong>信道(channel)这一名词。<strong>信道一般用来表示</strong>向一个方向</strong>传送消息的媒体。因此，<strong>一条通信电路往往包括一条发送信道和一条接收信道</strong>。</p><p>从通信的双方信息<strong>交互的方式</strong>来看，有三种基本方式：</p><ul><li><strong>单向通信</strong>：又称为<strong>单工通信</strong>，即只能有一个方向的通信而没有反方向的交互。<strong>无线电广播</strong>或<strong>有线电广播</strong>以及<strong>电视广播</strong>就属于这种类型。</li><li><strong>双向交替通信</strong>：又称<strong>半双工通信</strong>，即通信的双方都可以发送消息，但不能双方同时发送，也不能同时接收。这种通信方式是<strong>一方发送另一方接收</strong>，然后发送和接收的主体可以更替。</li><li><strong>双向同时通信</strong>，又称为<strong>全双工通信</strong>：即通信的双方可以同时发送和接收信息。</li></ul><p>单向通道只需要一条信道，而双向交替通信或双向同时通信则都<strong>需要两条信道</strong>(每个方向各一条)。</p><p>关于这三种基本方式，举一个形象的例子，<strong>单向通信</strong>就比如说你妈骂你而你不敢还嘴，所以就只有一个方向的通信没有反方向的交互(<strong>纯挨骂</strong>)。<strong>双向交替通信</strong>就是两个<strong>非常有素质</strong>的人有一天对骂了，但他们非常<strong>有素质</strong>，一人骂一句，<strong>交替骂</strong>。而<strong>双向同时通信</strong>就是泼妇骂街了，两个人同时开骂，同时接收。</p><h5 id="222-信号和调制"><a class="markdownIt-Anchor" href="#222-信号和调制"></a> 2.2.2 信号和调制</h5><ul><li><strong>基带信号</strong>： 来自信源的信号，也是基本频带信号。比如说计算机输出的代表各种文字或图像文件的数据信号都是基带信号。</li></ul><p>前面提到了，基带信号很多时候并不适合在传输系统(<strong>信道</strong>)传输，所以需要将基带信号通过<strong>调制</strong>，转变为<strong>适合在传输系统中传输</strong>的信号。</p><p><strong>调制</strong>可以分为两大类，一类是仅仅对基带信号的波形进行变换，使它能够与信道特性相适应，变换后的信号仍然是<strong>基带信号</strong>，这类调制称为<strong>基带调制</strong>，这种基带调制是把数字信号转换为另一种形式的数字信号，因此这种过程也称为<strong>编码(coding)</strong>。另一类调制则需要使用<strong>载波(carrier)<strong>进行调制，把基带信号的频率范围搬移到较高的频段，并转换为</strong>模拟信号</strong>，信号这样就可以更好地在模拟信道中传输。经过载波调制后的信号称为<strong>带通信号</strong>(即仅在某一段频率范围内能够通过信道)，而使用载波的调制称为<strong>带通调制</strong>。(差不多理解一下概念就好了我觉得，具体怎么调制得学<strong>通信原理</strong>(真学不动啊))。</p><ol><li><p>常用的编码方式：如图2-2</p><p>​    <img src="/2021/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%89%A9%E7%90%86%E5%B1%82/7.jpg" style="zoom:30%;"></p><ul><li><p><strong>不归零制</strong>：正电平代表1，负电平代表0，并且在表示完一个码元后，<strong>电压不需要回到0</strong>。</p></li><li><p><strong>归零制</strong>： 正脉冲代表1，负脉冲代表0，表示完一个码元后，<strong>电压要回到0</strong>。</p></li><li><p><strong>曼彻斯特编码</strong>：位周期中心的向上跳代表0，位周期中序的向下跳代表1。也可以反过来定义，但通信双方要一致。</p></li><li><p><strong>差分曼彻斯特编码</strong>：在每一位的中心处始终有跳变。<strong>位开始边界有跳动代表0</strong>，而开始边界没有跳代表1。</p></li></ul></li></ol><p>从自同步能力来看，不归零制不能从信号波形本身中提取出<strong>信号时钟频率</strong>，而曼彻斯特编码具有自同步能力。</p><p>**如何实现自同步？**这里引用某一知乎作者的一个图，如下图：如果我们遮住数据，时钟和虚线的话，就根本不知道非归零码的频率是多少，假如是图示的同步时钟频率，那么编码是0100101，但如果同步时钟频率是原来的一半(<strong>在原来虚线的基础中，每两条虚线中间再切一条虚线</strong>)，编码就是00110000110011了，而曼彻斯特编码就不会有这种影响。</p><img src="/2021/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%89%A9%E7%90%86%E5%B1%82/10.png"><ol start="2"><li><p><strong>基本的带通调制方法</strong></p><p>图2-3给出了最基本的调制方法：</p><img src="/2021/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%89%A9%E7%90%86%E5%B1%82/4.jpg" style="zoom:30%;"><ul><li><strong>调幅(AM)</strong>： 即载波的振幅随基带数字信号而变化。例如，0或1分别对应于无载波或有载波输出。</li><li><strong>调频(FM)</strong>:    即载波的频率随基带数字信号而变化。例如，0或1分别对应于频率<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">f_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">f_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li><li><strong>调相(PM)</strong>:    即载波的初始相位随基带数字信号而变化。例如：0或1分别对应于相位0度或180度。</li></ul></li></ol><p>实际上的调制不仅仅是单个性质上面的调制，一般会<strong>调幅</strong>，<strong>调频</strong>，<strong>调相</strong>一起混合调制。</p><h5 id="223-信道的极限容量"><a class="markdownIt-Anchor" href="#223-信道的极限容量"></a> 2.2.3 信道的极限容量</h5><p>首先我们需要知道，<strong>任何实际的信道都是不理想的，都不可能以任意搞的速率进行传送</strong>。在传输的过程中，信号不可避免地会出现<strong>失真</strong>，但在接收端只要能从失真的波形中能够识别出原来的信号，那么对于我们的通信质量影响就很小或者说没有影响。但若<strong>失真</strong>太严重，接受端无法识别或错误识别原来的信号，则对我们的通信质量产生了影响。如图2-4:</p><img src="/2021/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%89%A9%E7%90%86%E5%B1%82/5.jpg" style="zoom:30%;"><p>从概念上，限制码元在信道上的传输速率的因素有以下两个：</p><p><strong>(1) 信道能够通过的频率范围</strong>：具体的<strong>信道所能通过的频率范围总是有限的</strong>，信号中的许多高频分量往往不能通过信道。<br>如上图的2-4，该发送信号是一种典型的矩形脉冲信号，它含有丰富的高频分量。如果信号的高频分量在传输时因为<strong>信道的频率范围限制</strong>而受到衰减，那么在接收端收到的波形前沿和后沿就变得不那么陡峭了，每一个码元所占的时间界限也不再是非常明确的，这样在接收端收到的信号波形就失去了码元的<strong>清晰界限</strong>。这种现象叫做<strong>码间串扰</strong>，更严重的码间串扰会使得本来分界清楚的一串码元变得模糊而无法识别。</p><p>需要知道的是</p><blockquote><p>在任何信道中，码元传输的速率是有上限的，传输速率超过此上限，就会出现严重的码间串扰的问题，使得接收端对码元的判决(<strong>识别</strong>)成为不可能。</p></blockquote><p>如果信道的频带越宽，也就是能够通过的信号高频分量越多，那么就可以用更高的速率传送码元而不出现码间串扰。</p><p><strong>(2) 信噪比</strong>：噪声存在于所以的电子设备和通信信道中，且是随机产生的，有时候噪声可能会很大，因此<strong>噪声会影响接收端对码元的判决甚至产生误判</strong>。但噪声影响是相对的，如果信号相对很强，噪声的影响就相对较弱，因此，需要一个量来衡量<strong>噪声的影响</strong>，所以提出了<strong>信噪比</strong>，所谓信噪比就是信号的平均功率和噪声的平均功率之比，常记为<strong>S/N</strong>，用分贝(dB)作为度量的单位。</p><p>信噪比的计算有如下公式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">信</mi><mi mathvariant="normal">噪</mi><mi mathvariant="normal">比</mi><mo stretchy="false">(</mo><mi>d</mi><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mn>10</mn><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>10</mn></msub><mo stretchy="false">(</mo><mi>S</mi><mi mathvariant="normal">/</mi><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>d</mi><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">信噪比(dB)=10 log_{10}(S/N) (dB)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">信</span><span class="mord cjk_fallback">噪</span><span class="mord cjk_fallback">比</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span></span></p><p>比如当S/N=10时，信噪比就为10dB。</p><p>1948年，信息论的创始人<strong>香农(Shannon)<strong>推导出了著名的</strong>香农公式</strong>。</p><blockquote><p>“通信的基本问题，是在消息的接收端精确地或近似地复制发送端所挑选的信息”       ----香农</p></blockquote><p>香农公式指出：<strong>信道的极限信息传输速率C</strong>是</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>=</mo><mi>W</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>S</mi><mi mathvariant="normal">/</mi><mi>N</mi><mo stretchy="false">)</mo><mi mathvariant="normal">（</mi><mi>b</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C=W log_{2}(1+S/N) （bit/s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mord cjk_fallback">（</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span></span></p><p>其实，W为信道的带宽(<strong>HZ</strong>为单位)，S为信道内所传信号的平均功率，N为信道内部的高斯噪声功率。</p><p>香农公式表明：<strong>信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高</strong>。香农公式的意义在于<strong>给出了一个天花板</strong>，一个信息传输速率的天花板。只要信息传输速率低于信道的极限信息传输速率，就一定存在某在办法去实现<strong>无差错的传输</strong>,但无论怎样精巧的编码方法，也无法超越物理定理对实际通信系统中实现的<strong>极限信息传输速率</strong>。</p><p>从以上我们得到，对于频带宽度已确定的信道，如果信噪比无法再提高了，并且码元的传输速率也达到了上限值，那么还有什么办法来提高传递的信息量呢？可以用<strong>编码</strong>的方法<strong>让每一个码元携带更多比特的信息量</strong>。</p><p>举个例子：假设我们的基带信号是  101011000110111010，如果直接进行传送，则每一个码元所携带的信息量是1bit。如果我们将信号中的每3个比特编为一个码元，3个比特共有8种不同的排列，然后我们再用不同的调制方法表示这样的每一种信号。比如用8种<strong>不同的振幅</strong>，或8种<strong>不同的频率</strong>或8种<strong>不同的相位</strong>进行调制（与上面的<strong>调幅</strong>，<strong>调频</strong>，<strong>调相</strong>对应）。</p><p>假如我们采用相位调制，相位<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">\Phi 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Φ</span><span class="mord">0</span></span></span></span>表示000，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">\Phi 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Φ</span><span class="mord">1</span></span></span></span>表示001，以此类推<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi><mn>7</mn></mrow><annotation encoding="application/x-tex">\phi 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">ϕ</span><span class="mord">7</span></span></span></span>表示111。这样，原来传送18个码元的信号就转换为了传送6个新的码元。</p><p>101 011 000 110 111 010 =<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">\Phi 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Φ</span><span class="mord">5</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">\Phi 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Φ</span><span class="mord">3</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">\Phi 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Φ</span><span class="mord">0</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mn>6</mn></mrow><annotation encoding="application/x-tex">\Phi 6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Φ</span><span class="mord">6</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mn>7</mn></mrow><annotation encoding="application/x-tex">\Phi 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Φ</span><span class="mord">7</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">\Phi 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Φ</span><span class="mord">2</span></span></span></span></p><p>如果我们<strong>以同样的速率发送码元，则相同时间内传输的信息量提高了3倍</strong>。</p><p>这里需要指明一下<strong>码元传输速率</strong>和<strong>信息传输速率</strong>的关系</p><ul><li><p><strong>波特率</strong>：指单位时间内传输的码元个数，又称<strong>码元速率</strong>，<strong>信号速率</strong>或<strong>调制速率</strong>，单位是<strong>波特</strong>或<strong>baud</strong>。如果一个波形的持续期为T秒，则波特率<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>N</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">N_{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为1/T （<strong>Baud</strong>)</p></li><li><p><strong>比特率</strong>： 又称为<strong>信息速率</strong>或<strong>数据速率</strong>，指的是每秒传输的二进制信息位数(bit数)，单位是<strong>bit/s</strong>(或<strong>bps</strong>)。</p><p>波特率和比特率的关系为</p></li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><msub><mi>N</mi><mi>b</mi></msub><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>K</mi><mo stretchy="false">(</mo><mi>b</mi><mi>p</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S=N_{b}log_{2}K (bps)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mord mathdefault">p</span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span></span></p><p>S为比特率，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>N</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">N_{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为波特率，K表示码元所取的有效离散值个数。</p><p><strong>尼奎斯特定理</strong>：在无噪声的理想情况下，低通信道上的最大码元速率，数据传输速率分别为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>N</mi><mi>b</mi></msub><mo>=</mo><mn>2</mn><mi>B</mi><mo stretchy="false">(</mo><mi>B</mi><mi>a</mi><mi>u</mi><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N_{b}=2B (Baud)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">a</span><span class="mord mathdefault">u</span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>=</mo><mn>2</mn><mi>B</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>K</mi><mo>=</mo><msub><mi>N</mi><mi>b</mi></msub><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>K</mi><mi mathvariant="normal">（</mi><mi>b</mi><mi>p</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D=2Blog_{2}K=N_{b}log_{2}K （bps)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord cjk_fallback">（</span><span class="mord mathdefault">b</span><span class="mord mathdefault">p</span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>N</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">N_{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>: 波特率bps<br>D：介质的最大数据传输速率bps；<br>B：介质的带宽Hz；<br>K：码元所取的有效离散值个数</p><h3 id="3-物理层下面的传输媒体"><a class="markdownIt-Anchor" href="#3-物理层下面的传输媒体"></a> 3 物理层下面的传输媒体</h3><p>前面提到：</p><blockquote><p>现有的计算机网络中的硬件设备和传输媒体的种类非常繁多，而通信手段也有很多不同的方式，<strong>物理层的作用正是要尽可能地屏蔽掉这些传输媒体和通信手段的差异和复杂性</strong>，使得物理层上面的数据链路层感觉不到这些差异，这样就可以使得数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体和通信手段是什么，大大降低了复杂性。</p></blockquote><p>尽管如此，但是在物理层学习中，还是很有必要了解物理层下面的传输媒体(仅仅是了解一下,深入我也不懂呀/狗头)。</p><p><strong>传输媒体</strong>也称为<strong>传输介质</strong>或<strong>传输媒介</strong>，就是在数据传输系统中在发送器和接收器之间的物理通路。传输媒体可分为两大类，<strong>导引型传输媒体</strong>和<strong>非导引型传输媒体</strong>。</p><p>在导引型传输媒体中，电磁波被导引沿着固体媒体(如光纤或铜线)传播，而非导引型传输媒体就是指<strong>自由空间</strong>。在非导引型传输媒体中媒体中电磁波的传播常称为<strong>无线传输</strong>。</p><h4 id="31-导引型传输媒体"><a class="markdownIt-Anchor" href="#31-导引型传输媒体"></a> 3.1 导引型传输媒体</h4><ul><li><p><strong>双绞线</strong>：又称<strong>双扭线</strong>，分为屏蔽双绞线和非屏蔽双绞线。成本低，易于安装，高容量，抗干扰。</p></li><li><p><strong>同轴电缆</strong></p></li><li><p><strong>光纤</strong>：利用光导纤维传递光脉冲来进行通信。</p></li></ul><h4 id="32-非导引型传输媒体"><a class="markdownIt-Anchor" href="#32-非导引型传输媒体"></a> 3.2 非导引型传输媒体</h4><p><strong>无线传输介质</strong>可以利用无线电波在自由空间的传播较快地实现多种通信。</p><h3 id="4-信道复用技术"><a class="markdownIt-Anchor" href="#4-信道复用技术"></a> 4 信道复用技术</h3><p><strong>复用(multiplexing)<strong>是通信技术中的基本概念。在计算机网络中的信道广泛地使用各种复用技术。如图2-13(a)表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">A_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">B_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">C_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>分别使用一个单独的信道和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">A_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">B_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">C_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>进行通信，一共就需要三个信道。如果我们在发送端使用一个</strong>复用器</strong>，就可以让<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">A_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">B_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">C_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>合起来使用一个共享信道进行通信。在接收端再使用<strong>分用器</strong>，把传输的信息分别送到<strong>相应</strong>的终点。如图2-13(b)。</p><p>最基本的复用是<strong>频分复用FDM(Frequency Division Multiplexing)<strong>和</strong>时分复用(Time Division Multiplexing)</strong></p><img src="/2021/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%89%A9%E7%90%86%E5%B1%82/9.jpg" style="zoom:30%;"><h4 id="41-频分复用"><a class="markdownIt-Anchor" href="#41-频分复用"></a> 4.1 频分复用</h4><p><strong>频分复用</strong>指的是用户在分配到一定频带后，在通信过程中自始至终都占用这个频带。<strong>频分复用的所有用户在同样的时间占用不同的带宽资源</strong>。如图2-14(a)</p><img src="/2021/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%89%A9%E7%90%86%E5%B1%82/2.jpg" style="zoom:30%;"><h5 id="411-波分复用-wdm-wavelength-division-multiplexing"><a class="markdownIt-Anchor" href="#411-波分复用-wdm-wavelength-division-multiplexing"></a> 4.1.1 波分复用 WDM (Wavelength Division Multiplexing)</h5><p>波分复用就是<strong>光的频分复用</strong>。将8个波长很接近的光载波经过<strong>光复用器</strong>，就可以在一根光纤中传输了，再通过<strong>光分用器</strong>就可以到达对应的终点。</p><img src="/2021/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%89%A9%E7%90%86%E5%B1%82/11.png" style="zoom: 80%;"><h4 id="42-时分复用"><a class="markdownIt-Anchor" href="#42-时分复用"></a> 4.2 时分复用</h4><ul><li><strong>时分复用</strong>将时间划分为一段段等长的<strong>时分复用帧(TDM帧)</strong>。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙。TDM信号也称为<strong>等时</strong>信号。<strong>时分复用的所有用户在不同的时间里占用同样的频带宽度</strong>。如图2-14(b)</li></ul><h5 id="421-时分复用造成了线路资源的浪费"><a class="markdownIt-Anchor" href="#421-时分复用造成了线路资源的浪费"></a> 4.2.1 时分复用造成了线路资源的浪费</h5><p>使用时分复用系统传送计算机数据时，因为<strong>计算机数据的突发性质</strong>，用户对分配到的子信道的利用率一般是不高的。表现为当用户在某一段时间暂时无数据传输时，就只能让已经分配到手的子信道空闲着，<strong>其他用户也无法使用这个空闲的线路资源</strong>。如图2-15，可以看到，在每一个TDM帧中，都存着这某一段时间信道是空闲着的，因此造成了<strong>线路资源的浪费</strong>。</p><img src="/2021/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%89%A9%E7%90%86%E5%B1%82/1.jpg" style="zoom: 40%;"><h5 id="422-统计时分复用stdm-static-tdm"><a class="markdownIt-Anchor" href="#422-统计时分复用stdm-static-tdm"></a> 4.2.2 统计时分复用STDM （Static TDM)</h5><p>时分复用造成了线路资源的浪费，STDM是一种改进的时分复用，能明显地提高信道的利用率。<strong>集中器</strong>常使用这种统计时分复用，如图2-16。一个使用统计时分复用的集中器连接4个低速用户，然后将它们的数据<strong>集中起来</strong>通过高速线路发送到一个远处计算机。</p><img src="/2021/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%89%A9%E7%90%86%E5%B1%82/8.jpg" style="zoom: 50%;"><p>STDM之所以能提高信道的利用率，<strong>原因</strong>是STDM帧<strong>不是固定分配时隙</strong>，而是<strong>按需动态地分配时隙</strong>。各用户有了数据就随时发往集中器的输入缓存，然后集中器按顺序依次扫描输入缓存，把缓存中的输入数据放入STDM帧中，当一个帧的数据放满了，就发送出去。</p><h4 id="43-码分复用"><a class="markdownIt-Anchor" href="#43-码分复用"></a> 4.3 码分复用</h4><p><strong>码元复用CDM(Code Division Multiplexing)<strong>也是一种共享信道的方法。更常用的名词是</strong>码分多址CDMA(Code Division Multiple Access)</strong>。每一个用户可以在<strong>同样的时间</strong>使用<strong>同样的频带</strong>进行通信。</p><p>如何实现这种同时同频带通信而不相互干扰？<strong>各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰</strong>。</p><p>在CDMA中，每一比特时间再划分为m个短的间隔，称为<strong>码片(chip sequence)</strong>。一个站如果要发送比特1，则发送给它自己的m bit码片序列，如果要发送比特0，则发送该码片序列的二进制反码。</p><p>例如，指派给S站的8bit 码片序列为00011011.当S发送比特1时，它就发送序列00011011，而当S发送比特0时，就发送11100100。为了方便，我们按照惯例将码片中的0写为-1,1写为+1，因此S站的码片序列是(-1 -1 -1 +1 +1 -1 +1 +1)。</p><p>CDMA系统的一个重要特点就是每个站分配的码片序列不仅必须各不相同，而且还必须互相<strong>正交(orthogonal)</strong>。在实用的系统中使用<strong>伪随机码序列</strong>。</p><p>令向量S表示站S的码片向量，令T表示其他任何站的码片向量。两个不同站的码片序列正交，就是向量S和T的规格化<strong>内积(inner product)都是0</strong>。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>∗</mo><mi>T</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>m</mi><mo stretchy="false">)</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>S</mi><mi>i</mi></msub><msub><mi>T</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">S*T=(1/m)\sum_{i=1}^NS_{i}T_{i}=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.106005em;vertical-align:-1.277669em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p><p>例如向量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>为(-1 -1 -1 +1 +1 -1 +1 +1) 设向量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>为(-1 -1 +1 -1 +1 +1 +1 -1)把向量S和T的各分量带入上面公式可得出这两个码片序列是正交的。另外：</p><ul><li><p><strong>向量S和各站码片的反码的向量的内积也是0</strong>。</p></li><li><p><strong>任何一个码片向量和该码片向量自己的规格化内积都是1</strong>。</p></li><li><p><strong>一个码片向量和该码片反码的向量的规格化内积值是-1</strong>。</p><p>由上面公式可以得出，证明略。</p><p>举一个CDMA工作原理的例子，先假定有一个X站要接收S站发送的数据，X站就必须先知道S站<strong>独有的码片序列</strong>，X站用它<strong>已知的S站的码片序列与接收到的未知信号进行求内积</strong>的运算。因为X站接收到的未知信号是各个站(包括S站)发送的码片序列之和。又由上面知道，<strong>向量S和除S站外各站码片的内积是0</strong>。所以内积得到的结果是，<strong>所有其他站的信号都被过滤掉(因为内积为0)，而只剩下S站发送的信号</strong>，当S站发送比特1时，在X站计算的内积的结果就是+1，当S站发送比特0时，内积的结果就是-1.所以根据内积的结果，就可以判断S站发送的是0还是1。</p></li></ul><h3 id="5-宽带接入技术"><a class="markdownIt-Anchor" href="#5-宽带接入技术"></a> 5 宽带接入技术</h3><p>用户要连接到互联网，必须先连接到某个ISP，以便获得上网所需要的OP地址。这一部分粗略讲述一些有线宽带接入技术。</p><ul><li>ADSL技术： <strong>非对称数字用户线ADSL(Asymmetric Digtal Subscriber Line）</strong> 用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带数字业务。ADSL技术把0~4kHz低端频谱留给传统电话使用，而吧原来没有被利用的高端频谱留给用户上网使用。</li><li>FTTx技术</li></ul><img src="/2021/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%89%A9%E7%90%86%E5%B1%82/12.png" style="zoom:67%;"><h3 id="6-总结"><a class="markdownIt-Anchor" href="#6-总结"></a> 6 总结</h3><p>关于物理层的学习就到这，总结一下：</p><p>我们首先提到了</p><blockquote><p>现有的计算机网络中的硬件设备和传输媒体的种类非常繁多，而通信手段也有很多不同的方式，<strong>物理层的作用正是要尽可能地屏蔽掉这些传输媒体和通信手段的差异和复杂性</strong>，使得物理层上面的数据链路层感觉不到这些差异，这样就可以使得数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体和通信手段是什么，大大降低了复杂性。</p></blockquote><p>物理层是最底的一层，无论上层协议如何设计，到了物理层都需要通过<strong>线路传输比特流进而实现通信</strong>，所以紧接着了解了<strong>数据通信的一些基本知识</strong>，首先<strong>数据通信系统的模型</strong>，由源点，发送器，传输系统，接收器和终点五部分组成了模型，然后学习了通信交互的三种基本方式，<strong>单向通信</strong>，<strong>半双工通信</strong>，<strong>全双工通信</strong>。又因为源点产生的信号大多时候并不适合在传输系统中传输，我们我们需要对源点产生的信号进行<strong>调制</strong>。在有了通信的一些基本概念之后，我们讨论了信道的极限容量，提出了衡量信道传输速率的<strong>比特率</strong>和<strong>波特率</strong>，学习了<strong>香农公式</strong>，香农公式告诉我们一个天花板，告诉我们无论怎样精巧的编码方法，也无法超越物理定理对实际通信系统中实现的<strong>极限信息传输速率</strong>。</p><p>传输媒体主要分为<strong>导引型传输媒体</strong>和<strong>非导引传输媒体</strong>。</p><p>然后我们学习了信道**复用(multiplexing)**技术</p><ul><li>频分复用：频分复用的所有用户在<strong>同样的时间</strong>占用<strong>不同的带宽资源</strong></li><li>时分复用：时分复用的所有用户在<strong>不同的时间</strong>里占用<strong>同样的频带宽度</strong></li><li>码分复用：每一个用户可以在<strong>同样的时间</strong>使用<strong>同样的频带</strong>进行通信。</li></ul><p>.应当注意到这三种复用的使用在<strong>时间</strong>和<strong>频带</strong>上的差异。</p><p>最后简单介绍了ADSL和FTTX宽带接入技术。</p><p>感觉这一层内容更深入的学需要**《通信原理》**中相关的知识(学不会啊----------)</p><p>本篇博客只是<strong>自己</strong>对课程学习的一些笔记和总结，大部分内容参考自**《计算机网络》**第七版，谢希仁编著。</p><p>如有出错(非常大可能会出错哈哈)，欢迎指正！</p><p>完…</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-物理层的基本概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-物理层的基本概念&quot;&gt;&lt;/a&gt; 1 物理层的基本概念&lt;/h3&gt;
&lt;h4 id=&quot;需要物理层需要做些什么&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#需要物理层需要做些什么&quot;&gt;&lt;/a&gt; 需要物理层需要做些什么？&lt;/h4&gt;
&lt;p&gt;需要指出，物理层考虑的是怎样才能在连接&lt;strong&gt;各种计算机的传输媒体&lt;/strong&gt;上&lt;strong&gt;传输数据比特流&lt;/strong&gt;，而不是指某种具体的传输媒体。&lt;/p&gt;
&lt;p&gt;可以说，&lt;strong&gt;物理层提供了一层抽象&lt;/strong&gt;，上层的数据链路层和网络层&lt;strong&gt;只需要知道物理层传输的是比特流&lt;/strong&gt;，而不去考虑物理层用何种方式去传输比特流。&lt;/p&gt;
&lt;p&gt;为什么要提供这样的一层抽象？因为现有的计算机网络中的硬件设备和传输媒体的种类非常繁多，而通信手段也有很多不同的方式，&lt;strong&gt;物理层的作用正是要尽可能地屏蔽掉这些传输媒体和通信手段的差异和复杂性&lt;/strong&gt;，使得物理层上面的数据链路层感觉不到这些差异，这样就可以使得数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体和通信手段是什么，大大降低了复杂性。&lt;/p&gt;
&lt;p&gt;此外，数据在计算机内部多采用&lt;strong&gt;并行传输方式&lt;/strong&gt;，而数据在通信线路上的传输方式一般都是&lt;strong&gt;串行传输&lt;/strong&gt;，也就是逐个比特按照时间顺序传输，因此，物理层还要完成&lt;strong&gt;传输方式的转换&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://luo41.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://luo41.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="物理层" scheme="https://luo41.top/tags/%E7%89%A9%E7%90%86%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络数据链路层</title>
    <link href="https://luo41.top/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>https://luo41.top/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
    <published>2021-06-05T04:13:13.000Z</published>
    <updated>2021-06-13T03:35:53.167Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据链路层的设计初衷"><a class="markdownIt-Anchor" href="#数据链路层的设计初衷"></a> 数据链路层的设计初衷</h3><p>我们知道物理层的线路上传输的是我们的<strong>比特流</strong>，物理层的线路由传输介质与通信设备组成。比特流在物理线上的传输肯定会存在误差。这样我们就引入了数据链路层在物理层之上，在数据链路层中采用<strong>差错检测</strong>，<strong>差错控制</strong>和<strong>流量控制</strong>等方法，向网络层提高<strong>高质量</strong>的数据传输服务。</p><p>注意这里说的是<strong>高质量</strong>，而不是<strong>可靠</strong>，数据传输的<strong>可靠仍然要靠我们传输层的TCP协议实现</strong>。数据链路层提供了<strong>差错检测机制</strong>，相对于物理层来说，提高了数据传输的质量。</p><p>这样<strong>数据链路层</strong>就可以看成了<strong>网络层</strong>和<strong>物理层</strong>之间的一层<strong>抽象</strong>，属于计算机网络中的低层。</p><span id="more"></span><p>下面我们通过一个例子看一下<strong>数据链路层</strong>在主机通过互联网进行通信时所处的地位。如图：</p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/1.jpg" style="zoom:20%;"><p>图3-1(a)从主机的角度表示了H1主机向H2主机发送数据报时，中间经过了三个路由器R1,R2,R3，最后数据到达H2。</p><p>图3-1(b)从数据报经过的协议的角度来看数据的流动，主机H1和H2都有完整的五层协议栈，路由器在转发分组时使用的协议栈只有三层。主机H1在应用层将数据报一层一层向下交付直到物理层。数据进入路由器后先从物理层上到网络层，在<strong>路由器的转发表</strong>中<strong>找到下一跳的地址</strong>后，再下到物理层转发出去，到下一个路由器。主机H2收到数据报后，从物理层往上交付给应用层。</p><p>图3-2是我们常用的研究数据链路层的问题时用的图形，在许多情况下我们只关心在协议栈中水平方向的各数据链路层，<strong>想象数据在数据链路层就是简单地从左往右水平传送的</strong>。</p><p>数据链路层使用的信道主要有以下两种类型：</p><ul><li><p><strong>点对点信道</strong>：使用一对一的点对点通信方式的信道。</p></li><li><p><strong>广播信道</strong>：使用一对多的广播通信方式。</p></li></ul><h3 id="链路数据链路与帧"><a class="markdownIt-Anchor" href="#链路数据链路与帧"></a> 链路，数据链路与帧</h3><h4 id="链路"><a class="markdownIt-Anchor" href="#链路"></a> 链路</h4><p>所谓<strong>链路(link)<strong>就是从一个结点到</strong>相邻结点</strong>的一段<strong>物理线路</strong>(有线或无线)，而<strong>中间没有任何其他的交换结点</strong>。在主机间进行数据通信时，之间的通信路径往往要经过<strong>许多段链路</strong>，<strong>链路</strong>只是一条路径的<strong>组成部分</strong>。又称<strong>物理链路</strong></p><h4 id="数据链路"><a class="markdownIt-Anchor" href="#数据链路"></a> 数据链路</h4><p><strong>数据链路</strong>则不仅仅包括一条物理线路，它还包括了数据传送时起控制作用的<strong>协议</strong>。把实现这些<strong>协议</strong>的硬件和软件加到链路上，就构成了<strong>数据链路</strong>。又称<strong>逻辑链路</strong>。</p><p>可以简单地理解为，<strong>数据链路</strong>就是<strong>链路加上必要的通信协议</strong>。</p><h4 id="帧"><a class="markdownIt-Anchor" href="#帧"></a> 帧</h4><p><strong>帧</strong>是数据链路层的协议数据单元。</p><p>一个<strong>很重要的关系</strong>需要我们知道的是：网络层传输的是<strong>数据报</strong>，而数据链路层传输的是<strong>数据帧</strong>，而物理层传输的是<strong>比特流</strong>。数据链路层将网络层传输的<strong>数据报</strong>装入<strong>帧</strong>中，而物理层将<strong>帧</strong>以<strong>比特流</strong>的形式通过物理的传输线路在<strong>物理网络</strong>中传输。</p><p>网络层和数据链路层，物理层的数据传输关系大概可以用下图描述：</p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/2.jpg" style="zoom:20%;"><h3 id="三个基本问题"><a class="markdownIt-Anchor" href="#三个基本问题"></a> 三个基本问题</h3><p>数据链路层协议有很多，但有共同的<strong>三个基本问题</strong>：<strong>封装成帧</strong>，<strong>透明传输</strong>，<strong>差错检测</strong>。</p><h4 id="封装成帧"><a class="markdownIt-Anchor" href="#封装成帧"></a> 封装成帧</h4><p><strong>封装成帧</strong>(framing)就是在一段数据的前后分别添加<strong>首部</strong>和<strong>尾部</strong>，构成一个<strong>帧</strong>。</p><p>接收端在收到物理层上交的比特流后，可以根据<strong>首部</strong>和<strong>尾部</strong>的标记，判断出<strong>帧的开始和结束</strong>，我们又称为<strong>帧定界</strong>。此外，首部和尾部还包括了许多必要的<strong>控制信息</strong>。</p><p>在上面我们提到了网络层传输的<strong>IP数据报</strong>，而数据链路层传输的是<strong>数据帧</strong>，但网络层的IP数据报传送到数据链路层上只成为<strong>数据帧</strong>的<strong>数据部分</strong>，在需要再数据部分的前面和后面分别加上<strong>数据首部</strong>和<strong>数据尾部</strong>，构成一个完整的帧。一个<strong>数据帧</strong>=数据首部+数据部分+数据尾部，关系图如3-4</p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/3.jpg" style="zoom:20%;"><p>为了提高帧的传输效率，应当规定<strong>帧的数据部分长度应该尽可能地大于首部和尾部的长度</strong>。尽管如此，帧的数据部分也不可能无数长，每一种链路层协议都规定了所能传送的帧的<strong>数据部分长度上限—最大传送单元MTU</strong>(Maximum Transfer Unit)。</p><p>首部和尾部如何做到<strong>帧定界</strong>呢？当数据是可打印的ASCII码时，我们就可以使用特殊的<strong>帧定界符号</strong>，大家统一规定了某个符号一出现就表示是帧的开始或结束。比如说我们规定控制字符<strong>SOH</strong>(Start Of Header)表示帧的首部开始，另一控制字符<strong>EOT</strong>(End Of Transmission)表示帧的结束。注意SOH和EOT都是控制字符的名称，而不是三个字符。</p><p>控制字符进行<strong>帧定界</strong>的方法举例：</p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/4.jpg" style="zoom:20%;"><p><strong>帧定界符</strong>在数据传输出现差错时，可以起到作用。假定发送端在尚未发送完一个帧是突然出故障，中断了发送。随后很快恢复正常，于是<strong>重新从头开始</strong>发送刚才为发送完毕的帧。因为使用了帧定界符，接收端知道了前面收到的这个帧是不完整的，选择丢弃。后面的帧是完整的，选择收下。</p><h4 id="透明传输"><a class="markdownIt-Anchor" href="#透明传输"></a> 透明传输</h4><p><strong>透明传输</strong>，这里提到的**“透明”<strong>是一个很重要的术语。表示</strong>某一实际存在的事物但看起来却好像不存在一样**，类似于一个100%透明的玻璃，实际存在，但正常情况你看不见，除非你猛得一头撞上了&quot;玻璃&quot;。在数据链路层<strong>透明传送数据</strong>的意思就是：无论什么样的比特组合的数据，都能够按照原来照样没有差错地通过这个数据链路层，不存在有什么妨碍他们传输的东西。</p><p>封装成帧看起来十分的<strong>合理和<s>完美</s></strong>。但我们其实违背了<strong>透明传输</strong>，我们细想，万一我们传输的数据当中就包括了我们的<strong>帧定界符</strong>呢？那样接收端怎么判断这个帧定界是数据部分的还是数据首部或尾部的？如果按照一收到<strong>帧定界符</strong>就判断帧结束了，那么一旦数据部分包括了帧定界符，数据链路层就会<strong>错误地</strong>以为找到了帧的边界，把部分帧收下，而把剩下那部分的数据帧丢弃了。如图3-6所示：</p><p>而如图3-6，帧的传输就明显不是透明传输，因为数据帧中碰巧<strong>出现了帧定界符EOT</strong>。</p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/5.jpg" style="zoom:20%;"><p>如何解决这种<strong>误会</strong>呢？</p><p>答案是增加一个转义字符<strong>ESC</strong>。具体的方法是：发送端的数据链路层中的数据出现控制字符SOH和EOT，则在前面插入一个转义字符ESC，表明这个控制字符表示的是<strong>它本身的意思</strong>，而不是什么<strong>帧定界符</strong>。而在接收方的数据链路层，在把数据送往网络层之前<strong>删除</strong>这个插入的转义字符。这种方法我们又称作<strong>字节填充(byte stuffing)<strong>或</strong>字符填充(character stuffing)</strong>。</p><p>可能你又想到了，那么如果ESC表示的是它本身的意思呢？很简单，那么就在ESC前面再插入一个ESC(<strong>套娃成功</strong>)，当接收端连续收到两个转义字符时，就删除其中前面的那一个。图3-7表示用字节填充法解决透明传输的问题：</p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/6.jpg" style="zoom:20%;"><h4 id="差错检测"><a class="markdownIt-Anchor" href="#差错检测"></a> 差错检测</h4><p>上面提到了物理层比特流在物理网传输的过程中难免会出现差错，而<strong>数据链路层想向网络层提供&quot;更高质量&quot;的数据传输</strong>，实现的手段就是<strong>差错检测</strong>(更准确地说<strong>比特差错检测</strong>）。</p><h5 id="比特差错"><a class="markdownIt-Anchor" href="#比特差错"></a> 比特差错</h5><p>比特在传输过程中可能会产生差错：1可能会变成0,0也可能变成1，这就叫做<strong>比特差错</strong>。比特差错是传输差错中的一种，在差错检测这一节，差错指的一般是<strong>比特差错</strong>。</p><h5 id="循环冗余检验"><a class="markdownIt-Anchor" href="#循环冗余检验"></a> 循环冗余检验</h5><p>在一段时间内，传输错误的比特占所传输比特总述的比率称为<strong>误码率BER(Bit Error Rate)</strong>。比如说误码率为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>10</mn></mrow></msup></mrow><annotation encoding="application/x-tex">10^{-10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>表示平均传送<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">10^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>个比特就会出现一个比特的差错。在计算机网络传输数据时，需要采用各种差错检测的措施，目前在数据链路层广泛使用的是**循环冗余检验CRC(Cyclic Redundancy Check)**的检错技术。</p><p>下面我们通过一个简单的例子说明<strong>循环冗余检验的原理</strong>：</p><p>在发送端，我们将数据分成组，假定每组为k个比特。现假定待传送的数据M=101001(k=6)。CRC运算就是在数据M的后面添加供差错检测用的<strong>n位冗余码</strong>，然后构成一个帧(k+n)位，发送出去。</p><p>这n位的<strong>冗余码</strong>如何得出？我们用的是先用二进制的<strong>模2运算</strong>进行<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>乘M的操作，相当于M左移n位，也就是在M的后面添加n个0。得到的(k+n)位的数用<strong>模2除法</strong>除以收发双方事先约定的长度为(n+1)位除数P，得出商为Q而余数为R(n位，比P少一位)。这个余数R就作为<strong>冗余码</strong>拼接在数据M的后面发送出去。</p><p>这种为了进行检错而添加的冗余码也常称为<strong>帧检验序列FCS(Frame Check Sequence)</strong>。</p><p>举个例子：我们假定除数P为1101(n=3)，M=101001，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>乘M得到101001000 ，用<strong>模2除法</strong>除以1101，得到商Q=110101(并没有什么实际用处)，余数R=001。所以我们最终发送的帧为 101001001，一共k+n=9位。</p><p>关于<strong>模2除法</strong>，<a href="https://blog.csdn.net/qq_33411687/article/details/82593466">已经有博主讲得挺好的了</a>，就不再赘述。</p><p>这里区分一下<strong>循环冗余检验</strong>和<strong>帧检验序列</strong>，这两个并不是一个概念,CRC是一种<strong>检错的方法</strong>，FCS是添加在传输数据后面的<strong>冗余码</strong>，通过其他的检错方法也可以得到FCS。可以说，得到FCS是我们要的目的，而CRC只是我们达到目的的一种手段罢了。(<strong>小丑CRC</strong>)</p><h5 id="无差错传输和可靠传输"><a class="markdownIt-Anchor" href="#无差错传输和可靠传输"></a> 无差错传输和可靠传输</h5><p>这里需要强调一下，在数据链路层<strong>仅仅</strong>使用CRC差错检测技术，只能做到对<strong>帧的无差错接受</strong>。什么叫<strong>无差错接受</strong>，就是说我们接受到了的帧，我们都能以非常接近于1的概率认为这些帧在传输过程中没有产生差错(指<strong>比特出错</strong>)。而那些传输过程中出现差错(也是指<strong>比特差错</strong>)的帧，我们会丢弃，即这些帧不会被接受。</p><p>但<strong>可靠传输</strong>要求的是<strong>数据链路层的发送端发送什么，在接收端就接受到什么</strong>。</p><p>我的理解是，<strong>无差错接受</strong>针对的是到达了目的主机的帧，我对帧进行检查，这个检查只是针对<strong>比特差错</strong>的，就是判断有没有1变成0,0变成1的情况，没有我就收下。但是传输错误不仅仅包括比特错误，还包括有些<strong>帧丢失</strong>了，<strong>帧重复</strong>了，<strong>帧失序</strong>了，那样无差错接受就<strong>无能为力</strong>了。就需要上层协议去处理了，所以<strong>可靠传输</strong>是上层协议TCP去搞的。</p><p>还是那句话，<strong>数据链路层</strong>只是尽力提供**“更高质量”<strong>的数据传输。“更高质量”体现在现在</strong>比特错误<strong>我能处理了，但我还是不能</strong>完全可靠**。</p><h3 id="点对点信道的数据链路层-和-点对点协议-ppp"><a class="markdownIt-Anchor" href="#点对点信道的数据链路层-和-点对点协议-ppp"></a> 点对点信道的数据链路层 和 点对点协议 PPP</h3><h4 id="点对点信道的数据链路层"><a class="markdownIt-Anchor" href="#点对点信道的数据链路层"></a> 点对点信道的数据链路层</h4><p>以AB两主机进行通信为例子，点对点信道的数据链路层在进行通信时的主要步骤为：</p><ol><li><strong>A</strong>的数据链路层把网络层交下来的IP数据报添加首部和尾部<strong>封装成帧</strong>。</li><li><strong>A</strong>把封装好的帧发送给主机B的数据链路层。</li><li><strong>B</strong>检查数据链路层收到的帧无比特差错，则从收到的帧中提取出IP数据报交给上面的网络层；否则丢弃这个帧。</li></ol><h4 id="点对点协议ppp"><a class="markdownIt-Anchor" href="#点对点协议ppp"></a> 点对点协议PPP</h4><p><strong>点对点协议 PPP(Point-to-Point Protocol)<strong>是</strong>点对点的链路</strong>目前使用得最广泛的<strong>数据链路层协议</strong>。</p><h5 id="ppp协议的特点"><a class="markdownIt-Anchor" href="#ppp协议的特点"></a> PPP协议的特点</h5><p>互联网用户通常都要连接到某个ISP才能接入到互联网。PPP协议就是用户计算机和ISP进行通信时所使用的数据链路层协议，如图3-9：</p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/7.jpg" style="zoom:20%;"><p>PPP协议需要满足的<strong>一些需求</strong>：</p><ol><li><strong>简单</strong>：PPP基本的原理很简单：发送方发送帧，接收方收到一个帧，进行CRC检验，无比特差错，收下，否者丢弃，<strong>什么都不做</strong>。</li><li><strong>封装成帧</strong>：PPP协议是数据链路层，必然逃不过数据链路层三个基本问题中的封装成帧。</li><li><strong>透明性</strong>：PPP协议是数据链路层，必然逃不过数据链路层三个基本问题中的透明传输。</li><li><strong>多种网络层协议</strong>：PPP协议必须能够在<strong>同一条物理链路</strong>上同时支持<strong>多种网络层协议</strong>。向上层提供更多的支持。</li><li><strong>多种类型链路</strong>：PPP协议必须能够在<strong>多种类型的链路</strong>上运行。比如串行链路，并行链路，同步链路，异步链路等。</li><li><strong>差错检测</strong>： 数据链路层的三个基本问题。</li><li><strong>检测连接状态</strong>：PPP协议必须具有一种机制能够及时自动检测出链路是否处于正常工作状态。</li><li><strong>最大传送单元</strong>：前面提到每一种链路层协议都规定了MTU，PPP作为链路层协议也肯定得有</li><li><strong>网络层地址协商</strong>： 不太懂</li><li><strong>数据压缩协商</strong>：</li><li><strong>只支持全双工链路</strong></li></ol><h5 id="ppp协议的组成"><a class="markdownIt-Anchor" href="#ppp协议的组成"></a> PPP协议的组成</h5><p>PPP协议有三个组成部分：</p><ul><li><strong>将IP数据报封装到串行链路的方法</strong>。IP数据报是数据链路层<strong>帧的数据部分</strong>，需要有封装到帧里面的方法。</li><li>一个用来建立，配置和测试数据链路连接的<strong>链路控制协议LCP(Link Control Protocol)</strong>。通信双方可以协商一些选项。</li><li>一套<strong>网络控制协议NCP(Network Control Protocol)</strong>，其中的每一个协议支持不同的网络层协议。</li></ul><h5 id="ppp协议的帧格式"><a class="markdownIt-Anchor" href="#ppp协议的帧格式"></a> PPP协议的帧格式</h5><p>PPP的帧格式如图：</p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/8.jpg" style="zoom:20%;"><p>如图所示，<strong>各字段的意义</strong>为：</p><ul><li><p>PPP帧的首部和尾部分别为四个字段和两个字段。首部的第一个字段和尾部的第二个字段都是标志字段F(Flag),规定为0x7E，表示一个帧的开始或结束，也就是我们前面说的<strong>帧定界符</strong>。</p></li><li><p>首部中的地址字段<strong>A</strong>规定为0xFF,控制字段<strong>C</strong>为0x03，这两个字段到如今也没什么特殊定义。</p></li><li><p>PPP首部的第四个字段是2字节的<strong>协议字段</strong>。当协议字段为0x0021时，PPP帧的信息字段为<strong>IP数据报</strong>。为0xC021,则信息字段为PPP链路控制协议LCP的数据，而0x8021表示这是网络层的控制数据。</p></li><li><p>信息字段的长度可变，不超过1500字节。</p></li><li><p>尾部中的第一个字段(2字节)，是使用<strong>CRC</strong>的帧检验序列<strong>FCS</strong>。</p></li></ul><p><strong>字节填充</strong>：在透明传输中我们知道，当数据帧中有字段出现和标志字段(<strong>帧定界符</strong>)意义的比特(这里是0x7E)组合，必须在该字段前面插入<strong>转义符</strong>，表示<strong>这不是帧定界符</strong>。PPP协议规定了如下所述的填充方法：</p><ul><li>把数据帧字段中出现的每一个0x7E字节转变成2字节序列(0x7D,0x5E)</li><li>若数据帧中出现一个0x7D的字节，也就是出现了和转义字符一样的比特组合，则把0x7D转变为2字节序列(0x7D,0x5D)</li><li>若信息字段中出现 ASCII 码的控制字符(即数值小于 0x20 的字符）则在该字符前面要加入一个 0x7D 字节，同时将该字符的编码加以改变。(说实在，感觉好复杂，<strong>相信用不着</strong>嘿嘿)</li></ul><p>在接收端进行与发送端相反的变换，<strong>正确恢复出原来的信息</strong>。</p><p><strong>零比特填充</strong>：</p><p>具体做法：在发送端，扫描数据帧，只要发现有5个连续1，则立即填入一个0。因此经过这种<strong>零比特填充</strong>后的数据，保证在信息字段中不会出现6个连续1。为什么不能出现6个连续的1？因为我们PPP协议的<strong>帧定界符</strong>为0x7E(也就是01111110)，所以保证了数据帧中不会出现0x7E字段。如图：</p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/9.jpg" style="zoom:20%;"><h5 id="ppp协议的工作状态"><a class="markdownIt-Anchor" href="#ppp协议的工作状态"></a> PPP协议的工作状态</h5><p>PPP协议的工作状态可以用下图来描述</p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/10.jpg" style="zoom:20%;"><p>PPP链路的起始或终止状态永远是图中的<strong>链路静止</strong>，这时在用户个人电脑和ISP的路由器上不存在<strong>物理层的链接</strong>。</p><p>当用户个人电脑呼叫路由器时，路由器能够检测到信号，<strong>物理层建立连接</strong>，PPP进入了<strong>链路建立</strong>状态，其目的是建立链路层的LCP连接。这时LCP开始<strong>协商</strong>一些<strong>配置选项</strong>，即发送LCP的<strong>配置请求帧</strong>。这是一个PPP帧，其PPP帧的协议字段置为LCP对应的代码，<strong>信息字段</strong>包含特定的<strong>配置请求</strong>。</p><p>链路的另一端可以发送以下几种响应中的一种：</p><ul><li><strong>配置确认帧(Configure-Ack)</strong>: 所有配置选项都接受。</li><li><strong>配置否认帧(Configure-Nak)</strong>: 所有选项都理解但不能接受</li><li><strong>配置拒绝帧(Configure-Reject)</strong>: 选项有的无法识别或不能接受，还需要协商。</li></ul><p>LCP<strong>配置选项</strong>包括了比如链路上的最大帧长，所要使用的<strong>鉴别协议</strong>，以及不使用PPP帧中的<strong>地址和控制字段</strong>，因为这两个字段前面提到了，暂时没有什么特殊的意思，所以双方规定了遇到这两个字段就忽略掉。</p><p>协商结束后双方就建立了<strong>LCP链路</strong>，接着就进入了“<strong>鉴别</strong>”状态。在这一状态下，只允许传送LCP协议的分组，鉴别协议的分组以及监测链路质量的分组。鉴别身份失败，则转到<strong>链路终止</strong>状态，鉴别成功，则进入<strong>网络层协议</strong>状态。</p><p>在<strong>网络层协议</strong>状态，PPP链路的两端的网络控制协议NCP<strong>根据网络层的不同协议</strong>互相交换网络层特定的网络控制分组。这个步骤保证我们前面提到的PPP所需要满足的一些需求的第四点：<strong>支持多种网络层协议</strong>。使得PPP协议的两端的网络层可以运行不同的网络层协议，但仍然可以使用同一个PPP协议进行通信。</p><p>当网络层配置完毕后，链路就进入了可以进行数据通信的<strong>链路打开</strong>状态。链路的两个PPP端点可以彼此向对方发送分组。两个PPP端点还可以通过发送<strong>回送请求LCP</strong>分组和<strong>回送回答LCP</strong>分组，以检查链路的状态。</p><p>数据传输结束后，可以由链路的一端发出<strong>终止请求LCP分组</strong>请求终止链路连接，在收到对方发来的<strong>终止确认LCP分组</strong>后，转到链路终止状态。链路出现故障，也会从<strong>链路打开</strong>状态转入到<strong>链路终止状态</strong>。</p><h3 id="使用广播信道的数据链路层"><a class="markdownIt-Anchor" href="#使用广播信道的数据链路层"></a> 使用广播信道的数据链路层</h3><h4 id="局域网"><a class="markdownIt-Anchor" href="#局域网"></a> 局域网</h4><p>广播信道最重要的一个应用就是<strong>局域网</strong>。局域网是<strong>一个为单位所拥有的的，且地理范围和站点数目均有限的网络</strong>。</p><p>局域网具有如下一些主要优点：</p><ul><li><strong>具有广播功能</strong>：从一个站点可以很方便地访问全网。局域网上的主机共享连接在局域网上的各种硬件和软件资源。</li><li>便于系统的拓展和逐渐演变，各设备的位置可灵活调整和改变。</li><li>提高了系统的可靠性，可用性和生存性。</li></ul><p>局域网按照网络拓扑进行分类，可以分为<strong>星形网</strong>，<strong>环形网</strong>，<strong>总线网</strong>，他们的网络拓扑图如下：</p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/11.jpg" style="zoom:20%;"><p>这里指出，<strong>局域网</strong>工作的层次跨越了数据链路层和物理层，但因为局域网技术中的有关数据链路层的内容比较丰富，特在这里提出，并不表示局域网仅仅和数据链路层有关。</p><p>在局域网中，<strong>以太网</strong>已经占据了统治的地位。</p><h4 id="共享信道需要考虑的问题"><a class="markdownIt-Anchor" href="#共享信道需要考虑的问题"></a> 共享信道需要考虑的问题</h4><p>共享信道需要考虑的问题就是<strong>如何让众多用户能够合理而方便地通信资源</strong>，主要有两种方法</p><ul><li><strong>(1)静态划分信道</strong>： 静态分配用户使用的信道，用户只要分配到了信道就不会和其他用户发生冲突。但这种划分信道的方法代价很高，不适合局域网使用。比如说某用户分配到了信道，但是一直占着却不通信，其他用户就无法使用这段通信资源直到该用户释放该信道，这大大降低了通信效率。</li><li><strong>(2)动态媒体接入控制</strong>：又称为<strong>多点接入</strong>(multiple access)，其特点是<strong>信道并非在用户通信时固定分配给用户</strong>，又主要分成以下两类：<ul><li><strong>随机接入</strong>：随机接入的特点是所有的用户都随机德发送信息，但如果恰巧有两个或更多的用户在同一时刻发送消息，那么就发送了<strong>碰撞</strong>，使得这些用户的发送<strong>都失败</strong>，所有，需要有<strong>解决碰撞的网络协议</strong>。</li><li><strong>受控接入</strong>：受控接入的特点是用户不能随机地发送信息而必须服从一定的控制。比如分散控制的<strong>令牌环局域网</strong>和集中控制的多点线路<strong>探询(polling)<strong>和</strong>轮询</strong>。</li></ul></li></ul><h4 id="csmacd-协议"><a class="markdownIt-Anchor" href="#csmacd-协议"></a> CSMA/CD 协议</h4><p>这里需要提一下<strong>适配器</strong>，计算机与外界局域网的连接是通过通信<strong>适配器</strong>进行的，适配器是后面<strong>检测信道空闲</strong>，<strong>执行退避算法</strong>的主体。</p><p>最早的以太网(一种局域网)将许多的计算机都连接到一根总线上。这是因为在哪个时代认为，”有源器件不可靠，而无源的电缆线才是最可靠的“。</p><p>总线的特点就是当一台计算机发送数据时，<strong>总线上的所有计算机</strong>都能检测到这个数据，这种就是<strong>广播通信方式</strong>。</p><p>为了通信的方便，以太网采取了一下的两种措施：</p><ol><li><p>采用灵活的<strong>无连接</strong>的工作方式，不需要在传输数据前先建立连接。对发送的数据帧不尽进行编号，也不要求对方发回确认。因此，<strong>以太网提供的服务是尽最大努力的交付</strong>，是<strong>不可靠的交付</strong>。当目的站收到有差错的帧时，就把帧丢弃，其他什么都不做。对<strong>有差错的帧是否需重传则由高层决定</strong>。例如，如果高层是TCP协议，TCP发现有数据丢失，重新发送数据，但<strong>以太网并不知道这是重传帧，只是当成新的数据帧来传送</strong>。<br>我们知道，<strong>总线上在同一时间只能允许一台计算机发送数据</strong>，否则各计算机之间就会互相干扰。因此，如何协调总线上各计算机的工作就是以太网要解决的一个重要问题。以太网使用的协议是<strong>CSMA/CD</strong>，意思是<strong>载波监听多点接入/碰撞检测(Carrier Sense Multiple Access with Collision Detection)</strong>。</p></li><li><p>第二，以太网发送的数据都使用<strong>曼彻斯特编码</strong>的信号。</p></li></ol><h5 id="csmacd协议的要点"><a class="markdownIt-Anchor" href="#csmacd协议的要点"></a> <strong>CSMA/CD协议的要点</strong>：</h5><ul><li><p><strong>多点接入</strong>：指的是网络是总线型网络，计算器以多点接入的方式连接在一起。</p></li><li><p><strong>载波监听</strong>：载波监听其实就是<strong>检测信道</strong>。不管在发送前还是在发送中，<strong>每个站都必须不停地检测信道</strong>。在发送前检测信道，是为了<strong>获得发送权</strong>。检测到没有其他站在发送，就发送数据。在发送过程中检测信道，是为了及时发现有没有其他站的发送和本站发送的<strong>碰撞</strong>。这也称为<strong>碰撞检测</strong>，也叫<strong>冲突检测</strong>。</p><p><strong>碰撞检测</strong>也就是<strong>边发送边监听</strong>。适配器边发送数据边检测信道上的信号电压的变化情况，以便判断自己发送数据时其他站是否也在发送数据。</p><p>如果有多个站同时在总线上发送数据，总线上的信号电压会增大，电压超过一定门限值时，就认为了总线上至少有两个站同时在发送数据，表面发生了<strong>碰撞</strong>，也就是发生了冲突。任何一个正在发送数据的栈，一旦发现总线上出现了碰撞，就要<strong>立即停止发送</strong>，等待一段时间后再次发送。</p></li></ul><p>我们不是在发送数据前<strong>检测信道</strong>监听到信道为<strong>空闲</strong>了吗？为什么还要<strong>边发送边监听呢</strong>？这是因为我们数据通过电磁波在总线上是以<strong>有限的速率传播的</strong>。正如在一个会议中，一听到会场安静，我们就立即发言，但恰好这时也有人发觉会场安静，也发言了，于是你们同时发言了，这就<strong>产生了冲突</strong>。</p><h5 id="csmacd协议的具体过程"><a class="markdownIt-Anchor" href="#csmacd协议的具体过程"></a> CSMA/CD协议的具体过程</h5><p>如图3-17，图中的局域网两端的站A和站B相距1km，用同轴电缆相连。<strong>电磁波在1km电缆的传播时延为5<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\mu s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span><span class="mord mathdefault">s</span></span></span></span></strong>。因此，A检测到信道空闲后，向B发送数据，在约<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn><mi>μ</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">5\mu s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">5</span><span class="mord mathdefault">μ</span><span class="mord mathdefault">s</span></span></span></span>才能传送到B，且A的传输的途中(未到达B)，B检测信道，<strong>信道此时也显示空闲</strong>，若此时B发送数据，则一定会在途中与A发送的数据<strong>发生碰撞</strong>，碰撞的结果是<strong>两个帧都变为无用帧</strong>。</p><p>在局域网的分析中，我们常把总线上的<strong>单程端到端传播时延为τ</strong>。因此我们可以知道，A检测到信道控线后，发送数据，最迟经过<strong>2τ</strong>可以知道自己发送的数据与其他站发送的数据有没有发生碰撞，这种情况发生在A就快要到达B了(很接近很近但就是没到)，然后此时B默默发出一个数据，然后B主机发送的数据报经过<strong>τ</strong>时间后到达A，告诉A…<strong>对不起碰撞了</strong>。</p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/12.jpg" style="zoom:20%;"><p>在使用CSMA/CD 协议时，一个站<strong>不可能同时进行发送和接收</strong>(但必须<strong>边发送边监听信道</strong>)。因此使用CSMA/CD协议的以太网不可能进行全双工的方式而只能进行<strong>半双工通信</strong>。注意与PPP协议区别，PPP协议只支持<strong>全双工链路</strong>。</p><p>下面是图3-17一些重要的时刻</p><ul><li>t=0，此时A发送数据。B检测到信道为空闲。</li><li>t=τ-<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span></span></span></span>，此时A发送的数据还没有到达B，所以B检测到<strong>信道是空闲的</strong>，因此B发送数据。</li><li>t=τ-<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span></span></span></span>/2，此时A发送的数据和B发送的数据发生了碰撞。但这时<strong>A和B都不知道发送了碰撞</strong>。相当于可以看作A和B数据相遇，擦肩而过继续传播。</li><li>t=τ，A的数据到达了B，<strong>并告诉B在过程中发生了碰撞</strong>，B于是停止发送数据。</li><li>t=2π-τ，B的数据到达了A，<strong>并告诉了A在过程中发生了碰撞</strong>，A于是也停止发送数据。</li></ul><p>A和B发送数据<strong>均失败</strong>，它们都要<strong>推迟一段随机的时间再重新发送</strong>。</p><p>由此可见，<strong>每一主机在检测到信道空闲后，选择发送数据，在发送数据之后的一小段时间内，仍然存在着遭遇碰撞的可能性</strong>。这一小段时间是<strong>不确定的</strong>，取决于另一个发送数据的站到本站的距离。因此，以太网<strong>不能保证</strong>某一时间之内一定能够把自己的数据帧成功地发送出去，这一特点称为<strong>发送的不确定性</strong>。</p><p>我们前面提到，最先发数据帧的A主机，在发送数据帧后<strong>最多(最迟)<strong>经过</strong>2τ</strong>就可以知道所发送的数据帧是否遭到了碰撞。这是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi><mo>→</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\delta → 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>的情况，也就是前面说的在A就快要到达B了(很接近很近但就是没到)，然后此时B默默发出一个数据，几乎两个动作同时进行(极限的思想)。因此以太网的<strong>端到端往返时间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>τ</mi></mrow><annotation encoding="application/x-tex">2τ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span><strong>又称为</strong>争用期</strong>。<br><strong>争用期(contention period)<strong>又称</strong>碰撞窗口(collision window)</strong>。</p><p>于是我们得到<strong>结论</strong>：一个主机A(站)在发送完数据后，只要通过争用期的<strong>考验</strong>，即经过争用期这段时间还没有检测到碰撞的话，这样，直到A的数据顺利发送完毕，任何其他站检测信道都会检测到<strong>信道忙</strong>，我们可以肯定A发送数据不会发生碰撞了。</p><h5 id="重传机制截断二进制指数退避truncated-binary-exponential-backoff"><a class="markdownIt-Anchor" href="#重传机制截断二进制指数退避truncated-binary-exponential-backoff"></a> 重传机制–截断二进制指数退避(truncated binary exponential backoff)</h5><blockquote><p>前面我们提到，A和B发生碰撞后，发送数据<strong>均失败</strong>，它们都要<strong>推迟一段随机的时间再重新发送</strong>。</p></blockquote><p>这种重新发送我们又称为<strong>重传</strong>。问题就来了？<strong>推迟的机制</strong>是什么？如何确定<strong>推迟的时间呢</strong>？</p><p>以太网使用<strong>截断二进制指数退避</strong>算法来确定碰撞后重传的时机。这种算法让发生碰撞的站(主机)在停止发送数据后，<strong>不是等待信号变为空闲后就立即再次发送数据</strong>，而是选择<strong>推迟</strong>(或叫<strong>退避</strong>)一个随机的时间。之所以要采取这种机制，原因很容易理解，因为如果几个发生碰撞的站都在监听信道，那么很大概率会<strong>同时发现信道变为空闲</strong>，于是再次冲突，再次退避，再次冲突，再次退避，再次冲突…。</p><p>具体的<strong>退避算法</strong>如下：</p><ol><li><p>首先协议规定了基本退避时间为争用期2τ，具体的<strong>争用期时间</strong>是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>51.2</mn><mi>μ</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">51.2\mu s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord mathdefault">μ</span><span class="mord mathdefault">s</span></span></span></span>,对于10 Mbit/s的以太网，在争用期内可发送512bit(51.2*10)，也就是64字节,我们也说争用期是<strong>512比特时间</strong>。1比特时间就是发送1比特所的时间，争用期就是发送<strong>512bit所需的时间</strong>。</p></li><li><p>从离散的整数集合<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1,...(2^{k}-1)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span>中<strong>随机</strong>取出一个数，记为r。<strong>推迟重传的时间是r倍的争用期</strong>。k可以按下面的公式计算</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mi>M</mi><mi>i</mi><mi>n</mi><mo stretchy="false">[</mo><mi mathvariant="normal">重</mi><mi mathvariant="normal">传</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">，</mi><mn>10</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k=Min[重传数，10]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord cjk_fallback">重</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">，</span><span class="mord">1</span><span class="mord">0</span><span class="mclose">]</span></span></span></span></span></p></li><li><p>当重传<strong>16次仍不能成功</strong>时，表面此时的网络已经非常地拥挤了，以致于连续发生冲突，则丢弃该帧，向高层报告。</p></li></ol><p>例如在第一次重传时，k=1，随机数r从整数{0,1}中选一个数，因此重传的时间为0τ或2τ，在这两个时间中随机选择一个。</p><p>应当注意到，每发送一个新的帧，就要执行一次<strong>CSMA/CD 算法</strong>。适配器对过去发生的碰撞并无记忆，只能机械地按照退避算法进行退避，这都导致一种情况的发生：很可能某一个刚发送的新帧<strong>运气非常好</strong>，推迟时间非常短甚至是直接立即成功地插入到信道中，<strong>获得了发送权</strong>，而一些运气不好的“<strong>老帧</strong>”可能要无限期地等待下去…。</p><p>还需要注意的一个问题是：上面我们提到了结论：</p><blockquote><p>一个主机A(站)在发送完数据后，只要通过争用期的<strong>考验</strong>，即经过争用期这段时间还没有检测到碰撞，这样，在A终止发数据前，任何其他站检测信道都会检测到<strong>信道忙</strong>，我们可以肯定A发送数据不会发生碰撞了，直到A的数据顺利发送完毕。</p></blockquote><p>我们知道，争用期共可以发送<strong>64个字节</strong>，因为一检测到冲突就终止发送，所以此时发送出去的数据一定是小于64字节的。所以有<strong>凡长度小于64字节的帧都是由于冲突而异常终止的无效帧</strong>，收到这样的帧，立即将其丢弃。</p><h5 id="强化碰撞"><a class="markdownIt-Anchor" href="#强化碰撞"></a> <strong>强化碰撞</strong></h5><p>前面我们提到，发送数据的站一旦接收到<strong>发生了碰撞</strong>的信息后，立即停止发生数据。但在此基础上，我们还要继续发送<strong>32比特或48比特的人为干扰信号</strong>，以便所有用户都知道现在已经发生了碰撞。这就是<strong>强化碰撞</strong>。</p><p>如下图3-18，A站从发送数据开始到发现碰撞并停止发送的时间时间是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">T_{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。A站得知碰撞已经发生时所发送的<strong>强化碰撞的人为干扰信号</strong>的持续时间是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>J</mi></msub></mrow><annotation encoding="application/x-tex">T_{J}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.09618em;">J</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。发生碰撞使得A浪费的时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>B</mi></msub><mo>+</mo><msub><mi>T</mi><mi>J</mi></msub></mrow><annotation encoding="application/x-tex">T_{B}+T_{J}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.09618em;">J</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。而整个信道被占用的时间还要增加一个<strong>端到端的时延τ</strong>，因此总线被占用的时间是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>B</mi></msub><mo>+</mo><msub><mi>T</mi><mi>J</mi></msub><mo>+</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">T_{B}+T_{J}+τ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.09618em;">J</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span>。</p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/13.jpg" style="zoom:20%;"><h5 id="帧间最小间隔"><a class="markdownIt-Anchor" href="#帧间最小间隔"></a> <strong>帧间最小间隔</strong></h5><p>以太网还规定了<strong>帧间最小间隔为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9.6</mn><mi>μ</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">9.6\mu s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">9</span><span class="mord">.</span><span class="mord">6</span><span class="mord mathdefault">μ</span><span class="mord mathdefault">s</span></span></span></span>,相当于96bit时间</strong>，之所以这么做，是<strong>为了使刚刚收到数据帧的站的接受缓存来得及清理，做好接受下一帧的准备</strong>。</p><p>综上所述，我们将利用<strong>CSMA/CD</strong>协议发送数据的过程归纳如下：</p><blockquote><p>首先是发送前适配器<strong>检测信道</strong>，检测信道是否空闲。若信道忙，则不停地检测，一直等待<strong>信道空闲</strong>。一旦<strong>信道空闲</strong>，<strong>并在96比特时间内信道保持空闲</strong>(保证了帧间最小间隔)，适配器就<strong>发送这个帧</strong>。在边发送的过程中仍要不停地检测信道，及<strong>边发送边监听</strong>，如果在<strong>争用期</strong>内<strong>没有</strong>检测到碰撞，则这个帧肯定能够发送成功。 如果在争用期内<strong>检测到碰撞</strong>，这时应该立即停止正在发送的数据，并按规定发送<strong>人为干扰信号</strong>，告知所以用户都知道现在已经发生了碰撞，适配器执行<strong>指数退避算法</strong>，重新<strong>检测信道</strong>，准备发送。但若重传16次仍不能成功，停止重传并向上报错。</p></blockquote><h4 id="以太网的信道利用率"><a class="markdownIt-Anchor" href="#以太网的信道利用率"></a> 以太网的信道利用率</h4><p>以图3-21为例，<strong>分析以太网的信道利用率</strong>。</p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/14.jpg" style="zoom:20%;"><p>一个站在发送帧时出现了<strong>碰撞</strong>。经过一个争用期2τ后，又出现了碰撞…，这样经过若干个争用期后，一个站发送成功了。假定发送帧需要的时间是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">T_{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,我们应当注意，成功发送一个帧需要占用信道的时间是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub><mo>+</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">T_{0}+τ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span>，因为发送完最后一个比特后，这个比特还需要在以太网上传播一个τ的时间。因此，必须在经过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub><mo>+</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">T_{0}+τ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span>后以太网的信道才<strong>完全进入空闲状态</strong>，才允许其他站发送数据。</p><p>从图3-21可看出，<strong>要提高以太网的信道利用率</strong>，就必须减小τ和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">T_{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>之比。在以太网中我们定义了参数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>,它是以太网<strong>单程端到端时延τ</strong>与**帧的发送时间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">T_{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>**之比：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mo>=</mo><mi>τ</mi><mtext> </mtext><mo>÷</mo><mtext> </mtext><msub><mi>T</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\alpha=τ \ \div \ T_{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mo>→</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\alpha → 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>时，表示只要一发生碰撞，就立即可以检测出来，并立即停止发送，因为τ比较小，因而信道资源被浪费的时间非常非常少。反之，参数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>越大，表明<strong>争用期</strong>所占的比例越大，使得发生一次碰撞就浪费了不少的信道资源，<strong>信道利用率</strong>，明显降低。</p><p>因而，以太网的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>的值应当尽可能小，如何让<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>小？可以让<strong>τ</strong>小和让<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">T_{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>大，τ变小也就是以太网端到端连线的长度要小，这也是为什么<strong>以太网的长度的通信距离比较短的原因</strong>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">T_{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>变大就要求我们发送的<strong>以太网帧长</strong>不能太短。</p><h4 id="以太网的mac层"><a class="markdownIt-Anchor" href="#以太网的mac层"></a> 以太网的MAC层</h4><h5 id="mac层的硬件地址"><a class="markdownIt-Anchor" href="#mac层的硬件地址"></a> MAC层的硬件地址</h5><p>在局域网中，<strong>硬件地址</strong>又称为<strong>物理地址</strong>或<strong>MAC</strong>地址，有48位长。MAC地址一般固化在<strong>适配器</strong>的ROM中，则<strong>IP</strong>地址一般存在计算机存储器中。一台计算机的MAC地址一般是不可变的，除非你重新更换一个<strong>适配器</strong>，而IP地址是可以改变的，与你接入的网络有关。</p><p>规定MAC地址字段的<strong>第一字节的最低位</strong>为I/G位，I/G表示 Individual/Group。当I/G为0时，地址字段表示一个<strong>单个站的地址</strong>，I/G位为1时表示<strong>组地址</strong>，用来表示<strong>多播</strong>。</p><h5 id="mac帧的格式"><a class="markdownIt-Anchor" href="#mac帧的格式"></a> MAC帧的格式</h5><p>如图3-22表示以太网V2的MAC帧格式，我们假定网络层使用的是IP协议。</p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/15.jpg" style="zoom:20%;"><p>MAC帧较为简单，由五个字段组成。前两个字段分别为6字节长的<strong>目的地址</strong>和<strong>源地址</strong>。第三个字段的2字节为<strong>类型字段</strong>，用来标志上一层使用的是什么协议。例如，当类型字段的值为0x0800时，表示上层使用的是<strong>IP数据报</strong>。第四个字段是<strong>数据字段</strong>，长度在<strong>46</strong>到<strong>1500</strong>字节之间，46是怎么来的？我们前面提到了</p><blockquote><p>我们知道，争用期共可以发送<strong>64个字节</strong>，因为一检测到冲突就终止发送，所以此时发送出去的数据一定是小于64字节的。所以有<strong>凡长度小于64字节的帧都是由于冲突而异常终止的无效帧</strong>，收到这样的帧，立即将其丢弃。</p></blockquote><p>所以发送的帧最小长度为64字节，减去18字节的首部和尾部就得到了46-<strong>数据字段的最小长度</strong>。最后一个字段是4字节的<strong>帧检验序列FCS</strong>。</p><h5 id="无效的mac帧"><a class="markdownIt-Anchor" href="#无效的mac帧"></a> 无效的MAC帧</h5><ul><li><p>帧的长度不是整数个字节。</p></li><li><p>用受到的帧检验序列FCS查出有出错。</p></li><li><p>受到的MAC帧的<strong>数据长度</strong>不在46<sub>1500字节之间，也可以理解为**MAC帧总长度**不在64</sub>1518之间。</p></li></ul><h3 id="虚拟局域网vlan"><a class="markdownIt-Anchor" href="#虚拟局域网vlan"></a> 虚拟局域网VLAN</h3><h5 id="以太网交换机"><a class="markdownIt-Anchor" href="#以太网交换机"></a> 以太网交换机</h5><p>虚拟局域网VLAN(Virtual LAN)是利用<strong>以太网交换机</strong>实现，所以我们要先简单提一下<strong>以太网交换机</strong>。</p><p><strong>以太网交换机的出现</strong>其实是因为人们希望在<strong>数据链路层</strong>上拓展以太网，以太网交换机的作用就是对收到的帧根据其MAC帧的目的地址进行<strong>转发</strong>和<strong>过滤</strong>。一般都工作在<strong>全双工方式</strong>下，相互通信的主机都是<strong>独占传输媒体，无碰撞地传输数据</strong>，无碰撞，显然以太网交换机是不使用CSMA/CD协议的。</p><p>以太网交换机通过<strong>自学算法</strong>建立起其内部的<strong>交换表</strong>或者说是<strong>地址表</strong>，根据受到的帧的目的地址，查表然后转发，不检查差错。</p><h5 id="vlan"><a class="markdownIt-Anchor" href="#vlan"></a> VLAN</h5><p>虚拟局域网VLAN是由一些局域网网段构成的<strong>与物理位置无关</strong>的逻辑组，而这些网段具有某种<strong>共同的需求</strong>。每一个VLAN的帧都有一个<strong>明确的标识符</strong>，指明发送这个帧的计算机属于哪一个VLAN。</p><p><strong>虚拟局域网其实只是局域网给用户提供的一种服务，并不是一种新型的局域网</strong>。</p><p>如图3-27，设有10台计算机分配在三个楼层中，成了三个局域网:</p><p>LAN1(A1,A2,B1,C1)  LAN2: (A3,B2,C2),   LAN3(A4,B3,C3) 但这10个用户划分为了三个工作组，也就是三个虚拟局域网VLAN。即VLAN1：(A1,A2,A3,A4)  VLAN2: (B1,B2,B3)  VLAN3: (C1,C2,C3)</p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/16.jpg" style="zoom:20%;"><p>从图中看出，每一个VLAN的计算机可以处在<strong>不同的局域网</strong>中。利用以太网交换机可以将这10台计算机划分为三个虚拟局域网：VLAN1, VLAN2, VLAN3。<strong>在虚拟局域网上的每一个站都可以收到同一个虚拟局域网上的其他成员发出的广播</strong>。</p><p>例如：计算机B1~B3同属虚拟局域网VLAN2，当B1向工作组内成员送数据时，B2和B3会收到广播的信息，即使他们没有跟B1连在同一个以太网交换机上，而A1,A2和C1都不会收到B1发出的广播信息，虽然它们都与B1连接在同一个交换机上。<strong>以太网交换机不向虚拟局域网以外的计算机传送B1的广播信息</strong>。这样，虚拟局域网限制了接收广播信息的计算机数，使得网络不会因传播过多的广播信息(<strong>广播风暴</strong>)而引起性能的恶化。</p><p>同时，虚拟局域网可按照需要随时重新组合，很方便。</p><p>如何指明发送数据帧的计算机属于哪一个局域网？虚拟局域网的协议在以太网的帧格式中插入了4字节的标识符，称为<strong>VLAN标记(tag)</strong>，指明发送该帧的计算机属于哪一个虚拟局域网。</p><p>有关<strong>数据链路层</strong>的内容差不多就是这些了，真的太多太多了，感觉整理的不是很好，觉得什么东西都很重要，连贯性很强，你有部分东西不写后面又会用到这个名词，都想写下来哈哈</p><p><strong>整个数据链路层</strong>的内容很多，这里做一个小小的总结：</p><p>首先我们提到：</p><blockquote><p>1 数据链路层设计的初衷是为了向网络层提高更高质量的数据传输。</p></blockquote><blockquote><p>2 网络层传输的是数据报，数据链路层传输的是帧，物理层传输的是比特流。</p></blockquote><p>之后我们引出了<strong>所有数据链路层都需要考虑的三个基本问题</strong>：<strong>封装成帧，透明传输，差错检测</strong></p><p>为什么要封装成帧？因为<strong>数据链路层传输的是帧呀</strong>，为什么要透明传输？因为特定的帧定界符也需要封装进帧里，所以需要透明传输的原因也是<strong>数据链路层传输的是帧</strong>，为什么要差错检测？因为数据链路层的设计的初衷是为了<strong>向网络层提供更高质量的数据传输</strong>。所有三个基本问题的出现也就顺理成章了，之后就是三个基本问题引出的一系列问题，如CRC校验等。</p><p>接着我们介绍了数据链路层的两种协议<strong>PPP协议</strong>和<strong>CSMA/CD</strong>协议，PPP协议支持的是点对点信道，CSMA/CD协议支持的是广播信道。后面就是对着两个协议一些细节的介绍了。</p><p>本篇博客只是<strong>自己</strong>对课程学习的一些笔记和总结，大部分内容参考自**《计算机网络》**第七版，谢希仁编著。</p><p>如有出错(非常大可能会出错哈哈)，欢迎指正！</p><p>完…</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;数据链路层的设计初衷&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#数据链路层的设计初衷&quot;&gt;&lt;/a&gt; 数据链路层的设计初衷&lt;/h3&gt;
&lt;p&gt;我们知道物理层的线路上传输的是我们的&lt;strong&gt;比特流&lt;/strong&gt;，物理层的线路由传输介质与通信设备组成。比特流在物理线上的传输肯定会存在误差。这样我们就引入了数据链路层在物理层之上，在数据链路层中采用&lt;strong&gt;差错检测&lt;/strong&gt;，&lt;strong&gt;差错控制&lt;/strong&gt;和&lt;strong&gt;流量控制&lt;/strong&gt;等方法，向网络层提高&lt;strong&gt;高质量&lt;/strong&gt;的数据传输服务。&lt;/p&gt;
&lt;p&gt;注意这里说的是&lt;strong&gt;高质量&lt;/strong&gt;，而不是&lt;strong&gt;可靠&lt;/strong&gt;，数据传输的&lt;strong&gt;可靠仍然要靠我们传输层的TCP协议实现&lt;/strong&gt;。数据链路层提供了&lt;strong&gt;差错检测机制&lt;/strong&gt;，相对于物理层来说，提高了数据传输的质量。&lt;/p&gt;
&lt;p&gt;这样&lt;strong&gt;数据链路层&lt;/strong&gt;就可以看成了&lt;strong&gt;网络层&lt;/strong&gt;和&lt;strong&gt;物理层&lt;/strong&gt;之间的一层&lt;strong&gt;抽象&lt;/strong&gt;，属于计算机网络中的低层。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://luo41.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://luo41.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="数据链路层" scheme="https://luo41.top/tags/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>hexo melody主题配置邮箱链接</title>
    <link href="https://luo41.top/2021/06/03/hexo-melody%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E9%82%AE%E7%AE%B1%E9%93%BE%E6%8E%A5/"/>
    <id>https://luo41.top/2021/06/03/hexo-melody%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E9%82%AE%E7%AE%B1%E9%93%BE%E6%8E%A5/</id>
    <published>2021-06-03T07:24:23.000Z</published>
    <updated>2021-06-05T04:50:33.725Z</updated>
    
    <content type="html"><![CDATA[<p>首先到<a href="https://fontawesome.com/">图标网上</a>找一个图标，别人访问你的博客点击该图标就可以利用<strong>mailto</strong>给你发邮件。</p><img src="/2021/06/03/hexo-melody%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E9%82%AE%E7%AE%B1%E9%93%BE%E6%8E%A5/1.png" style="zoom:50%;"><p>这里我选择的是envelope图标，点击图标进去，点击Start Using This Icon</p><span id="more"></span><img src="/2021/06/03/hexo-melody%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E9%82%AE%E7%AE%B1%E9%93%BE%E6%8E%A5/2.png" style="zoom:50%;"><p>提示Copy下面语句写入网页html文件中即可</p><img src="/2021/06/03/hexo-melody%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E9%82%AE%E7%AE%B1%E9%93%BE%E6%8E%A5/3.png" style="zoom:50%;"><p>但<strong>我死活没找到我的blog的HTML文件</strong>在哪里，所以用另外一种办法，在<strong>主题配置文件</strong>(注意，不是博客根目录下的，而是主题melody下的_config.yml文件)里找到 social 这项，写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">social:</span><br><span class="line">  envelope fa: mailto:XXXXX@qq.com <span class="comment">//XXXX为你的邮箱名，qq.com为例，其他邮箱相同</span></span><br></pre></td></tr></table></figure><p>这里的envelope fa对应上面我们选的</p><img src="/2021/06/03/hexo-melody%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E9%82%AE%E7%AE%B1%E9%93%BE%E6%8E%A5/4.png" style="zoom:50%;"><p>如果我们选择了</p><img src="/2021/06/03/hexo-melody%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E9%82%AE%E7%AE%B1%E9%93%BE%E6%8E%A5/5.png" style="zoom:50%;"><p>则语句改为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">social:</span><br><span class="line">  envelope-square fa: mailto:XXXXX@qq.com <span class="comment">//XXXX为你的邮箱名，qq.com为例，其他邮箱相同</span></span><br></pre></td></tr></table></figure><p><strong>也就是如下图这样</strong></p><img src="/2021/06/03/hexo-melody%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E9%82%AE%E7%AE%B1%E9%93%BE%E6%8E%A5/7.png" style="zoom:50%;"><p>其他图标的设置也一样的操作。</p><p><strong>更改完，重新部署看到邮件图标就成功了，如下：</strong></p><img src="/2021/06/03/hexo-melody%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E9%82%AE%E7%AE%B1%E9%93%BE%E6%8E%A5/6.png" style="zoom:50%;">]]></content>
    
    
    <summary type="html">&lt;p&gt;首先到&lt;a href=&quot;https://fontawesome.com/&quot;&gt;图标网上&lt;/a&gt;找一个图标，别人访问你的博客点击该图标就可以利用&lt;strong&gt;mailto&lt;/strong&gt;给你发邮件。&lt;/p&gt;
&lt;img src=&quot;/2021/06/03/hexo-melody%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E9%82%AE%E7%AE%B1%E9%93%BE%E6%8E%A5/1.png&quot; style=&quot;zoom:50%;&quot;&gt;
&lt;p&gt;这里我选择的是envelope图标，点击图标进去，点击Start Using This Icon&lt;/p&gt;</summary>
    
    
    
    <category term="折腾" scheme="https://luo41.top/categories/%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="HEXO" scheme="https://luo41.top/tags/HEXO/"/>
    
  </entry>
  
  <entry>
    <title>函数依赖，码和范式</title>
    <link href="https://luo41.top/2021/06/02/%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%EF%BC%8C%E7%A0%81%E5%92%8C%E8%8C%83%E5%BC%8F/"/>
    <id>https://luo41.top/2021/06/02/%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%EF%BC%8C%E7%A0%81%E5%92%8C%E8%8C%83%E5%BC%8F/</id>
    <published>2021-06-01T16:55:37.000Z</published>
    <updated>2021-06-07T07:36:21.254Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-函数依赖xrightarrowy"><a class="markdownIt-Anchor" href="#1-函数依赖xrightarrowy"></a> 1 函数依赖X<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>Y</h3><h4 id="11-什么是函数依赖"><a class="markdownIt-Anchor" href="#11-什么是函数依赖"></a> 1.1 什么是函数依赖？</h4><p><strong>函数依赖X<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>Y</strong>: X和Y都是属性(集合)</p><ul><li>一个X的值，只对应一个Y</li><li>一个Y，可能对应不止的X</li></ul><p><strong>X<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>Y</strong> 的意思是X<strong>函数决定</strong>Y，或Y<strong>函数依赖</strong>于X，X是Y的<strong>决定</strong>元素</p><span id="more"></span><p>为了举例子：</p><p>我们建立下面的<strong>排课表</strong>关系模型</p><table><thead><tr><th>班级</th><th>辅导员</th><th>办公室</th><th>课程</th><th>学时</th><th>教师</th></tr></thead><tbody><tr><td>师范1班</td><td>刘冰</td><td>201</td><td>数据库</td><td>54/6</td><td>潘帅</td></tr><tr><td>师范1班</td><td>刘冰</td><td>201</td><td>大学英语</td><td>32/0</td><td>李少芳</td></tr><tr><td>软件3班</td><td>张友</td><td>203</td><td>大学英语</td><td>32/0</td><td>李少芳</td></tr><tr><td>网工5班</td><td>颜启</td><td>202</td><td>数据库</td><td>54/6</td><td>张和</td></tr><tr><td>网工5班</td><td>颜启</td><td>202</td><td>JAVA</td><td>48/16</td><td>胡乐天</td></tr><tr><td>数媒7班</td><td>张友</td><td>203</td><td>JAVA</td><td>48/16</td><td>查左</td></tr></tbody></table><p>其中的函数依赖有<strong>班级<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>辅导员</strong>为一个函数依赖，班级(X)一旦确定，辅导员(Y)也随之确定。其他的函数依赖还包括<strong>辅导员<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>办公室</strong>，<strong>课程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>学时</strong>等，都是箭头左边的属性可以决定右边的属性值。</p><p>X和Y也可以是<strong>属性集合</strong>，比如说单独课程无法决定老师，也就是<strong>课程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>↛</mo></mrow><annotation encoding="application/x-tex">\nrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel amsrm">↛</span></span></span></span>老师</strong>，但是<strong>班级和课程</strong>两个属性可以决定<strong>教师</strong>这个属性，所以<strong>班级，课程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>教师</strong>也是一个函数依赖。</p><h4 id="12-特殊类型的函数依赖"><a class="markdownIt-Anchor" href="#12-特殊类型的函数依赖"></a> 1.2 特殊类型的函数依赖</h4><ul><li><p><strong>平凡的函数依赖</strong>：满足 <strong>X<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>Y,Y<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊆</mo></mrow><annotation encoding="application/x-tex">\subseteq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">⊆</span></span></span></span>X</strong><br>在上面的排课表中，其中的平凡函数依赖有<strong>班级<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>班级</strong>，<strong>班级，老师<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>班级</strong>，平凡的函数依赖必然成立，<strong>没什么讨论的价值</strong>。</p></li><li><p><strong>非平凡的函数依赖</strong>：满足 <strong>X<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>Y,Y<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊊</mo></mrow><annotation encoding="application/x-tex">\subsetneq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel amsrm">⊊</span></span></span></span>X</strong><br><strong>非平凡的函数依赖不一定成立</strong>，如在上面的例子中<strong>班级<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>班级，辅导员</strong>这个函数依赖是成立的，而<strong>辅导员<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>办公室，班级</strong>这个函数依赖是不成立的。</p></li><li><p><strong>部分的函数依赖</strong>：<strong>X<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>Y: 存在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>X</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup><mo>⊂</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">X^{&#x27;} \subset X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.98158em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>, 使得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>X</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X^{&#x27;} \rightarrow Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>成立</strong><br>简单理解就是其实只要<strong>左边的一部分就可以决定右边了</strong>。举个例子，在排课表中，<strong>班级，课程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>学时</strong>是部分的函数依赖，因为左边<strong>课程</strong>就可以决定学时了。记为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mover><mo><mo>⟶</mo></mo><mi>p</mi></mover><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\stackrel{p}{\longrightarrow}Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1704999999999999em;vertical-align:-0.011em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1595em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">⟶</span></span></span><span style="top:-3.758108em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span></p></li><li><p><strong>完全的函数依赖</strong> <strong>X<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>Y: 不存在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>X</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup><mo>⊂</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">X^{&#x27;} \subset X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.98158em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>, 使得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>X</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X^{&#x27;} \rightarrow Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>成立</strong></p><p>理解：要<strong>左边的全部</strong>才可以<strong>决定右边</strong>。比如在排课表中：<strong>班级，课程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>教师</strong>是完全的函数依赖。记为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mover><mo><mo>⟶</mo></mo><mi>F</mi></mover><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\stackrel{F}{\longrightarrow}Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3003310000000001em;vertical-align:-0.011em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2893310000000002em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">⟶</span></span></span><span style="top:-3.7110000000000003em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">F</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span></p></li><li><p><strong>传递的函数依赖</strong>：(公式不想列出，因为觉得好难懂!)</p><p>简单的理解就是左边与右边的属性存在中间属性。例如，排课表中，<strong>班级<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>办公室</strong>是传递的函数依赖，因为存在<strong>班级<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>辅导员</strong>和<strong>辅导员<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>办公室</strong>，班级和办公室存在辅导员这个中间元素。</p></li><li><p><strong>非传递的函数依赖</strong>：<br>左边和右边的属性直接决定，不存在中间元素。如<strong>课程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>学时</strong>是非传递的。</p></li></ul><p>这就是所有特殊的函数依赖了，其中有</p><p>结论一：<strong>部分的函数依赖一定是传递的函数依赖</strong>，证明如下：</p><p>因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\rightarrow Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>是部分函数依赖，所以<strong>X<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>Y: 存在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>X</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup><mo>⊂</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">X^{&#x27;} \subset X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.98158em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>, 使得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>X</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X^{&#x27;} \rightarrow Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>成立</strong>，因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>X</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup></mrow><annotation encoding="application/x-tex">X^{&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>是X的部分,显然<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>→</mo><msup><mi>X</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup></mrow><annotation encoding="application/x-tex">X \rightarrow X^{&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>,又<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>X</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X^{&#x27;} \rightarrow Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>,所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>X</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup></mrow><annotation encoding="application/x-tex">X^{&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>是X和Y的中间元素，所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \rightarrow Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>是传递的函数依赖。</p><p>结论二：<strong>非传递的函数依赖也一定是完全的</strong>，证明如下：</p><p><strong>用反证法</strong>：如果函数依赖是部分的，则有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>X</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup><mo>⊂</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">X^{&#x27;} \subset X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.98158em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>X</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X^{&#x27;} \rightarrow Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>,又显然 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>→</mo><msup><mi>X</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup></mrow><annotation encoding="application/x-tex">X \rightarrow X^{&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>，所以有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \rightarrow Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>是传递的，因为有中间元素<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>X</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup></mrow><annotation encoding="application/x-tex">X^{&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.94248em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>，与前提矛盾。反证失败，得出结论，<strong>非传递的函数依赖也是完全的函数传递</strong></p><h3 id="2-码"><a class="markdownIt-Anchor" href="#2-码"></a> 2 码</h3><p>码这里只简单提几种码的概念，因为讲到范式需要用到几种码的概念。</p><h4 id="21-超码"><a class="markdownIt-Anchor" href="#21-超码"></a> 2.1 超码</h4><p>超码是关系中能<strong>唯一标识</strong>每个元组(可以简单的每一行数据)的<strong>属性或者属性组</strong>。</p><h4 id="22-候选码"><a class="markdownIt-Anchor" href="#22-候选码"></a> 2.2 候选码</h4><p>候选码是<strong>最小的超码</strong>，一个超码可能含有多于的属性。</p><h4 id="23-主码"><a class="markdownIt-Anchor" href="#23-主码"></a> 2.3 主码</h4><p>一个关系里可能存在几个候选码，但是只选一个出来作为<strong>主码</strong>。</p><h4 id="24-码属性"><a class="markdownIt-Anchor" href="#24-码属性"></a> 2.4 码属性</h4><p>又称主属性，一个属性，出现在<strong>某个候选码</strong>中。例如(A,B,C)构成了一个候选码，那么A,B,C都具有码属性。</p><h4 id="25-非码属性"><a class="markdownIt-Anchor" href="#25-非码属性"></a> 2.5 非码属性</h4><p>一个属性，<strong>不出现在任何的候选码中</strong>。一个属性，不是码属性就是非码属性。</p><h3 id="3-范式"><a class="markdownIt-Anchor" href="#3-范式"></a> 3 范式</h3><p>注：在下文中出现的<strong>码</strong>特指<strong>候选码</strong>。</p><h4 id="31-第一范式-1nf"><a class="markdownIt-Anchor" href="#31-第一范式-1nf"></a> 3.1 第一范式 1NF</h4><p>第一范式要求关系模型中的每个属性都是<strong>原子的</strong>，所谓<strong>原子的</strong>就是不可再分的。如上面排课表关系模型<strong>不满足第一范式的要求</strong>，原因是学时属性不是原子的，而是符合的，如果我们<strong>将学时拆分为理论学时和实验学时</strong>，则满足了第一范式的要求。</p><h4 id="32-第二范式-2nf"><a class="markdownIt-Anchor" href="#32-第二范式-2nf"></a> 3.2 第二范式 2NF</h4><ul><li><strong>满足第一范式</strong></li><li><strong>且每一个非码属性完全函数依赖于码</strong></li></ul><p>下面举一个不满足第二范式的关系。</p><p>我们有关系模型(学生学号，学生的系，学生的住处，课程号，班级) 且<strong>每个系的学生只能住同一个地方</strong>，关系模型的码为(<strong>学生学号，课程号</strong>)</p><table><thead><tr><th>学生学号(码属性)</th><th>学生的系(非码属性)</th><th>学生的住处(非码属性)</th><th>课程号(码属性)</th><th>班级(非码属性)</th></tr></thead><tbody><tr><td>2019213201</td><td>网络工程</td><td>西三</td><td>C110</td><td>5</td></tr><tr><td>2019213209</td><td>人工智能</td><td>西五</td><td>C110</td><td>3</td></tr><tr><td>2019213208</td><td>网络工程</td><td>西三</td><td>C130</td><td>5</td></tr><tr><td>2019213207</td><td>计算机科学</td><td>西四</td><td>C120</td><td>4</td></tr></tbody></table><p>存在以下的函数依赖</p><p><strong>（学生学号，课程号）</strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover><mo><mo>⟶</mo></mo><mi>F</mi></mover></mrow><annotation encoding="application/x-tex">\stackrel{F}{\longrightarrow}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3003310000000001em;vertical-align:-0.011em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2893310000000002em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">⟶</span></span></span><span style="top:-3.7110000000000003em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">F</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span></span></span></span></span><strong>班级</strong><br><strong>学生学号</strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span><strong>学生的系</strong>，则**(学生学号，课程号)<strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover><mo><mo>⟶</mo></mo><mi>p</mi></mover></mrow><annotation encoding="application/x-tex">\stackrel{p}{\longrightarrow}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1704999999999999em;vertical-align:-0.011em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1595em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">⟶</span></span></span><span style="top:-3.758108em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span></span></span></span></span><strong>学生的系</strong><br><strong>学生学号</strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span><strong>学生的住处</strong>，则</strong>(学生学号，课程号)**<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover><mo><mo>⟶</mo></mo><mi>p</mi></mover></mrow><annotation encoding="application/x-tex">\stackrel{p}{\longrightarrow}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1704999999999999em;vertical-align:-0.011em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1595em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">⟶</span></span></span><span style="top:-3.758108em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span></span></span></span></span><strong>学生的住处</strong><br><strong>学生的系</strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span><strong>学生的住处</strong></p><p>简单地理解这个关系模型，<strong>只知道学生的学号，我们就可以确定学生的系，学生的住处。但无法知道学生的课程号和班级，只有同时知道了学生的学号和学生的课程，才知道学生的班级</strong>。</p><p>可以看到，非码属性<strong>学生的住处</strong>和<strong>学生的系部分依赖于码(学生学号，课程号)</strong>。<strong>也就是我只要学生学号就可以知道学生的住处和学生的系了，因此课程号有没有都无所谓的，你每一行给我加上一个无关紧要的课程号就使得整个关系模型变得冗余了</strong>。因此该关系模型是<strong>不符合第二范式的</strong>，可以对该关系模型进行拆分，拆分为：</p><table><thead><tr><th>学生学号(码属性)</th><th>学生的系(非码属性)</th><th>学生的住处(非码属性)</th></tr></thead><tbody><tr><td>2019213201</td><td>网络工程</td><td>西三</td></tr><tr><td>2019213209</td><td>人工智能</td><td>西四</td></tr><tr><td>2019213208</td><td>网络工程</td><td>西三</td></tr><tr><td>2019213207</td><td>计算机科学</td><td>西五</td></tr></tbody></table><p><strong>和</strong></p><table><thead><tr><th>学生学号(码属性)</th><th>课程号(码属性)</th><th>班级(非码属性)</th></tr></thead><tbody><tr><td>2019213201</td><td>C110</td><td>5</td></tr><tr><td>2019213209</td><td>C110</td><td>3</td></tr><tr><td>2019213208</td><td>C130</td><td>5</td></tr><tr><td>2019213207</td><td>C120</td><td>4</td></tr></tbody></table><p><strong>候选码</strong>为(<strong>学生学号，课程号</strong>)</p><p><strong>两个关系模型就都符合第二范式了</strong>。</p><h4 id="33-第三范式-3nf"><a class="markdownIt-Anchor" href="#33-第三范式-3nf"></a> 3.3 第三范式 3NF</h4><ul><li><p>满足第一范式</p></li><li><p>每一个非码属性<strong>非传递函数依赖</strong>于码。</p><p>由上面结论二<strong>非传递的函数依赖也一定是完全的</strong>，所以<strong>满足第三范式也隐含着满足第二范式</strong>，是第二范式的真子集，也可以这么说，<strong>第三范式就是在第二范式的基础上消除函数传递</strong>。</p><p>考虑到我们上面拆分后的关系模型</p><table><thead><tr><th>学生学号(码属性)</th><th>学生的系(非码属性)</th><th>学生的住处(非码属性)</th></tr></thead><tbody><tr><td>2019213201</td><td>网络工程</td><td>西三</td></tr><tr><td>2019213209</td><td>人工智能</td><td>西四</td></tr><tr><td>2019213208</td><td>网络工程</td><td>西三</td></tr><tr><td>2019213207</td><td>计算机科学</td><td>西五</td></tr></tbody></table><p>因为我们提到<strong>每个系的同学只能住一个住处</strong>，该关系模型中存在关系依赖<strong>学生学号</strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span><strong>学生的系</strong>，<strong>学生的系</strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span><strong>学生的住处</strong>，所以<strong>非码属性(学生的住处) “函数依赖” 于码属性(学生学号)</strong>。该关系模型违反了<strong>第三范式</strong>，我们可以做拆分：</p></li></ul><table><thead><tr><th>学生学号(码属性)</th><th>学生的系(非码属性)</th></tr></thead><tbody><tr><td>2019213201</td><td>网络工程</td></tr><tr><td>2019213209</td><td>人工智能</td></tr><tr><td>2019213208</td><td>网络工程</td></tr><tr><td>2019213207</td><td>计算机科学</td></tr></tbody></table><table><thead><tr><th>学生的系(码属性)</th><th>学生的住处(非码属性)</th></tr></thead><tbody><tr><td>网络工程</td><td>西三</td></tr><tr><td>人工智能</td><td>西四</td></tr><tr><td>网络工程</td><td>西三</td></tr><tr><td>计算机科学</td><td>西五</td></tr></tbody></table><p>在第二范式的基础上<strong>消除了函数传递</strong>，拆分后关系模型<strong>满足第三范式</strong>。</p><h4 id="34-bc范式-4nf"><a class="markdownIt-Anchor" href="#34-bc范式-4nf"></a> 3.4 BC范式 4NF</h4><ul><li><p>满足第一范式的要求</p></li><li><p>每一个属性(<strong>码属性+非码属性)不传递函数依赖于码</strong></p><p>比第三范式多要求了<strong>码属性</strong>不传递函数依赖于码，所以BC范式一定满足第三范式，是第三范式的真子集。</p></li></ul><p><strong>非码属性传递函数依赖于码</strong>在第三范式中已经举例了，不再举例。这里举一个<strong>码属性传递函数依赖于码</strong>的例子。</p><p>假设我们有如下的关系模型：</p><p>且<strong>假设一个教师只教一门课程，但一门课程有多个教师</strong>，也就是<strong>教师</strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span><strong>课程</strong>。并且假设<strong>一个班级和一门课程，只有一个老师给这个班上这门课</strong>，也就是(<strong>班级，课程</strong>)<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span><strong>教师</strong></p><table><thead><tr><th>班级(码属性)</th><th>课程(码属性)</th><th>教师(非码属性)</th></tr></thead><tbody><tr><td>师范1班</td><td>数据库</td><td>潘帅</td></tr><tr><td>师范1班</td><td>大学英语</td><td>李少芳</td></tr><tr><td>软件3班</td><td>大学英语</td><td>李少芳</td></tr><tr><td>网工5班</td><td>数据库</td><td>严戈</td></tr><tr><td>网工5班</td><td>JAVA</td><td>胡乐天</td></tr><tr><td>数媒7班</td><td>JAVA</td><td>查左</td></tr></tbody></table><p>由函数依赖<strong>教师</strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span><strong>课程</strong>和(<strong>班级，课程</strong>)<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span><strong>教师</strong>，有<strong>码属性</strong>(班级，课程)<strong>函数传递</strong>于<strong>码属性</strong>(课程)，因为有中间属性<strong>教师</strong>，违反了BC范式。</p><h3 id="4-范式的判定"><a class="markdownIt-Anchor" href="#4-范式的判定"></a> 4 范式的判定</h3><p>范式的判定就是要从满足范式的条件出发，从最低级的1NF开始，到2NF最后到3NF和BCNF，如果低范式无法满足，高范式也肯定无法满足。具体判定方法后续(<strong>看自己能不能学明白和有没有心情哈哈哈</strong>)</p><h3 id="5-如何从低范式到更高级别的范式"><a class="markdownIt-Anchor" href="#5-如何从低范式到更高级别的范式"></a> 5 如何从低范式到更高级别的范式？</h3><p>同上…</p><p>个人学习笔记，说的不对或请指正！！</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-函数依赖xrightarrowy&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-函数依赖xrightarrowy&quot;&gt;&lt;/a&gt; 1 函数依赖X&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;→&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;\rightarrow&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.36687em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;→&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;Y&lt;/h3&gt;
&lt;h4 id=&quot;11-什么是函数依赖&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#11-什么是函数依赖&quot;&gt;&lt;/a&gt; 1.1 什么是函数依赖？&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;函数依赖X&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;→&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;\rightarrow&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.36687em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;→&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;Y&lt;/strong&gt;: X和Y都是属性(集合)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个X的值，只对应一个Y&lt;/li&gt;
&lt;li&gt;一个Y，可能对应不止的X&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;X&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;→&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;\rightarrow&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.36687em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;→&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;Y&lt;/strong&gt; 的意思是X&lt;strong&gt;函数决定&lt;/strong&gt;Y，或Y&lt;strong&gt;函数依赖&lt;/strong&gt;于X，X是Y的&lt;strong&gt;决定&lt;/strong&gt;元素&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://luo41.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://luo41.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库" scheme="https://luo41.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>《计算机网络》网络层</title>
    <link href="https://luo41.top/2021/05/31/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>https://luo41.top/2021/05/31/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%BD%91%E7%BB%9C%E5%B1%82/</id>
    <published>2021-05-31T02:31:02.000Z</published>
    <updated>2021-06-13T03:35:28.511Z</updated>
    
    <content type="html"><![CDATA[<p>网络真是太复杂了…感觉很多东西单独理解起来很简单，但合起来内容就变得很复杂，懂完过一阵子就忘记了。</p><p>最近计算机网络课学到了网络层了，本文仅是自己对课本学习内容的一个整理，方便期末复习(其实也没怎么整理，本文<strong>巨长，阅读请谨慎</strong>！！！)</p><p>参考书籍是 <strong>谢希仁</strong> 《计算机网络》第七版</p><span id="more"></span><h4 id="网络层提供什么样的服务"><a class="markdownIt-Anchor" href="#网络层提供什么样的服务"></a> 网络层提供什么样的服务？</h4><p>在计算机网络领域，网络层应该向运输层提高怎样的服务，是<strong>面向连接</strong>还是<strong>无连接</strong>？曾引起了长期的争论。争论的焦点的实质就是：在计算机通信中，<strong>可靠交付应当由谁来负责？<strong>是</strong>网络</strong>还是<strong>端系统</strong>？</p><ul><li><p>支持<strong>面向连接</strong>的人认为，坚持让网络借助电信网的成功经验，让<strong>网络负责可靠交付</strong>。他们认为网络的实现是：当两台计算机进行通信时，应当先建立连接，思路是建立一条<strong>虚电路VC Virtual Circult</strong>，虚电路预留双方通信所需的<strong>一切网络资源</strong>，然后双方就沿着已建立的虚电路发送分组。在分组交换中，分组的首部不需要填写完整的目的主机地址，而只需要填写这条虚电路的编号，因此减少了分组的开销。<br>采用虚电路的通信方式，分组<strong>无差错按序</strong>到达终点，不丢失，也不重复。在通信结束后释放建立了的虚电路。如图，主机H1和H2之间交换的分组都必须在实现建立的虚电路上传送。如图：</p><img src="/2021/05/31/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%BD%91%E7%BB%9C%E5%B1%82/1.jpg" style="zoom:50%;"></li><li><p>互联网的先驱者却提出了一种崭新的网络设计思路，采用<strong>无连接</strong>的方式。<br>设计的思路是这样的：<strong>网络层向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务</strong>。网络在发送分组不需要先建立连接。每一个分组(也就是IP数据报)<strong>独立</strong>发送，与其他分组无关。<strong>网络层不提供服务质量的承诺</strong>。所传送的分组<strong>可能出错，丢失，重复和失序，也不保证分组交付的时间</strong>。这种设计的好处是：网络不提供端到端的可靠传输服务，因此路由器的设计比较简单，造价也便宜。网络造价大大降低，运行方式也更加灵活。如图，主机H1和H2发送的分组各自独立地选择路由，并且在传送的过程中可能会丢失。</p></li><li><img src="/2021/05/31/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%BD%91%E7%BB%9C%E5%B1%82/2.jpg" style="zoom:80%;"><p>下图归纳了<strong>虚电路服务和数据报服务的对比</strong>:</p><img src="/2021/05/31/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%BD%91%E7%BB%9C%E5%B1%82/3.jpg" style="zoom: 25%;"></li></ul><h4 id="网际协议ip"><a class="markdownIt-Anchor" href="#网际协议ip"></a> 网际协议IP</h4><p>网际协议IP是TCP/IP体系中两个最主要的协议之一，也是最重要的互联网标准协议之一。IP协议又称为Kahn-Cerf协议，以纪念它的两个研发者Robert Kahn和Vint Cerf。与IP协议配套使用的还有三个协议：</p><ul><li><strong>地址解析协议ARP(Address Resolution Protocol)</strong></li><li><strong>网际控制报文协议ICMP(Internet Control Message Protocol)</strong></li><li><strong>网际组管理协议IGMP(Internet Group Management Protocol)</strong></li></ul><p>他们都属于<strong>网际协议</strong>，下图画出了这三个协议和IP协议的关系，ARP在最下面，因为IP协议经常需要ARP协议的辅助(后面会说到)，而ICMP和IGMP协议画在网际协议的上部，因为它们要用到IP协议。</p><img src="/2021/05/31/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%BD%91%E7%BB%9C%E5%B1%82/4.jpg" style="zoom: 15%;"><h5 id="虚拟互连网络"><a class="markdownIt-Anchor" href="#虚拟互连网络"></a> 虚拟互连网络：</h5><p>我们知道，要把全世界方位内数百万计的网络互连起来将会非常复杂，需要解决很多的问题如：不同的寻址方案，不同的差错恢复方法，不同的服务，不同的管理和控制方式等等，<strong>没有一种单一的网络能够适应所有用户的需求</strong>。</p><p>从一般的概念讲，将网络互相连接起来要使用一些<strong>中间设备</strong>，根据设备所处的层次大概有四种不同的中间设备：</p><ul><li><strong>转发器</strong>：<strong>物理层</strong>中使用的中间设备</li><li><strong>网桥或桥接器</strong>：<strong>数据链路层</strong>中使用的中间设备</li><li><strong>路由器</strong>：<strong>网络层</strong>使用的中间设备</li><li><strong>网关</strong>： 网络层以上使用的中间设备</li></ul><p>用转发器或网桥作为中间设备，仅仅是将<strong>一个网</strong>扩大了，从网络层的角度上看，这仍然是<strong>一个网络</strong>，我们<strong>并不称为网络互连</strong>。我们现在指的<strong>网络互连</strong>一般都是指用路由器进行网络互连和路由选择。</p><p>下面这张图表示有<strong>许多计算机网络通过众多路由器</strong>进行了互连，由于<strong>参加互连的计算机网络都使用相同的网际协议IP(Internet Protocal)</strong>,所以可以把互连后的计算机网络看成如图所示的一个<strong>虚拟互联网络</strong>，这些使用IP协议的虚拟互连网络也可简称为<strong>IP网</strong>。</p><img src="/2021/05/31/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%BD%91%E7%BB%9C%E5%B1%82/5.jpg" style="zoom: 25%;"><p>使用IP网的好处是当IP网上的主机进行通信时，就<strong>好像在一个单个网络上通信一样</strong>，忽略了互连的各网络的具体异构细节(不知道可不可以用一个计算机名词来形容：<strong>透明</strong>：指在计算机的实现中客观存在的但我们一般不太需要去了解它的很多细节)。</p><p>如果在这种覆盖全球的<strong>IP网</strong>的上层使用TCP协议，就成为了现在的<strong>互联网</strong>了。</p><p>这里需要指出<strong>互联网(Internet)<strong>并不等于</strong>互连网(internet)</strong>,互连网泛指由多个计算机网络互连而成的网络，在这些网络之间的通信协议可以是任意的，而<strong>互联网</strong>采用的协议是<strong>TCP/IP协议族</strong>作为通信的规则，可以粗略的理解为<strong>互联网是互连网的一种实现</strong>。</p><h5 id="直接交付和间接交付"><a class="markdownIt-Anchor" href="#直接交付和间接交付"></a> 直接交付和间接交付</h5><p>直接交付和间接交付的区别，简单举例，假设如图的主机H1要把一个IP数据包发送给目的主机H2。主机H1首先会查找自己的路由表，如果目的主机在本网络上(与路由器直接相连的网络)，则不需要通过任何路由器<strong>直接交付</strong>，如不是，必须先把IP数据报发送给某个路由器(如图中的R1)进行<strong>间接交付</strong>。</p><img src="/2021/05/31/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%BD%91%E7%BB%9C%E5%B1%82/14.jpg" style="zoom: 50%;"><h5 id="分类的ip地址"><a class="markdownIt-Anchor" href="#分类的ip地址"></a> 分类的IP地址</h5><p>整个互联网就是一个<strong>单一的，抽象的网络</strong>。IP地址就是给互联网上的每一台主机(或路由器)的每一个接口分配一个在全世界范围内是<strong>唯一的32位</strong>的标识符。</p><p><strong>分类的IP地址</strong>就是将<strong>32位的IP</strong>地址划分为若干个固定的类，包括A,B,C,D,E五类地址。每一类的地址都由两个字段：<strong>网络号和主机号</strong>构成。IP地址之所以在全世界范围是唯一的，原因是<strong>一个网络号在整个互联网范围内是唯一的</strong>。</p><p>这种两级的IP地址可以记为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>P</mi><mi mathvariant="normal">地</mi><mi mathvariant="normal">址</mi><mo>=</mo><mo>&lt;</mo><mi mathvariant="normal">网</mi><mi mathvariant="normal">络</mi><mi mathvariant="normal">号</mi><mo>&gt;</mo><mo separator="true">,</mo><mo>&lt;</mo><mi mathvariant="normal">主</mi><mi mathvariant="normal">机</mi><mi mathvariant="normal">号</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">IP地址= &lt;网络号&gt;,&lt;主机号&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord cjk_fallback">地</span><span class="mord cjk_fallback">址</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">网</span><span class="mord cjk_fallback">络</span><span class="mord cjk_fallback">号</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">主</span><span class="mord cjk_fallback">机</span><span class="mord cjk_fallback">号</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span></span></p><p>下图给出了五类IP地址的网络号字段和主机号字段各自的位数：</p><img src="/2021/05/31/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%BD%91%E7%BB%9C%E5%B1%82/6.jpg" style="zoom: 15%;"><p>A类,B类,C类地址都是<strong>单播地址</strong>，是最常用的。D类地址为<strong>多播地址。</strong></p><p>IP地址都是32位的二进制代码，为了提高可读性，采用了每8位为一个单位的<strong>点分十进制记法</strong>：每8位代表一位十进制数，中间用点隔开。</p><p>如10000000 00001011 00000011 00011111可以读为128.11.3.31。</p><p>注意1：IP地址中的<strong>全0的网络号</strong>表示**”这个(this)“<strong>。意思是</strong>”本网络“<strong>，是个保留地址。第二，网络号为127，也就是01111111保留作为本地软件</strong>环回测试**，所以<strong>网络号为127的地址不作为一个网络地址</strong>。</p><p>注意2：<strong>全0的主机号</strong>(与上面区分，上面说的是网络号全0，这里指的是主机字段全0)，表示的是该IP地址是”本主机“所连接到的<strong>单个网络地址</strong>，例如，一主机的IP地址为5.6.7.8，则该主机所在的网络地址就是5.0.0.0，<strong>所以一般不会分配给某一台主机全0的主机号</strong>。而主机号全1表示**”所有的“(all)**,表示该网络上的所有主机。</p><p>如B类地址128.7.255.255(255为全1的十进制)，表示**”在网络128.7.0.0上的所有主机“<strong>。 而A类地址0.0.0.35，网络号为全0，表示本网络，主机号为35，所以表示的意思是</strong>”在本网络上主机号为35的主机**。</p><p>下图给出<strong>IP地址的指派范围</strong>和<strong>一般不使用的特殊IP地址</strong>：</p><img src="/2021/05/31/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%BD%91%E7%BB%9C%E5%B1%82/7.jpg" style="zoom: 20%;"><p>下面介绍IP地址一些重要的特点：</p><ul><li><p>IP地址由网络号和主机号组成，是一种分等级的地址结构。这种结构的好处首先是IP地址管理机构在分配地址的时候可以<strong>只分配网络号，主机号由各单位自己分配</strong>，就比如中国移动给某个学校分配一个C类地址的网络号，学校自行给校内主机编主机号。其次，路由器<strong>仅根据目的主机所连接的网络号转发分组</strong>，不考虑目的主机号，加快了查询的速度。</p></li><li><p>按照互联网的观点，一个网络指的是具有<strong>相同网络号的主机的集合</strong>，所以用<strong>转发器或网桥</strong>连接起来的若干个局域网仍为一个网络，因此这些局域网都具有相同的网络号。<strong>具有不同网络号的局域网必须使用路由器进行互连</strong>。</p></li></ul><h5 id="ip地址与硬件地址"><a class="markdownIt-Anchor" href="#ip地址与硬件地址"></a> IP地址与硬件地址</h5><p>硬件地址又称物理地址，MAC地址。</p><ul><li><strong>物理地址</strong>是数据链路层和物理层使用的地址</li><li><strong>IP地址</strong>是网络层和以上各层使用的地址，是一种逻辑地址</li></ul><p><strong>IP地址和MAC地址的区别</strong>：可以简单这么理解：</p><p><strong>从负责的层次角度来看</strong>：<strong>IP地址负责的是网络层和网络层以上层的运输，而物理地址负责的是数据链路层及以下层的运输</strong>。</p><p>发送数据报时，当上层使用IP数据报一旦交给了数据链路层，就被封装成MAC帧了，而MAC帧在传送时使用的源地址和目的地址都是物理地址。收到数据报时，主机收下MAC帧后，将数据报上传给网络层后，网络层会获取数据报中的源IP地址和目的IP地址，再进行后面的处理。</p><p><strong>从可不可以改变的角度来看</strong>：<strong>IP地址一般是可以改变的，而MAC地址一般不可以改变(要改变一般要修改硬件)</strong></p><p>但MAC地址和IP地址都可以我们标识一台主机的身份，MAC地址类似我们的姓名，而IP地址类似我们的学号。但我们改变了我们主机连接的网络(类似于升学),IP地址(学号)一般会改变，而MAC地址(姓名)一般不会改变。</p><h5 id="地址解析协议arp"><a class="markdownIt-Anchor" href="#地址解析协议arp"></a> 地址解析协议ARP</h5><p>APR协议简单地说就是<strong>在一个局域网上，根据某主机的IP地址找到该主机的MAC地址</strong>的一种协议。之所以需要知道MAC地址，是因为在数据链路层及以下的层次转发数据报需要MAC地址。</p><h5 id="ip数据报的格式"><a class="markdownIt-Anchor" href="#ip数据报的格式"></a> IP数据报的格式</h5><p>IP数据报的格式如图：</p><img src="/2021/05/31/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%BD%91%E7%BB%9C%E5%B1%82/8.jpg" style="zoom: 25%;"><p>下面对各字段的解释：</p><ol><li><p><strong>版本</strong>：占4位，指IP协议的版本，目前广泛使用的版本号为4(IPV4)。</p></li><li><p><strong>首部长度</strong>：占4位，表示最大十进制数为15，<strong>注意首部长度的单位为32个字也就是四个字节</strong>，所以首部长度最大可为15*4=60字节。因为以32个字为单位，IP分组的首部长度不是4字节的整数倍时，需要<strong>填充</strong>。也因此数据报的数据部分永远在4字节的整数倍开始。<br>最常用的首部长度是20字节(没有可选字段)，也就是0101。</p></li><li><p>区别服务：没有被实际用过。</p></li><li><p><strong>总长度</strong>：占16位，指的是<strong>首部和数据部分的长度和</strong>。</p></li><li><p><strong>标识</strong>：占16位。每一个数据报都有一个标识位，因为当数据报大于数据帧的最大长度：我们称之为<strong>最大传送单元MTU Maximum Transfer Unit</strong>,需要进行分片转发。<strong>同一数据报分片后标识字段的值仍然是是相同的</strong>，这样在目的主机收到这些分了片的数据报后，就能<strong>根据相同的标识字段将分片后的各数据报正确地重装为原来的数据报</strong>。</p></li><li><p><strong>标志位</strong>：占3位，目前只有2位有意义。</p><ul><li>标志字段的最低位为<strong>MF</strong> MF=1 表示后面还有分片，MF=0表示这已经是数据报片的最后一片了。</li><li>标志字段的中间一位为<strong>DF</strong> DF=1 意思为不能分片 DF=0 才允许分片。</li></ul></li><li><p><strong>片偏移</strong>：占13位。片偏移表示的是在分组分片后，某片在原分组的相对位置。<strong>片偏移</strong>以8个字节为偏移单位。也就是说，每个分片的长度一定是8字节(64位)的整数倍。<strong>标识</strong>位让我们知道是<strong>哪一个数据报</strong>，<strong>片偏移</strong>让我们知道了被分片了的某一块数据报是原来数据报里面的<strong>哪一块</strong>，加上标志位就可以<strong>不出差错的重组</strong>我们收到的多个数据报。</p></li><li><p><strong>生存时间</strong>：占8位 <strong>TTL Time To Live</strong>表明数据报在网络中的<strong>寿命</strong>。其目的是防止<strong>无法交付的数据报无限制地在互联网中兜圈子</strong>。具体是实现我们叫做**“跳数限制”<strong>。路由器在每次转发数据报</strong>之前<strong>就把TTL值减1，若TTL值减小到0，就丢弃这个数据报，不再转发。显然：数据报能在互联网中经过的路由器的最大数值是</strong>255**。利用TTL的属性，我们有时候把TTL的初始值设置为1，<strong>表示这个数据报只能在本局域网中传送</strong>。</p></li><li><p><strong>协议</strong>：占8位，指出该数据报携带的数据使用了何种协议。</p></li><li><p><strong>首部检验和</strong>：占16位。这个字段<strong>只检验数据报的首部，不包括数据部分</strong>。具体计算方法为：在发送方，先把IP数据报首部划分为许多16位字的序列，并把检验和字段置零。用反码算术运算把16位字相加后，将得到的<strong>和的反码</strong>写入检验和字段。接收方收到数据报后，将首部的所有16位再使用反码算术运算相加一次，将得到的<strong>和取反码</strong>，即得出接收方检验和的计算结果。若首部未发生任何变化，则此结果必为0。</p></li><li><p><strong>源地址</strong>：32位的IP地址</p></li><li><p><strong>目的地址</strong>：32位的目的IP地址</p></li></ol><h5 id="路由表"><a class="markdownIt-Anchor" href="#路由表"></a> 路由表</h5><p>每一条路由最主要是两个信息(<strong>目的网络地址</strong>，<strong>下一条的地址</strong>)</p><h4 id="划分子网和构造超网"><a class="markdownIt-Anchor" href="#划分子网和构造超网"></a> 划分子网和构造超网</h4><h5 id="划分子网"><a class="markdownIt-Anchor" href="#划分子网"></a> 划分子网</h5><h6 id="为什么要划分子网"><a class="markdownIt-Anchor" href="#为什么要划分子网"></a> 为什么要划分子网？</h6><p>在今天看来，IP地址的设计不够合理。原因有：</p><ul><li><strong>IP地址空间的利用率有时很低</strong></li><li>给每一个物理网络分配一个网络号会使得<strong>路由表变得太大</strong>而使网络性能变坏。</li><li><strong>两级IP地址不够灵活</strong>。</li></ul><p>为解决上述问题，我们在IP地址中又增加了一个<strong>子网号</strong>字段，使得两级IP地址变成为<strong>三级IP地址</strong>，这种做法也叫做<strong>划分子网</strong>，或子网寻址或子网路由选择。</p><h6 id="划分子网的基本思路"><a class="markdownIt-Anchor" href="#划分子网的基本思路"></a> 划分子网的基本思路</h6><p>划分子网的基本思路，简单的两句话，一是<strong>内部划分</strong>，二是<strong>对外仍然表现为一个网络</strong>。</p><p>一个拥有许多物理网络的单位，可将所属的物理网络划分为<strong>若干个子网</strong>。划分子网纯属一个单位内部的事情，本单位以外的网络<strong>看不见</strong>这个网络是由多少个子网组成，这个单位<strong>对外仍然表现为一个网络</strong>。</p><h6 id="划分子网的具体方法"><a class="markdownIt-Anchor" href="#划分子网的具体方法"></a> 划分子网的具体方法</h6><p>划分子网的具体方法是<strong>从网络的主机号</strong>借用若干位作为<strong>子网号</strong>。因此主机号也就减少了相应的位数，于是两级IP地址在<strong>本单位内部</strong>就变成了<strong>三级IP地址</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>P</mi><mi mathvariant="normal">地</mi><mi mathvariant="normal">址</mi><mo>=</mo><mo>&lt;</mo><mi mathvariant="normal">网</mi><mi mathvariant="normal">络</mi><mi mathvariant="normal">号</mi><mo>&gt;</mo><mo separator="true">,</mo><mo>&lt;</mo><mi mathvariant="normal">子</mi><mi mathvariant="normal">网</mi><mi mathvariant="normal">号</mi><mo>&gt;</mo><mo separator="true">,</mo><mo>&lt;</mo><mi mathvariant="normal">主</mi><mi mathvariant="normal">机</mi><mi mathvariant="normal">号</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">IP地址=&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord cjk_fallback">地</span><span class="mord cjk_fallback">址</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">网</span><span class="mord cjk_fallback">络</span><span class="mord cjk_fallback">号</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">子</span><span class="mord cjk_fallback">网</span><span class="mord cjk_fallback">号</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">主</span><span class="mord cjk_fallback">机</span><span class="mord cjk_fallback">号</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span></span></p><p>于是乎，凡是从<strong>其他网络</strong>发送给本单位某台主机的IP数据报，仍然是<strong>根据IP数据报的网络号</strong>找到连接在本单位网络上的路由器。但此路由器在收到IP数据报后，再按照目的网络和子网号找到<strong>目的子网</strong>，把IP数据报交付给主机。</p><p>比如下面这个例子：</p><img src="/2021/05/31/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%BD%91%E7%BB%9C%E5%B1%82/9.jpg" style="zoom: 15%;"><p>图中表示某单位拥有一个B类IP地址，网络地址为145.13.0.0(网络号为145.13)。凡是目的地址为145.13.x.x的数据报都先发送这个网络的路由器R1。<strong>R1再根据数据报的目的地址把数据报转发到相应的子网</strong>。</p><h5 id="子网掩码"><a class="markdownIt-Anchor" href="#子网掩码"></a> 子网掩码</h5><h6 id="如何找到子网"><a class="markdownIt-Anchor" href="#如何找到子网"></a> 如何找到子网？</h6><p><strong>上面我们讲到了R1要根据数据报的目的地址把数据报转发到相应的子网</strong>，那么问题就很自然地来了，如何找到子网？从IP数据报的首部是无法看出子网的划分的。解决方法就是<strong>子网掩码</strong>。</p><p>如图：IP地址为145.13.3.10的主机本身是两级IP地址结构，网络号为145.13.0.0。如果我们用三级IP地址结构去解释这个IP地址，主机号拿出<strong>8位作为子网号</strong>，则网络号为145.13.3.0。为了使路由器R1能够很<strong>方便地从数据报中的目的IP地址中提取出所要找的子网的网络地址</strong>，路由器就要使用三级地址的子网掩码。三级地址的子网掩码这里也是32位的，由一串24个1和跟随的一串8个0组成。</p><img src="/2021/05/31/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%BD%91%E7%BB%9C%E5%B1%82/10.jpg" style="zoom: 15%;"><p><strong>子网掩码中1的位数对应于IP地址中原来二级地址中的16位网络号和新加上的8位子网号，而0的位数对应于主机号所占的位数</strong></p><p>把三级IP地址的子网掩码和收到的数据报中的目的IP地址进行<strong>与运算</strong>，就可以得到我们要的<strong>子网的网络地址</strong>，解决了如何找到子网的问题。</p><p><strong>归述</strong>，对于IP地址145.13.0.0从网络<strong>外面</strong>看，这就是一个普通的B类网络，网络号为145.13.0.0。但<strong>进入</strong>到这个网络后(即到了路由器R1)，我们对该网络进行了不同的子网划分，记录下子网掩码，就看到了还有许多网络。如我们设置子网掩码为24个1和8个0，其内部的网络地址就变为145.13.x.0。x可以为不同的数值，表示不同的子网。再次显示了子网设计的基本思路：<strong>内部划分</strong>，<strong>对外仍表现为一个网络</strong>。</p><h6 id="默认子网掩码"><a class="markdownIt-Anchor" href="#默认子网掩码"></a> 默认子网掩码</h6><p>在不划分子网时，虽然没有子网，但为了方便路由表查找的统一性，使用<strong>默认子网掩码</strong></p><ul><li><p>A类地址的默认子网掩码为255.0.0.0</p></li><li><p>B类地址的默认子网掩码为255.255.0.0</p></li><li><p>C类地址的默认子网掩码为255.255.255.0</p></li></ul><h6 id="路由表的改变"><a class="markdownIt-Anchor" href="#路由表的改变"></a> 路由表的改变</h6><p><strong>子网掩码是一个网络或一个子网的重要属性</strong>。在划分了子网后，路由器在和相邻路由器交换路由信息时，必须把自己所在网络(或子网)的<strong>子网掩码告诉相邻路由器</strong>。</p><p>我们之前提到，路由表的每一条目有两个信息(目的网络地址，下一跳的地址)。但在划分完子网后，除了要给出目的网络地址外，还<strong>必须同时给出该网络的子网掩码</strong>。所以路由表的每一条两个三个信息(<strong>目的网络地址</strong>，<strong>目的网络地址的子网掩码</strong>，<strong>下一跳的地址</strong>)。</p><p>现在路由表是如何工作的呢？原理挺简单，当路由表收到数据报，从首部提取出目的IP地址D，与路由表中各网络的子网掩码进行逐为与操作，与其对应的目的网络地址匹配，若<strong>匹配则直接交付或将数据报传给下一跳路由器</strong>。</p><p><strong>总结</strong>：<strong>划分子网增加了灵活性，但却减少了能够连接在网络上的主机总数</strong>。原因很简单：划分子网使得能划分出来的网络更多了，而每个网络总要排除全0的主机号和全1的总机号，一般这两个不作为主机的IP地址，所以减少了能够连接在网络上的主机总数。</p><h5 id="构造超网无分类编址cidr"><a class="markdownIt-Anchor" href="#构造超网无分类编址cidr"></a> 构造超网(无分类编址CIDR)</h5><h6 id="为什么要采用无分类编址"><a class="markdownIt-Anchor" href="#为什么要采用无分类编址"></a> 为什么要采用无分类编址？</h6><p>划分子网在一定程度上缓解了互联网在发展中遇到的困难，但是仍面临着<strong>B类地址已经要全部分配完毕，互联网主干网上的路由表中的项目数目急剧增长</strong>。因此，IETF研究出<strong>无分类编址</strong>的方法来解决问题。</p><h6 id="什么是无分类编址"><a class="markdownIt-Anchor" href="#什么是无分类编址"></a> 什么是无分类编址</h6><p>无分类编址的正式名字是<strong>无分类域间路由选择CIDR(Classless Inter-Domain Routing)</strong>，它的主要特点有两个：</p><ul><li><p><strong>消除了传统的A类，B类，C类地址以及划分子网的概念。<strong>把32位的IP地址划分为前后两个部分，前面部分为</strong>网络前缀</strong>，或简称为<strong>前缀</strong>，用来指明网络，后面部门则用来表面主机。其实就是一种<strong>无分类的两级编址</strong>，记法为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>P</mi><mi mathvariant="normal">地</mi><mi mathvariant="normal">址</mi><mo>=</mo><mo>&lt;</mo><mi mathvariant="normal">网</mi><mi mathvariant="normal">络</mi><mi mathvariant="normal">前</mi><mi mathvariant="normal">缀</mi><mo>&gt;</mo><mo separator="true">,</mo><mo>&lt;</mo><mi mathvariant="normal">主</mi><mi mathvariant="normal">机</mi><mi mathvariant="normal">号</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">IP地址=&lt;网络前缀&gt;,&lt;主机号&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord cjk_fallback">地</span><span class="mord cjk_fallback">址</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">网</span><span class="mord cjk_fallback">络</span><span class="mord cjk_fallback">前</span><span class="mord cjk_fallback">缀</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">主</span><span class="mord cjk_fallback">机</span><span class="mord cjk_fallback">号</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span></span></p><p>同时，CIDR还使用<strong>斜线记法</strong>，或称<strong>CIDR记法</strong>，即在IP地址后面加上斜线“/”，然后写上网络前缀所占IP地址的位数。</p></li><li><p><strong>CIDR</strong>把<strong>网络前缀相同</strong>的连续的IP地址组成一个<strong>CIDR地址块</strong>。我们只要知道CIDR地址块中的任何一个地址，就可以知道这个地址块的最小地址和最大地址，以及地址块中的地址数。</p><p>例如，IP地址128.14.35.7/20 是某CIDR地址块中的一个地址，其前20位是网络前缀，只要把IP地址的二进制写出来，进行简单修改很容易就知道，这个地址块中的最小地址为128.14.32.0，最大地址为128.14.47.255。</p><p>我们通常<strong>用最小地址和网络前缀的位数指明一个CIDR地址块</strong>，例如上面的地址块可以表示为128.14.32.0/20。</p></li></ul><h6 id="地址掩码"><a class="markdownIt-Anchor" href="#地址掩码"></a> 地址掩码</h6><p>为了更方便地进行路由选择，CIDR使用32位的<strong>地址掩码</strong>。<strong>地址掩码由一串1和一串0组成</strong>，与子网掩码是一样的，不过地址掩码<strong>1的位数</strong>等于<strong>网络前缀的长度</strong>，而子网掩码的1的位数等于网络号的长度。之所以要引进<strong>地址掩码</strong>，是因为CIDR根本就不使用子网(指的是并没有直接指明若干位作为子网号），自然也不存在什么子网掩码。</p><p>但分配到一个CIDR地址块的单位，仍然可以在本单位内部根据需要“<strong>划分子网</strong>”，这些子网也都只有一个网络前缀和一个主机号字段。其实也可以理解为，<strong>这里说的子网也就是前缀更长些的CIDR块</strong>，有了更长的前缀，就可以划分出更多的网络。</p><h6 id="路由聚合"><a class="markdownIt-Anchor" href="#路由聚合"></a> 路由聚合</h6><p>前面我们提到<strong>互联网主干网上的路由表中的项目数目急剧增长</strong>。CIDR设计解决这个问题的方法是<strong>路由聚合</strong>。</p><p>由于一个CIDR地址块有很多的地址，所以在路由表中就利用<strong>CIDR地址块</strong>来查找目的网络，这种地址的聚合就称之为<strong>路由聚合</strong>。它<strong>使得路由表中的一个项目可以表示原来传统分类地址的很多个路由，以此减少表项目</strong>。路由聚合也称为<strong>构成超网</strong>。</p><p><strong>每一个CIDR地址块中的地址数一定是2的整数次幂。</strong></p><p><strong>下面给出一个CIDR地址块分配的例子</strong>：</p><p>假定某ISP(互联网服务提供商如中国移动)拥有地址块206.0.64.0/18，也就是相当于有64个C类网络。现在某大学需要800个IP地址，ISP可以给该大学分配一个地址块206.0.68.0/22，它包括1024个IP地址。然后这个大学可以自由地对本校的各系分配地址块，各系还可以再划分地址块。如下图：</p><img src="/2021/05/31/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%BD%91%E7%BB%9C%E5%B1%82/11.jpg" style="zoom: 20%;"><p>对于该图，我们分析<strong>地址聚合</strong>的意义。</p><p>这个ISP共拥有64个C类网络，如果不采用CIDR技术，则与在与该ISP的路由器交换路由信息的每一个路由器的路由表中，<strong>都需要有64个项目</strong>。但采用路由聚合后，就只需要路由聚合后的一个项目206.0.64.0/18就可以找到该ISP。同理，四个系的路由也可以聚合为大学的路由<strong>206.0.65.0/22</strong>，简单地理解就是这个项目就是大学的收发室，寄给这个大学任何一个系的邮件，邮递员都不会考虑大学各个系的地址，而是不管三七二十一把邮件集中投递到大学的收发室，然后剩下的就交给大学的收发室，这样就减轻了邮递员的工作量，只需要把邮件发给某个大学，不管大学如何再把这封信交给各个系(相当于<strong>简化了路由表的查找</strong>)。</p><p>结论：<strong>路由聚合</strong>实际上是将<strong>网络前缀缩短</strong>，网络前缀越短，其地址块所包含的地址数越多。</p><p><strong>最长前缀原则</strong>：在使用CIDR时，因为采用了网络前缀的这种记法，在查找路由表时可能<strong>会得到不止一个匹配结果</strong>，出现这种情况，<strong>我们应当从匹配结果中选择具有最长网络前缀的路由</strong>，也称之为<strong>最长前缀匹配</strong>。仍然用前面的例子，在ISP的路由表中，有以下两个项目，即206.0.68.0/22(大学)和206.0.71.128/25(四系)。现假设ISP收到一个数据报，其目的IP地址为D=206.0.71.130分别与这两个项目的掩码逐位与，得到结果206.0.68.0/22和206.0.71.128/25都匹配。这是我们选择后者，因为它是更具体的一个。</p><h4 id="网际控制报文协议icmp"><a class="markdownIt-Anchor" href="#网际控制报文协议icmp"></a> 网际控制报文协议ICMP</h4><p>网际控制报文协议的出现，是为了<strong>更有效地转发IP数据报和提高交付的机会</strong>。ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。</p><p>ICMP报文是装在IP数据报中，作为其中的数据部分，是IP层的协议。ICMP报文格式如下图：</p><h5 id="icmp报文的种类"><a class="markdownIt-Anchor" href="#icmp报文的种类"></a> ICMP报文的种类</h5><p>ICMP报文的种类有两种，<strong>ICMP差错报告报文</strong>和<strong>ICMP询问报文</strong>。</p><p>常用的ICMP报文类型，如图：</p><img src="/2021/05/31/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%BD%91%E7%BB%9C%E5%B1%82/12.jpg" style="zoom: 20%;"><p>ICMP检验和字段用来<strong>检验整个ICMP报文</strong>，前面提到，IP数据报的首部的检验并不检验IP数据报的内容，因此无法保证经过传输的ICMP报文不产生差错。</p><h5 id="icmp差错报文"><a class="markdownIt-Anchor" href="#icmp差错报文"></a> ICMP差错报文</h5><p>ICMP差错报文共有四种：</p><ul><li><strong>终点不可达</strong>：当路由器或主机不能交付数据报时就向源点发送<strong>终点不可达报文</strong></li><li><strong>时间超过</strong>：路由器收到生存时间为0的数据报时，丢弃该数据报外，向源点<strong>发送时间超过报文</strong> 。当终点在预先规定的时间内<strong>不能收到一个数据报的全部数据报片时</strong>，丢弃数据报片，向源点<strong>发送时间超过报文</strong>。<strong>Traceroute</strong>就是利用了该原理。</li><li><strong>参数问题</strong>：当路由器或目的主机收到的<strong>数据报的首部中有的字段的值不正确</strong>(通过检查首部检验和)，就丢弃数据报，向源点<strong>发送参数问题报文</strong></li><li><strong>改变路由</strong>(<strong>重定向</strong>)：路由器把改变路由报文发送给主机，<strong>让主机知道下次数据报发送给另外的路由</strong>(可通过更好的路由)</li></ul><p><strong>不应发送ICMP差错报文报告的几种情况</strong>：</p><ul><li>对ICMP差错报告报文，不再发送ICMP差错报告报文(<strong>禁止套娃</strong>!!!)</li><li>对第一个分片的数据包片的所有后续数据报片，都不发送ICMP差错报告报文</li><li><strong>对具有多播地址的数据报</strong>，都不发送ICMP差错报告报文</li><li>对具有特殊地址的数据报，不发送ICMP差错报告报文。</li></ul><h5 id="icmp询问报文"><a class="markdownIt-Anchor" href="#icmp询问报文"></a> ICMP询问报文</h5><p>ICMP询问报文有两种</p><ul><li><strong>回送请求和回答</strong> ICMP回送请求报文是由主机或路由器向一个特定的目的主机<strong>发出的询问</strong>。<strong>收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文</strong>。这种询问可以用来测试目的站是否可达以及了解有关状态。如我们的cmd命令 <strong>PING</strong>就是利用回送请求与回送回答报文。</li><li><strong>时间戳请求和回答</strong>：ICMP时间戳请求报文是<strong>请某台主机或路由器回答当前的日期和时间</strong>。</li></ul><h4 id="ip多播"><a class="markdownIt-Anchor" href="#ip多播"></a> IP多播</h4><p>IP多播即一对多的通信</p><h6 id="以太网多播"><a class="markdownIt-Anchor" href="#以太网多播"></a> 以太网多播</h6><p>以太网网卡接收两种帧：</p><ul><li>目的MAC地址为本机网卡地址</li><li>目的MAC地址为广播地址(FF-FF-FF-FF-FF-FF)</li></ul><p>且以太网网卡对单播和广播，硬件判别能力很好。<strong>以太网多播地址的最高字节的最低位为1</strong>。</p><p><strong>以太网多播实现机制</strong>：目前网卡或网卡驱动软件能进行多播地址的判别与过滤，看主机是否属于一个或多个多播组，然后决定丢弃或接受。</p><h6 id="ip多播地址和地址映射"><a class="markdownIt-Anchor" href="#ip多播地址和地址映射"></a> IP多播地址和地址映射</h6><p>前面提到了D类地址，D类地址就是专用多播地址，范围为224.0.0.0~239.255.255.255</p><p><strong>一个D类多播地址对应一组计算机，这组计算机的集合成为多播主机组</strong>。主机组成员可以是因特网上的任何主机，成员是动态的。多播地址不是一般的IP主机地址，而是参加多播组的所有主机的组地址，为一组主机共有。</p><p>那么问题来了，当一个IP多播组传送到一个以太网时，如何传送到LAN中的几台计算机上？这就要知道<strong>IP多播到以太网多播地址转换</strong>。</p><p>IP多播包从路由网进入以太网前，通过<strong>多播地址的转换</strong>，把IP多播地址<strong>转化为相应的以太网硬件多播地址，然后利用以太网的多播机制完成多播</strong>。</p><p>IANA定义的可转化的以太网多播地址范围为：<strong>01:00:5e:00:00:00~01:00:5e:7f:ff:ff</strong>。</p><p>IP多播与以太网多播的映射关系如图（图源来自张老师PPT）</p><img src="/2021/05/31/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E7%BD%91%E7%BB%9C%E5%B1%82/13.png" style="zoom: 50%;"><p><strong>映射地址的前25bit是固定的</strong></p><h6 id="ip多播传送的基本过程"><a class="markdownIt-Anchor" href="#ip多播传送的基本过程"></a> IP多播传送的基本过程</h6><p>​    <strong>单个物理网络中的IP多播过程</strong>：</p><ol><li><p>发送主机的<strong>多播进程</strong>将目的IP地址设置为一个<strong>多播</strong>地址。</p></li><li><p>主机的设备驱动<strong>将IP多播地址转换为相应的以太网多播地址</strong>，并发送数据。</p></li><li><p>接收端的<strong>接收程序</strong>，先加入一个多播组，让驱动设备能够接收这些数据报。</p></li><li><p>当以太网以多播形式接收数据后，根据地址映射关系，传送给<strong>IP层相应的多播进程</strong>处理。</p><p><strong>多个物理网络中的IP多播过程</strong>：<br>比较复杂，需要使用支持多播的路由器，不太懂略。</p></li></ol><h6 id="igmp协议"><a class="markdownIt-Anchor" href="#igmp协议"></a> IGMP协议</h6><p>前面提到了多播的实现原理是利用多播组，那么<strong>主机如何加入或撤出多播组，多播组的状态如何维护？<strong>这就需要用到</strong>IGMP</strong>协议。</p><p>IGMP：Internet Group Management Protocol <strong>解决互联网中多播组成员的加入或撤出，多播组状态维护的问题</strong>。</p><p><strong>多播工作的两个阶段</strong>：</p><p>1 加入多播组：<strong>IGMP报告</strong>：主机A要加入一个多播组时，向多播地址发出一个IGMP报文，表明要成为组成员，本地多播路由收到该报文后，将该成员关系转发给互联网上的多播路由器，告诉大家有个B…站用户<strong>打不过就加入我们了</strong>，以后大家收到这个多播组的信息就传一份给他。</p><p>2 维护多播组：<strong>IGMP查询</strong>：A主机撤出多播组时，可以报告离开或不报告，多播组中成员是动态的。为了及时掌握组中的成员情况，多播路由器对所以多播组不断发出IGMP查询报文，<strong>问谁还在啊？还需要我给你转发多播数据报吗？<strong>根据组中各主机的响应判断还有哪些</strong>“活跃成员”</strong>，并将还存在的成员转告路由器，不活跃的成员就不再给他转发信息了。</p><p>本篇博客只是<strong>自己</strong>对课程学习的一些笔记和总结，大部分内容参考自**《计算机网络》**第七版，谢希仁编著。</p><p>如有出错(非常大可能会出错哈哈)，欢迎指正！</p><p>完…</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;网络真是太复杂了…感觉很多东西单独理解起来很简单，但合起来内容就变得很复杂，懂完过一阵子就忘记了。&lt;/p&gt;
&lt;p&gt;最近计算机网络课学到了网络层了，本文仅是自己对课本学习内容的一个整理，方便期末复习(其实也没怎么整理，本文&lt;strong&gt;巨长，阅读请谨慎&lt;/strong&gt;！！！)&lt;/p&gt;
&lt;p&gt;参考书籍是 &lt;strong&gt;谢希仁&lt;/strong&gt; 《计算机网络》第七版&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://luo41.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://luo41.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="网络层" scheme="https://luo41.top/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>Git教程学习笔记</title>
    <link href="https://luo41.top/2021/05/22/Git%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://luo41.top/2021/05/22/Git%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-05-21T23:55:10.000Z</published>
    <updated>2021-05-22T04:29:07.479Z</updated>
    
    <content type="html"><![CDATA[<p>廖雪峰老师的Git教程之前看过一遍，讲的很简单基础明了，入门应该是够了的，之后对Git的使用还是比较少，所以很多命令都忘记了，前阵子刚刚入门ctf(很弱很弱很弱的那种)有做到git泄露的题目，觉得有必要再了解一遍Git，所以这两天再看了一遍书，做一下笔记，方便查阅，但感觉还是要用起来，用起来，用起来才能记住，本文也只当做学习记录了。注意，<strong>本文略长且无营养</strong>，阅读请考虑仔细！！！</p><span id="more"></span><p>先罗列一下Git常用的指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init //将本地目录初始化为可管理的仓库</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add test.txt //将工作区的文件添加到暂存区，等待提交到版本库</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;modify what&quot;</span> //将暂存区的文件推送提交到版本库，-m后面输入的是本次提交的声明</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status  //查看工作区的当前状态</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff test.txt  //查看test.txt的修改变化</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> //查看历史提交记录</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --pretty=oneline //与git <span class="built_in">log</span>同，显示更加简洁</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard HEAD^ //回退到上一个版本</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard 版本号 //回退到具体版本号的那个版本，版本号可以用git <span class="built_in">log</span>查看</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reflog  //用来记录每次命令</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- filename //当你修改了工作区的文件filename，但还没有加入到暂存区，丢弃工作区对文件名为filename的修改</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset HEAD test.txt //修改了工作区的文件filename，但已经加入到了暂存区，先执行该命令，再执行上面的命令git checkout -- filename 即可以删除修改</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm test.txt</span>  </span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;删除了test.txt&quot;</span>  //两条的命令一起，删除test.txt文件</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add origin https://github.com/Github账户/Github仓库名.git  //与远程仓库关联</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin master //把当前分支master推送到远程仓库，首次推送加上-u参数，方面后面的推送,第二次开始开始不用加-u</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/Github账户/Github仓库名.git //从现有的远程仓库，克隆到我们的本地库</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch dev //新建分支branch dev</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout dev //切换到dev分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b dev //上面两条指令的结合体，相当于一次性执行上面两条语句</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch //查看分支情况</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge dev //将分支dev合并到当前分支上</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d dev //删除分支dev</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash //保留工作区现场</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash apply //恢复工作区现场，恢复后，stash内容并不删除</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash drop  //删除stash内容，与上面的git stash apply 配合使用</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash pop //恢复工作区现场并删除stash，相当于上面两条指令的结合体</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash list //查看已保存的工作现场</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -D name //name为分支名，该命令的效果为 丢弃一个没有合并过的分支</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v //查看远程库的信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin master //向远程库推送master分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b dev origin/dev //抓取分支，创建远程的dev分支关联本地的dev分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull //抓取分支</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag v1.0 //打标签,默认给master打标签</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag v0.9 74645665  // 74645665为对应commit ID的前几位</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -a v0.1 -m <span class="string">&quot;version 0.1 released&quot;</span> 3628164 //-a 指定标签名，-m 指定说明文字</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show v0.9 //显示标签v0.9的信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag //查看所有标签</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -d v0.1 //删除标签</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin v1.0   //推送标签到远程</span></span><br><span class="line">//或者</span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --tags  //一次性推送全部尚未推送到远程的本地标签</span></span><br><span class="line"></span><br><span class="line">//删除一个已经推送到了远程的标签</span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -d v0.9 //删除本地标签</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin :refs/tags/v0.9  //从远程删除标签</span></span><br></pre></td></tr></table></figure><h4 id="1-git简介"><a class="markdownIt-Anchor" href="#1-git简介"></a> 1 Git简介</h4><p>Git是目前世界上最先进的分布式版本控制系统。（<strong>没有之一！！！</strong>）</p><p>关于分布式版本控制系统，廖雪峰老师是这样描述</p><p><img src="/2021/05/22/Git%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png" alt></p><p>简而言之，我的理解大概就是<strong>用于多人协作开发项目(或修改文件)，并且每次都能记录文件的改动。</strong></p><h4 id="2-安装略"><a class="markdownIt-Anchor" href="#2-安装略"></a> 2  安装（<strong>略</strong>)</h4><p>​网上教程很多</p><h4 id="3-一些基本操作"><a class="markdownIt-Anchor" href="#3-一些基本操作"></a> 3  一些基本操作</h4><p>​<strong>创建版本库</strong></p><p>​ 创建一个版本库首先选一个合适的地方，创建一个空目录，右键点击git bash，在打开的命令行界面内，依次输入下面指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir dir1 //新建dir1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> dir1   //切换路径</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">pwd</span>       //显示当前的路径</span></span><br></pre></td></tr></table></figure><p>完成后文件夹是这个样子，尽量目录中不要出现中文，不然可能会报一些奇怪的错误</p><p><img src="/2021/05/22/Git%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.png" alt></p><p>一下是一些命令：</p><p>​<strong>git init</strong></p><p>​执行初始化命令将该目录变成Git可以管理的仓库,注意，命令的执行是要在该dir1目录下的，如果不是要先cd到 zz/dir1下在执行初始化语句</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Initialized empty Git repository in 路径 //就算成功</span><br></pre></td></tr></table></figure><p>成功后可以在dir1的目录下找到这个.git文件，看不到的可能要勾选一下文件夹隐藏的项目</p><img src="/2021/05/22/Git%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.png" style="zoom:80%;"><p>.git文件是Git来跟踪管理版本库的，一般不要手动修改这个目录里的文件，否则会破坏仓库</p><p>​<strong>git add</strong></p><p><strong>添加文件到版本库</strong></p><p>在dir1目录下新建一个test.txt，执行即添加成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add test.txt</span> </span><br></pre></td></tr></table></figure><p>​</p><p>​    <strong>git commit</strong></p><p>​ git commit命令，-m后面输入的是本次提交的说明，可以输入任意的内容，但最好是有意义的，这样你在之后能从历史记录里面可以根据commit看到每次修改的地方是什么，很方便。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;wrote a test.txt file&quot;</span></span></span><br></pre></td></tr></table></figure><p>git commit命令执行成功后悔提示你，哪个文件被改动了，具体改动了什么。</p><p><strong>为什么Git添加要分add,commit两步？</strong></p><p>因为可以执行多条add后，一次性commit提交。例如以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add test1.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add test2.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add test3.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;add test1,test2.test3 three files&quot;</span></span></span><br></pre></td></tr></table></figure><p>​<strong>git status</strong></p><p>​    git status命令可以随时掌握<strong>工作区</strong>(后面会提到)的当前状态</p><p>​    <img src="/2021/05/22/Git%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.png" alt></p><p>如当我们新建test文件，执行完git add  git commit命令后，执行git status，会提示我们</p><p>add 和 commit都已经完成了，工作目录是干净的。</p><p><strong>git diff</strong></p><p>我们对test.txt文件进行了修改，但是隔了一段时间忘记了修改了什么内容，这时候我们就可以执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff <span class="string">&quot;test.txt&quot;</span></span></span><br></pre></td></tr></table></figure><p><img src="/2021/05/22/Git%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.png" alt></p><p>这样就可以看到修改了什么内容了，确认修改无误后，提交到我们的仓库即可，提交修改和提交文件是一样的。执行以下两条指令即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add test.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;change the test.txt&quot;</span></span></span><br></pre></td></tr></table></figure><p>git diff一般配合git status使用，git status显示有文件被修改过，就可以用git diff查看修改内容。</p><h5 id="版本回退"><a class="markdownIt-Anchor" href="#版本回退"></a> <strong>版本回退</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span>   //查看历史记录</span></span><br></pre></td></tr></table></figure><p><img src="/2021/05/22/Git%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.png" alt></p><p>git log命令显示从最近到最远的提交日志，可以看到3次提交，简单查看也可以执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --pretty=oneline</span></span><br></pre></td></tr></table></figure><p><img src="/2021/05/22/Git%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.png" alt></p><p>（HEAD-master)表示的是<strong>当前的版本</strong>，前面黄颜色的一大串字符串表示一个版本ID <strong>Commit ID</strong></p><p>后面信息的表示版本修改了什么内容。</p><p>现在要将版本回退到上一个版本，也就是**”change the test.txt&quot;<strong>的版本，我们可以执行</strong>git reset**命令，如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard HEAD^ //此命令表示回退到前一个版本</span></span><br></pre></td></tr></table></figure><p>还可以执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard e71f58</span></span><br></pre></td></tr></table></figure><p>后面的e71f58正是**“change the test.txt&quot;**版本的版本号，不需要写全版本号，前几位就可以了(但为了防止多个版本号前几位相同导致冲突，尽量多写几位)</p><p><strong>Git版本回退的实现原理是Git在内部有个指向当前版本的指针HEAD，当回退版本时，仅仅是将HEAD的指向改变而已。</strong></p><p><strong>git reflog命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br></pre></td></tr></table></figure><p>用来记录每次命令的命令，可以实现**“穿梭未来**，如廖老师所讲：</p><p><img src="/2021/05/22/Git%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.png" alt></p><h4 id="4-工作区暂存区和版本库"><a class="markdownIt-Anchor" href="#4-工作区暂存区和版本库"></a> 4 工作区，暂存区和版本库</h4><p>工作区 <strong>Working Directory</strong>:就是在电脑里能看到的目录，比如前面的dir1文件夹就是一个工作区，也是我们直接添加和编辑文件的地方。</p><p>暂存区 <strong>Stage 或 Index</strong> 数据暂时存放的区域，可在工作区和版本库之间进行数据的友好交流。当我们执行**git add **时，实际上就是把工作区的文件修改添加到暂存区。</p><p>版本库  <strong>Repository</strong>：工作区有一个隐藏目录.git，这个文件夹不算工作者，而算Git的版本库，当我们执行完<strong>git commit</strong>，实际上就是<strong>把暂存区的所有内容一次性提交到当前分支</strong>。</p><p>三个分区的关系如图：</p><p><img src="/2021/05/22/Git%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.png" alt></p><p>在我们创建Git版本库时，Git自动为我们创建了<strong>唯一一个master分支</strong>，所以，commit就是往master分支上提交我们的修改。</p><p><strong>简单理解，就是执行完一个add，或连续完多个add，就是将修改文件添加到暂存区，然后执行一次commit就可以将暂存区的修改文件一次提交到版本库。</strong></p><h4 id="5-管理修改"><a class="markdownIt-Anchor" href="#5-管理修改"></a> 5 管理修改</h4><p>Git之所以比其他的版本控制系统更流行更好的原因，是因为**Git跟踪并管理的是修改，而非文件。**意思就是每次修改文件或新建文件，如果不执行add到暂存区，执行commit时是不会被加入到版本库中的。</p><p>​     <strong>撤销修改</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- test.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset HEAD test.txt</span></span><br></pre></td></tr></table></figure><p><img src="/2021/05/22/Git%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.png" alt></p><p><strong>撤销总结</strong>：</p><p><img src="/2021/05/22/Git%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.png" alt></p><h4 id="6-删除文件"><a class="markdownIt-Anchor" href="#6-删除文件"></a> 6 删除文件</h4><p>一般我们通常都会在文件管理器中删除掉文件，这样只是删除掉工作区的文件，那我们的版本库中还存在着这个文件，这时存在两种情况，第一是我们确实想要删除这个文件，并把该文件从版本库中删除，此时我们可以执行下面两条命令完成版本库中文件的删除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rm test.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;删除了test.txt文件&quot;</span></span></span><br></pre></td></tr></table></figure><p>另一种情况是我们删错了，不要慌，此时版本库中还有该文件，我们可以执行一键还原我们的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- test.txt</span></span><br></pre></td></tr></table></figure><h4 id="7-远程仓库"><a class="markdownIt-Anchor" href="#7-远程仓库"></a> 7 远程仓库</h4><p><strong>Github相当于提供一个Git服务器，提供Git仓库托管服务</strong>,不同位置的多台主机可以从Github上面下载版本库，实现多人协作开发。</p><p>（1）<strong>添加远程库</strong></p><p>​          首先在Github新建一个仓库，与本地一个已有的本地仓库关联，在本地的仓库下运行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote add origin https://github.com/Github账户/Github仓库名.git</span></span><br></pre></td></tr></table></figure><p>远程库的名字为<strong>origin</strong>,这也是Git的默认叫法。</p><p>（2）<strong>把本地库的所有内容推送到远程库上</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin master</span></span><br></pre></td></tr></table></figure><p>实际上是把当前分支master推送到远程，由于远程库是空的，第一次推送master分支时，加上了参数-u,Git不但会把本地的master分支内容推送到远程新的master分支，还会把本地的master分支和远程的master分支关联起来，以后的推送或者拉取时就可以简化命令。</p><p>从此以后，只要本地作了提交，只需执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin master</span></span><br></pre></td></tr></table></figure><p>就可以<strong>把本地master分支的最新修改推至Github</strong>。</p><p>（3）<strong>从远程库克隆</strong></p><p>从现有的远程库，新建一个目录，将远程库克隆到我们一个本地库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/Github账户/Github仓库名.git</span></span><br></pre></td></tr></table></figure><h4 id="8-分支管理"><a class="markdownIt-Anchor" href="#8-分支管理"></a> 8 分支管理</h4><p>创建分支，执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch dev  //新建branch分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout dev  //切换到dev分支</span></span><br><span class="line"></span><br><span class="line">//也可以直接</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b dev  //创建并切换</span></span><br></pre></td></tr></table></figure><p>查看分支情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br></pre></td></tr></table></figure><p>将分支dev合并到当前分支上(一般是合并到master分支上，所以要先切换到master分支)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge dev</span></span><br></pre></td></tr></table></figure><p>合并完就可以删除分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d dev</span></span><br></pre></td></tr></table></figure><p><strong>解决冲突</strong>：廖老师讲得很清楚，直接抠图</p><p><img src="/2021/05/22/Git%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.png" alt></p><p>​     <img src="/2021/05/22/Git%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/13.png" alt><img src="/2021/05/22/Git%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/14.png" alt></p><p><img src="/2021/05/22/Git%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/15.png" alt><img src="/2021/05/22/Git%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/16.png" alt></p><h4 id="9-保存现场"><a class="markdownIt-Anchor" href="#9-保存现场"></a> 9 保存现场</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git stash</span></span><br></pre></td></tr></table></figure><p>git stash可以把当前工作现场“储藏起来”，等以后恢复现场后再继续工作。执行完git stash后，工作区是干净的，因此可以做其他的修改和调整，调整完再还原原来的工作现场。</p><p>恢复现场可以有两个办法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git stash apply  //恢复后，stash内容并不删除，需要再执行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash drop //删除stash</span></span><br><span class="line"></span><br><span class="line">//或者直接使用</span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash pop  //恢复并删除stash</span></span><br></pre></td></tr></table></figure><p>查看已保存的工作现场可以用以下指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git stash list</span></span><br></pre></td></tr></table></figure><p>丢弃一个<strong>没有被合并过的分支</strong>，要通过强制删除命令删除分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -D name //name为分支名</span></span><br></pre></td></tr></table></figure><h4 id="10-多人协作"><a class="markdownIt-Anchor" href="#10-多人协作"></a> 10 多人协作</h4><p>（1）<strong>查看远程库的信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote -v   //查看远程库的信息，-v可选可不选</span></span><br></pre></td></tr></table></figure><p>（2） <strong>推送分支</strong><br>推送分支，就是将该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样Git就会把该分支推送到远程库对应的远程分支上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin master //推送master分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin dev    //推送dev分支</span></span><br></pre></td></tr></table></figure><p>（3）<strong>抓取分支</strong></p><p>​      当你的同伴从远程库clone到本地时，默认情况下，只能看到本地的master分支。现在如果，你的同伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，可以执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b dev origin/dev</span></span><br></pre></td></tr></table></figure><p>这样，同伴就可以在dev继续修改，修改完将dev分支push到远程库。</p><p>考虑一种情况，你的同伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件进行了修改，并试图推送，这是推送失败，原因是<strong>你的小伙伴的最新提交和你试图推送的提交有冲突</strong></p><p>怎么解决？先用git pull把最新的提交从origin/dev抓取下来，在本地合并，解决冲突，再推送。解决步骤命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --set-upstream dev origin/dev //指定本地dev分支与远程origin/dev分支的链接</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull //抓取下来</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;解决合并有冲突的问题&quot;</span>  //解决合并冲突</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin dev  //再次推送完成</span></span><br></pre></td></tr></table></figure><h4 id="11-标签管理"><a class="markdownIt-Anchor" href="#11-标签管理"></a> 11 标签管理</h4><p>发布一个新版本时，我们可以在版本库先打一个标签，这样，就唯一确定了打标签时刻的版本，标签也是版本库的一个快照。</p><p>打标签时，切换到需要打标签的分支上，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag v1.0  //v1.0为标签</span></span><br></pre></td></tr></table></figure><p><strong>默认标签都是打在最新提交的commit上的</strong>，如果之前的版本忘记打标签了，现在要打标签，也有办法，首先要先执行<strong>git log</strong>查看历史提交的commit id，然后执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag v0.9 74645665  // 74645665为对应commit ID的前几位</span></span><br></pre></td></tr></table></figure><p>还可以创建带有说明的标签，执行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -a v0.1 -m <span class="string">&quot;version 0.1 released&quot;</span> 3628164 //-a 指定标签名，-m 指定说明文字</span></span><br></pre></td></tr></table></figure><p>想要查看具体某一个标签的信息，可以执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git show v0.9 //显示标签v0.9的信息</span></span><br></pre></td></tr></table></figure><p>可以用命令git tag查看所有标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag</span></span><br></pre></td></tr></table></figure><p>如果标签打错了，也可以删除 执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -d v0.1</span></span><br></pre></td></tr></table></figure><p>因为创建的标签都只存储在本地，不会自动推送到远程，如果要推送某个标签到远程，可以执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin v1.0</span>  </span><br><span class="line">//或者</span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --tags  //一次性推送全部尚未推送到远程的本地标签</span></span><br></pre></td></tr></table></figure><p>如果标签已经推送到远程，要删除远程标签，就需要先从本地删除，再从远程删除，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git tag -d v0.9 //删除本地标签</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin :refs/tags/v0.9  //从远程删除标签</span></span><br></pre></td></tr></table></figure><p>写完才发现原来码了这么多，感觉还是有很多细节要注意，特别是pull,push等指令要配合起来使用，理解Git的工作原理就更为重要，还需再查阅更多资料，还有就是，要用起来，用起来，用起来。（可惜自己太菜了，没项目可以push到Gayhub)。</p><p>Hexo博客的基本前提按道理来说也是要懂得Git的使用，可hexo clean  hexo g -d已经把Git细节给隐藏了。</p><p>…</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;廖雪峰老师的Git教程之前看过一遍，讲的很简单基础明了，入门应该是够了的，之后对Git的使用还是比较少，所以很多命令都忘记了，前阵子刚刚入门ctf(很弱很弱很弱的那种)有做到git泄露的题目，觉得有必要再了解一遍Git，所以这两天再看了一遍书，做一下笔记，方便查阅，但感觉还是要用起来，用起来，用起来才能记住，本文也只当做学习记录了。注意，&lt;strong&gt;本文略长且无营养&lt;/strong&gt;，阅读请考虑仔细！！！&lt;/p&gt;</summary>
    
    
    
    
    <category term="Git" scheme="https://luo41.top/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>C语言中的联合</title>
    <link href="https://luo41.top/2021/05/05/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E8%81%94%E5%90%88/"/>
    <id>https://luo41.top/2021/05/05/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E8%81%94%E5%90%88/</id>
    <published>2021-05-05T02:29:05.000Z</published>
    <updated>2021-05-05T02:30:02.157Z</updated>
    
    <content type="html"><![CDATA[<p>1  C语言中的Union又称为联合，联合的声明语法与结构的语法一样，但是语义差别很大，<strong>联合用不同的字段，引用相同的内存块</strong>。</p><p>2  <strong>为什么使用联合？</strong></p><p><strong>在一些上下文中，联合的使用能够减小分配空间的总量。</strong> 一种应用的情况是，我们事先知道对一个数据结构中的两个不同字段的使用是<strong>互斥的</strong>(同时只会有一个字段是有意义的)，那么将这两个字段声明为联合的一部分，而不是结构的一部分，会减小分配空间的总量。</p><span id="more"></span><p>比如说，我们要实现一个二叉树的数据结构，每个叶子节点都有两个double类型的数据值，而每个内部节点都有指向两个孩子的指针，但是没有数据，如果用<strong>Struct</strong>做如下声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_s</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_s</span> *<span class="title">left</span>;</span>   <span class="comment">//8字节</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node_s</span> *<span class="title">right</span>;</span>  <span class="comment">//8字节</span></span><br><span class="line">    <span class="keyword">double</span> data[<span class="number">2</span>]; <span class="comment">//2*8=16字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，每个结点需要32个字节，而且每个节点都要浪费16个字节，因为如果是内部节点，data字段无意义，如果是叶子节点，left,right指针字段无意义。</p><p>如果我们用<strong>Union</strong>声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">node_u</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">node_u</span> *<span class="title">left</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">node_u</span> *<span class="title">right</span>;</span></span><br><span class="line">    &#125;internal;</span><br><span class="line">    <span class="keyword">double</span> data[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：一个联合的总的大小等于它最大字段的大小</strong>。</p><p>那么，每个结点就只需要16个字节，相当于系统分配16个字节的内存空间，如果是内部节点，将16字节的第一个8字节作为left指针的存放区域，第二个8字节内存作为right指针的存放区域。如果是叶子节点，则将16个字节的内存空间分配给data数组，<strong>实现了内存的共享。</strong></p><p>那么问题来了？如果确定一个给定的结点到底是叶子节点还是内部节点呢，通常的方法是引进一个枚举类型，定义这个联合中可能的不同选择，然后再将枚举类型与union放进一个struct里面：如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span>N_LEAF,N_INTERNAL&#125; <span class="keyword">nodetype_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">nodetype_t</span> type;  <span class="comment">//标签字段  4字节</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">node_u</span>&#123;</span>   <span class="comment">//联合字段    //16字节</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">node_u</span> *<span class="title">left</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">node_u</span> *<span class="title">right</span>;</span></span><br><span class="line">    &#125;internal;</span><br><span class="line">    <span class="keyword">double</span> data[<span class="number">2</span>];</span><br><span class="line">&#125;info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个结构总共需要24个字节(type和node_u之间要填充4个字节，这里不展开，或者你当成是20字节就好啦，比之前32个字节少了12个字节呢)。这还只是两个字段共享一块内存区域的情况，如果是更多的字段共享一块内存区域，节省的空间会更加可观。</p><p>注：可能有同学会觉得是否可用布尔类型实现标签字段，如果是只有两个字段是可以的，当多个字段，还是得用枚举类型。</p><p>(<strong>未学过数据结构同学这段可以不看</strong>）关于互斥的例子，我记得大二上的时候在讲中序线索二叉树的遍历时就遇到过这种情况，中序线索二叉树每个结点有两个字段leftChild和rightChild。对于某一个结点，当左子女存在时，leftChild指向左子女结点，不存在时，leftChild指向该结点的前驱结点，当右子女存在时，rightChild指向右子女结点，不存在时，rightChild指向的是该节点的后继结点。那么如何区别leftChild和rightChild是子女还是前驱结点或后继结点，当时书里给出的是给两个标志位ltag和rtag，标志位为0时表示子女，为1时表示前驱结点或后序结点。</p><p>该二叉树结点的结构大概如下，这段好像没有明显用到联合，但我觉得跟联合的思想很像，就是用一个标志位，根据标志位的不同，判断同一个内存段里面的数据代表的是不同的含义。(<strong>或者说，如果去解读这段内存？</strong>)</p><table><thead><tr><th style="text-align:center">leftChild</th><th>ltag</th><th style="text-align:center">data</th><th style="text-align:center">rtag</th><th style="text-align:center">rightChild</th></tr></thead><tbody><tr><td style="text-align:center"></td><td></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>下面是一个用联合实现的数据类型转换的函数。</p><p>联合里面用两个字段，一个是整数字段d，一个是无符号整数字段u，所以内存会分配给union字段8个字节也就是32个位，这时参数为num传进来，num的值为-1，执行temp.d=num=-1,此时分配的内存块里的数据情况是32个1，也就是0xffff ffff(有符号数表示为-1），随后执行return temp.u</p><p>temp.u的内存块里的数据是多少？同样也是0xffff ffff，因为它和temp.d共享内存块，所以程序就会以无符号数解读0xffff ffff，返回值<strong>4294967295</strong>，实现了数据类型的转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">double2bits</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;  <span class="comment">//输入整数d，</span></span><br><span class="line"><span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> d;             <span class="comment">//union各成员共享一段空间</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> u;</span><br><span class="line">&#125;temp;</span><br><span class="line">temp.d=num;</span><br><span class="line"><span class="keyword">return</span> temp.u;  返回d的无符号值</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Hello World&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="built_in">double2bits</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;1  C语言中的Union又称为联合，联合的声明语法与结构的语法一样，但是语义差别很大，&lt;strong&gt;联合用不同的字段，引用相同的内存块&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;2  &lt;strong&gt;为什么使用联合？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在一些上下文中，联合的使用能够减小分配空间的总量。&lt;/strong&gt; 一种应用的情况是，我们事先知道对一个数据结构中的两个不同字段的使用是&lt;strong&gt;互斥的&lt;/strong&gt;(同时只会有一个字段是有意义的)，那么将这两个字段声明为联合的一部分，而不是结构的一部分，会减小分配空间的总量。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CSAPP" scheme="https://luo41.top/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>CSAPPLAB配置</title>
    <link href="https://luo41.top/2021/05/04/CSAPPLAB%E9%85%8D%E7%BD%AE/"/>
    <id>https://luo41.top/2021/05/04/CSAPPLAB%E9%85%8D%E7%BD%AE/</id>
    <published>2021-05-04T11:00:08.000Z</published>
    <updated>2021-06-08T01:49:27.627Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲述我自己做CSAPP实验时的环境搭建，目前我只做了CSAPP DATAlab一个实验，所以后续实验需要到的一些配置在本文可能不会提到，但会持续更新(如果我有做后面的实验的话，手动狗头)。</p><p>1  <strong>安装虚拟机和ubuntu</strong>。</p><p>第一步实验要求在Linux环境下运行，所以需要安装Linux或虚拟机以及ubuntu，我个人的话安装的是虚拟机以及ubuntu。关于安装虚拟机以及ubuntu，我用的是下面这个网址里面的教程，教程挺详细的，不再重复，直到下载完VS CODE即可，注意那个共享文件夹的位置，稍后实验需要用到。</p><p><a href="https://0xffff.one/d/391">https://0xffff.one/d/391</a></p><span id="more"></span><p>2  <strong>下载实验压缩包</strong>。</p><p>完成了虚拟机以及ubuntu的安装后，我们先下载CSAPP的实验压缩包，到官方地址进行下载，如图</p><p><a href="http://csapp.cs.cmu.edu/3e/labs.html">http://csapp.cs.cmu.edu/3e/labs.html</a></p><img src="/2021/05/04/CSAPPLAB%E9%85%8D%E7%BD%AE/CSAPP实验压缩包.png" style="zoom: 67%;"><p>3 <strong>解压实验包。</strong></p><p>下载完实验压缩包后，进行解压。这里将压缩包解压到我们主机与虚拟机的共享文件夹里。具体做法是：</p><p>比如我本机与虚拟机的共享文件夹是我本机的D盘，挂载在虚拟机的host目录下，所以我在D盘下新建一个文件夹CSAPP_lab，再将实验压缩包解压到CSAPP_lab里面。</p><img src="/2021/05/04/CSAPPLAB%E9%85%8D%E7%BD%AE/共享文件夹.png" style="zoom: 67%;"><p><img src="/2021/05/04/CSAPPLAB%E9%85%8D%E7%BD%AE/datalab-handout.png" alt></p><p>这时我们就可以在虚拟机下的host文件夹下找到我们的CSAPP_lab文件夹，也可以找到datalab_handout，第三步就算完成了。</p><img src="/2021/05/04/CSAPPLAB%E9%85%8D%E7%BD%AE/虚拟机中实验文件.png" style="zoom:80%;"><p>4 <strong>安装gcc</strong>:</p><p>build-essential是一个软件包，装了该软件包，编译c/c<ins>所需要的软件包也都会被安装。因此如果想在Ubuntu中编译c/c</ins>程序,只需要安装该软件包就可以了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get  install  build-essential</span><br></pre></td></tr></table></figure><p>5 <strong>开始做实验啦</strong>(只针对Datalab，因为后面还没做，不确定是否是一样的操作)</p><p>Datalab实验其实就是修改datalab-handout下的bit.c文件，用vscode打开，根据题目要求修改代码。</p><img src="/2021/05/04/CSAPPLAB%E9%85%8D%E7%BD%AE/bitc.png" style="zoom:80%;"><img src="/2021/05/04/CSAPPLAB%E9%85%8D%E7%BD%AE/bitc2.png" style="zoom:80%;"><p>修改完代码后，在datalab-handout文件下右键打开终端</p><img src="/2021/05/04/CSAPPLAB%E9%85%8D%E7%BD%AE/打开终端.png" style="zoom:80%;"><p>1 先执行 make btest, <strong>相当于编译</strong>，每次修改过代码重新测试的时候都需要先执行一遍make btest</p><p>2   <strong>./btest</strong> 运行，运行后得到相应的结果。</p><img src="/2021/05/04/CSAPPLAB%E9%85%8D%E7%BD%AE/运行结果.png" style="zoom:80%;"><p>结语：DATALAB的实验过程大致就是这些，看网上教程有的是用docker容器的，但那个我弄了在make那一步总是出错，所以改用了这种方法。个人折腾过程，有些步骤可能跟机器相关而出错了，出错的话可能需要再自行查阅资料。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文讲述我自己做CSAPP实验时的环境搭建，目前我只做了CSAPP DATAlab一个实验，所以后续实验需要到的一些配置在本文可能不会提到，但会持续更新(如果我有做后面的实验的话，手动狗头)。&lt;/p&gt;
&lt;p&gt;1  &lt;strong&gt;安装虚拟机和ubuntu&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;第一步实验要求在Linux环境下运行，所以需要安装Linux或虚拟机以及ubuntu，我个人的话安装的是虚拟机以及ubuntu。关于安装虚拟机以及ubuntu，我用的是下面这个网址里面的教程，教程挺详细的，不再重复，直到下载完VS CODE即可，注意那个共享文件夹的位置，稍后实验需要用到。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://0xffff.one/d/391&quot;&gt;https://0xffff.one/d/391&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="折腾" scheme="https://luo41.top/categories/%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="CSAPP" scheme="https://luo41.top/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP_DATALAB</title>
    <link href="https://luo41.top/2021/05/04/CSAPP-DATALAB/"/>
    <id>https://luo41.top/2021/05/04/CSAPP-DATALAB/</id>
    <published>2021-05-04T07:37:02.000Z</published>
    <updated>2021-06-08T01:48:55.104Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-bitxor"><a class="markdownIt-Anchor" href="#1-bitxor"></a> 1 <strong>bitXor</strong></h2><p>题目：</p><ul><li><p>目标：实现 x ^ y.</p></li><li><p>限制：只能使用操作符～，&amp;</p></li><li><p>最大操作次数： 14</p></li><li><p>难度：1</p><span id="more"></span></li></ul><p>解法1：<strong>观察异或运算的数字逻辑电路真值表</strong></p><table><thead><tr><th style="text-align:center">X</th><th style="text-align:center">Y</th><th style="text-align:center">Z</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table><p>易得：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi><mo>=</mo><mover accent="true"><mi>X</mi><mo stretchy="true">‾</mo></mover><mi>Y</mi><mo>+</mo><mi>X</mi><mover accent="true"><mi>Y</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">Z=\overline{X}Y+X\overline{Y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9666600000000001em;vertical-align:-0.08333em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></span></p><p>因为不能使用+(或)符号，很容易想到<strong>德摩根定律</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>X</mi><mo>+</mo><mi>Y</mi></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mi>X</mi><mo stretchy="true">‾</mo></mover><mover accent="true"><mi>Y</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{X+Y}=\overline{X}\overline{Y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9666600000000001em;vertical-align:-0.08333em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.08333em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></span></p><p>可以看到，<strong>用非运算和与运算可以解决或运算</strong>,转换得：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi><mo>=</mo><mover accent="true"><mover accent="true"><mrow><mover accent="true"><mi>X</mi><mo stretchy="true">‾</mo></mover><mi>Y</mi><mo>+</mo><mi>X</mi><mover accent="true"><mi>Y</mi><mo stretchy="true">‾</mo></mover></mrow><mo stretchy="true">‾</mo></mover><mo stretchy="true">‾</mo></mover><mo>=</mo><mover accent="true"><mrow><mo stretchy="false">(</mo><mover accent="true"><mrow><mover accent="true"><mi>X</mi><mo stretchy="true">‾</mo></mover><mi>Y</mi></mrow><mo stretchy="true">‾</mo></mover><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mover accent="true"><mrow><mi>X</mi><mover accent="true"><mi>Y</mi><mo stretchy="true">‾</mo></mover><mo stretchy="false">)</mo></mrow><mo stretchy="true">‾</mo></mover></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">Z=\overline{\overline{\overline{X}Y+X\overline{Y}}}=\overline{(\overline{\overline{X}Y})(\overline{X\overline{Y})}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.3666600000000002em;vertical-align:-0.08333em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2833300000000003em;"><span style="top:-3.08333em;"><span class="pstrut" style="height:3.08333em;"></span><span class="mord"><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span><span style="top:-4.00333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.08333em;"><span></span></span></span></span></span></span></span><span style="top:-4.28666em;"><span class="pstrut" style="height:3.08333em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.08333em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.5333300000000003em;vertical-align:-0.25em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2833300000000003em;"><span style="top:-3.08333em;"><span class="pstrut" style="height:3.08333em;"></span><span class="mord"><span class="mopen">(</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span><span style="top:-4.00333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-4.00333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25em;"><span></span></span></span></span></span></span></span><span style="top:-4.28666em;"><span class="pstrut" style="height:3.08333em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25em;"><span></span></span></span></span></span></span></span></span></span></p><p>解法2：用<strong>门电路实现</strong>(其实应该和解法1一样，只是从门电路的逻辑上去理解)</p><p>我们知道，一个异或门可以由与门，或门和非门实现，如图：</p><p><img src="/2021/05/04/CSAPP-DATALAB/%E5%BC%82%E6%88%96%E9%97%A81.png" alt></p><p>又因为或门规定不能使用，<strong>根据德摩根定律，可以用与门和非门实现或门</strong>，实现如图：</p><p><img src="/2021/05/04/CSAPP-DATALAB/%E5%BC%82%E6%88%96%E9%97%A82.png" alt></p><p>所以根据解法可以写出代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitXor</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~(~x&amp;~y)&amp;~(x&amp;y);<span class="comment">//       解法2</span></span><br><span class="line">  <span class="comment">// return ~(~(~x&amp;y)&amp;~(x&amp;~y));    解法1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-tmin"><a class="markdownIt-Anchor" href="#2-tmin"></a> 2. tmin</h2><p>题目：</p><ul><li><p>目标：返回最小补码数 ，即 0x80000000.</p></li><li><p>限制：只能使用操作符！~ &amp; ^ | + &lt;&lt;&gt;&gt;</p></li><li><p>最大操作次数： 4</p></li><li><p>难度：1</p><p>最小补码数，32位机器当然就是0x80000000，有符号数补码表示法，<strong>最高位为1时负权值，低位全为正权值</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补码可以用下图2-13<strong>左右箭头理解</strong>，最终值为左右箭头(<strong>各个位权值</strong>)相互抵消后的值</p><p><img src="/2021/05/04/CSAPP-DATALAB/CSAPP%E9%85%8D%E5%9B%BE.png" alt></p><h2 id="3-istmax"><a class="markdownIt-Anchor" href="#3-istmax"></a> <strong>3. isTmax</strong></h2><p>题目：</p><ul><li>目标：判断 x 是否是 Tmax，如果是，返回 1，否则返回 0。</li><li>限制：只能使用操作符！~ &amp; ^ | +</li><li>最大操作次数： 10</li><li>难度：2</li></ul><p>解题思路：首先是先要知道Tmax是什么值，第二题提到过，<strong>有符号数补码表示法最高位为1时，权值为负值，最终结果也会为负值，低位权值始终为正值</strong>，所以Tmax就是最高位(符号位)为0，其余各位全部为1，也就是<strong>0x7fff ffff</strong>，所以问题就是转化为如果判断给定的x为<strong>0xffff ffff</strong>。因为不允许用if等判断语句，所以自然而然思路就是要找特殊值<strong>0</strong>，如何去构造特殊值<strong>0</strong>，可以通过<strong>直接构造全0，或构造全1，全1取反就得到全0了</strong>嘛。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mi>x</mi><mn>7</mn><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mo>+</mo><mn>1</mn><mo>=</mo><mn>0</mn><mi>x</mi><mn>80000000</mn></mrow><annotation encoding="application/x-tex">0x7fff ffff +1=0x8000 0000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord">7</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord">8</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></span></p></li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mi>x</mi><mn>7</mn><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mo>+</mo><mn>0</mn><mi>x</mi><mn>80000000</mn><mo>=</mo><mn>0</mn><mi>x</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">0x7fff ffff+0x80000000=0xffffffff</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord">7</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord">8</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span></span></p><p>全1出现，似乎已经可以写出代码了，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTmax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x_addone=x+<span class="number">1</span>;  <span class="comment">//加1得到0x80000000</span></span><br><span class="line">  x=x+x_addone;  <span class="comment">//相加得到0xffffffff</span></span><br><span class="line">  x=~x;     <span class="comment">//取反得到 0x00000000</span></span><br><span class="line">  <span class="keyword">return</span> !x;  <span class="comment">//满足条件，返回1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提交后报错了，原因是0xfffffff也通过了我的代码测试，返回了1，分析</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mi>x</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mo>+</mo><mn>1</mn><mo>=</mo><mn>0</mn><mi>x</mi><mn>00000000</mn></mrow><annotation encoding="application/x-tex">0xffffffff+1=0x00000000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mi>x</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mo>+</mo><mn>0</mn><mi>x</mi><mn>00000000</mn><mo>=</mo><mn>0</mn><mi>x</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">0xffffffff+0x00000000=0xffffffff</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span></span></p><p>得到结果也是全1，最终返回1，所以需要进行一个<strong>特判</strong>。</p><p>设置一个flag，当x为0xffffffff,flag设置为0x0，否则设置为0x1,最终成功代码为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTmax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x_addone=x+<span class="number">1</span>;  <span class="comment">//加1得到0x80000000</span></span><br><span class="line">  <span class="keyword">int</span> flag=!(!x_addone); <span class="comment">//x为0xffffffff时，x_addone为全0，flag设置为0x0，否则设置为0x1</span></span><br><span class="line">  x=x+x_addone;  <span class="comment">//相加得到0xffffffff</span></span><br><span class="line">  x=~x;     <span class="comment">//取反得到 0x00000000</span></span><br><span class="line">  <span class="keyword">return</span> flag&amp;(!x);  <span class="comment">//满足条件，返回1  注意(!x是0x0或者0x1,只有一位有效)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-alloddbits"><a class="markdownIt-Anchor" href="#4-alloddbits"></a> 4. allOddBits</h2><p>题目：</p><ul><li><p>目标：如果 x 的二进位的所有奇数位全为1，则返回 1，否则返回 0。 <em>注：二进制最低位是第 0 位。</em></p></li><li><p>例子：allOddBits (0xFFFFFFFD) = 0, allOddBits (0xAAAAAAAA) = 1</p></li><li><p>限制：只能使用操作符！~ &amp; ^ | + &lt;&lt; &gt;&gt;</p></li><li><p>最大操作次数： 12</p></li><li><p>难度：2</p><p>解题思路：判断x的二进制的所有奇数位全为1，其实就是判断该数是否为0xAAAAAAAA或0xffffffff。代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allOddBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  x=x&amp;<span class="number">0xAAAAAAAA</span>;          <span class="comment">//当且仅当x为0xAAAAAAAA或0xffffffff，x&amp;0xAAAAAAAA的结果为0xAAAAAAAA </span></span><br><span class="line">  <span class="keyword">return</span> !(x^<span class="number">0xAAAAAAAA</span>); <span class="comment">//上一步结果为0xAAAAAAAA,返回1，否者返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-negate"><a class="markdownIt-Anchor" href="#5-negate"></a> 5. negate</h2><p>题目：</p><ul><li>目标：返回 -x</li><li>限制：只能使用操作符！~ &amp; ^ | + &lt;&lt;&gt;&gt;</li><li>最大操作次数：5</li><li>难度：2</li></ul><p>直接解就可以了  <strong>-x=~x+1</strong></p><p>证明一下这个式子：</p><p>我们有(-x)+x=0，两边同时加**<sub>x**,，有（-x)+x+(</sub>x)=0+(~x) 又x+(~x)为全1(0xffffffff)，也就是-1，所以有</p><p>(-x)-1=(~x)，把1移到右边，等式得证。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (~x)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-isasciidigit"><a class="markdownIt-Anchor" href="#6-isasciidigit"></a> 6. isAsciiDigit</h2><p>题目：</p><ul><li><p>目标： return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters ‘0’ to ‘9’)</p></li><li><p>例子：</p><ul><li>isAsciiDigit(0x35) = 1.</li><li>isAsciiDigit(0x3a) = 0.</li><li>isAsciiDigit(0x05) = 0.</li></ul></li><li><p>限制：只能使用操作符！~ &amp; ^ | + &lt;&lt;&gt;&gt;</p></li><li><p>最大操作次数：15</p></li><li><p>难度：3</p><p>解题思路:就是简单判断x是否在区间内，没有if语句，还是跟前面那个想法，<strong>构造出0或1</strong>。想法也很简单，比较大小可以<strong>用减法，再观察差是正负即可</strong>。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> neg_Num_zero=~(<span class="number">0x30</span>)+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> neg_Num_nine=~(<span class="number">0x39</span>)+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> judge1=!(((x+neg_Num_zero)&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>); <span class="comment">//x&gt;=0x30 judge1 is true</span></span><br><span class="line">  <span class="keyword">int</span> judge2=(((x+neg_Num_nine)&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>);   <span class="comment">//x&lt;0x39 judge2 is true</span></span><br><span class="line">  <span class="keyword">int</span> judge3=!(x^(<span class="number">0x39</span>); <span class="comment">// x=0x39  judge3 is ture;</span></span><br><span class="line">  <span class="keyword">return</span> judge1&amp; (judge2|judge3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="7-conditional"><a class="markdownIt-Anchor" href="#7-conditional"></a> 7. conditional</h2><p>题目：</p><ul><li>目标：实现三目运算符 same as x ? y : z</li><li>限制：只能使用操作符！~ &amp; ^ | + &lt;&lt; &gt;&gt;</li><li>最大操作次数：16</li><li>难度：3</li></ul><p>解法：实现<strong>三目运算符</strong>，根据X条件选择Y或Z，可以巧妙运用数电的思想(类似于一个选择器)X=1时，选择Y，X等于0时，选择Z的值</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>E</mi><mi>S</mi><mi>U</mi><mi>L</mi><mi>T</mi><mo>=</mo><mi>X</mi><mi>Y</mi><mo>+</mo><mover accent="true"><mi>X</mi><mo stretchy="true">‾</mo></mover><mi>Z</mi></mrow><annotation encoding="application/x-tex">RESULT=XY+\overline{X}Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span></span></p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conditional</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> flag=!(!x);  <span class="comment">//x等于0时不做转化，x为非0时，转化为1</span></span><br><span class="line">  <span class="keyword">return</span> ((~(flag<span class="number">-1</span>)&amp;y) | (flag<span class="number">-1</span>)&amp;z); <span class="comment">//flag为1时，即要选择Y，所以~（flag-1)变为全1，&amp;上y后仍然是y的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-islessorequal"><a class="markdownIt-Anchor" href="#8-islessorequal"></a> 8. isLessOrEqual</h2><p>题目：</p><ul><li><p>目标：如果 x&lt;=y ，则返回 1， 否则返回 0.</p></li><li><p>限制：只能使用操作符！~ &amp; ^ | + &lt;&lt;&gt;&gt;</p></li><li><p>最大操作次数：24</p></li><li><p>难度：3</p><p>解题思路：<strong>同样使用减法实现判断小于等于号</strong>  y-x&gt;=0</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> neg_x=~x+<span class="number">1</span>;  <span class="comment">//-x的值</span></span><br><span class="line">  <span class="keyword">int</span> judge1=!(((y+neg_x))&gt;&gt;<span class="number">31</span>)&amp;(<span class="number">0x1</span>);  <span class="comment">//x,y符号相同的情况，根据相减的符号位判断是否是&lt;= 是&lt;=则judge1=1</span></span><br><span class="line">  <span class="keyword">int</span> judge2=(x&gt;&gt;<span class="number">31</span>)^(y&gt;&gt;<span class="number">31</span>);  <span class="comment">//x,y符号不相同，直接判断，judge2=0时，符号位相同，为1时，符号位不同</span></span><br><span class="line">  <span class="keyword">int</span> flag=~(~judge2+<span class="number">1</span>); <span class="comment">//flag，与上一题相同，相当于一个选择器，当judge2=0时，符号位相同，flag为全一，此时选择的是judge1的结果(即要根据相减的符号位是0或1进行判断) 当judge2=1时，flag为全0，~flag为全1，此时选择判断的依据为(x&gt;&gt;31)&amp;0x1，即判断x的符号位</span></span><br><span class="line">  <span class="keyword">return</span> (flag&amp;judge1) | (~flag&amp;((x&gt;&gt;<span class="number">31</span>)&amp;<span class="number">0x1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-logicalneg"><a class="markdownIt-Anchor" href="#9-logicalneg"></a> 9. logicalNeg</h2><p>题目：</p><ul><li>目标：实现！操作</li><li>例子： logicalNeg (3) = 0, logicalNeg (0) = 1</li><li>限制：只能使用操作符～&amp; ^ | + &lt;&lt;&gt;&gt;</li><li>最大操作次数：12</li><li>难度：4</li></ul><p>本题要实现的是!操作，道理很简单就是<strong>0返回1，非0返回0</strong></p><p>刚拿到这道题，有点懵，想了很久没有思路，网上借鉴了大牛的思路，列真值表判断情况</p><table><thead><tr><th style="text-align:center">X</th><th style="text-align:center">X符号位</th><th style="text-align:center">X+0xffffffff 符号位</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center"><code>0</code></td><td style="text-align:center"><code>1</code></td></tr><tr><td style="text-align:center">正数</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">负数</td><td style="text-align:center">1</td><td style="text-align:center">1 or 0</td></tr></tbody></table><p>由表可知，只有X=0时，X符号位与X+0xffffffff符号位的组合为<strong>0 1</strong> 此时返回1，其余情况均返回0，可以写出代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> k=<span class="number">0xffffffff</span>;</span><br><span class="line">  <span class="keyword">return</span> (~(x&gt;&gt;<span class="number">31</span>)&amp; <span class="number">0x1</span>)&amp;(((k+x)&gt;&gt;<span class="number">31</span>)&amp;<span class="number">0x1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-howmanybits"><a class="markdownIt-Anchor" href="#10-howmanybits"></a> 10. howManyBits</h2><p>题目：</p><ul><li>目标： 返回表示一个数（补码形式）所需要的最小 bit 数。</li><li>例子：<ul><li>howManyBits(12) = 5</li><li>howManyBits(298) = 10</li><li>howManyBits(-5) = 4</li><li>howManyBits(0) = 1</li><li>howManyBits(-1) = 1</li><li>howManyBits(0x80000000) = 32</li></ul></li><li>限制：只能使用操作符！~ &amp; ^ | + &lt;&lt;&gt;&gt;</li><li>最大操作次数： 90</li><li>难度：4</li></ul><p>emmmmmm， 真不会做，<strong>看了别人的思路，觉得记录下来也有学习的意义</strong> 大概思路是：</p><p>首先正数的话，就是要从高位到地位找第一个值为1的位，此时所需要的bit数为该bit位的位置+1，因为还需要一个符号位。</p><p>对于负数，负数需要找的是从高位到地位首个值为0的bit位，所以“<strong>对于负数，我们可以用对待正数的算法去处理</strong>”，将负数取反即可。</p><p>接下来的处理方法，就是如何确实找到的首个位是第几个比特位，换句话说，也就是该<strong>比特位后面还有多少比特位</strong>，为处理方便，可以将后面的比特位全部置为1。再利用<strong>掩码+移位</strong>的方法确实后面有多少个1，也就是有多少个位。<strong>具体代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">howManyBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> re_x=~x;<span class="comment">//取反</span></span><br><span class="line">  <span class="keyword">int</span> neg_one=~<span class="number">0x1</span>+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> flag=!(x&gt;&gt;<span class="number">31</span>);</span><br><span class="line">  x=(~(flag+neg_one)&amp;x) | ((flag+neg_one)&amp;re_x);  <span class="comment">//同样是类似一个选择器，保证x为正值</span></span><br><span class="line">  x=x | x&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  x=x | x&gt;&gt;<span class="number">2</span>;</span><br><span class="line">  x=x | x&gt;&gt;<span class="number">4</span>;</span><br><span class="line">  x=x | x&gt;&gt;<span class="number">8</span>;</span><br><span class="line">  x=x | x&gt;&gt;<span class="number">16</span>;   <span class="comment">//将32位最高位1后的所有位全部填充为1</span></span><br><span class="line">  <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> one=<span class="number">0x1</span>;</span><br><span class="line">  sum+=x &amp; one;</span><br><span class="line">  sum+=(x&gt;&gt;<span class="number">1</span>)&amp; one;</span><br><span class="line">  sum+=(x&gt;&gt;<span class="number">2</span>)&amp; one;</span><br><span class="line">  sum+=(x&gt;&gt;<span class="number">3</span>)&amp; one;</span><br><span class="line">  sum+=(x&gt;&gt;<span class="number">4</span>)&amp; one;</span><br><span class="line">  sum+=(x&gt;&gt;<span class="number">5</span>)&amp; one;</span><br><span class="line">  sum+=(x&gt;&gt;<span class="number">6</span>)&amp; one;</span><br><span class="line">  sum+=(x&gt;&gt;<span class="number">7</span>)&amp; one;</span><br><span class="line">  sum+=(x&gt;&gt;<span class="number">8</span>)&amp; one;</span><br><span class="line">  sum+=(x&gt;&gt;<span class="number">9</span>)&amp; one;</span><br><span class="line">  sum+=(x&gt;&gt;<span class="number">10</span>)&amp; one;</span><br><span class="line">  sum+=(x&gt;&gt;<span class="number">11</span>)&amp; one;</span><br><span class="line">  sum+=(x&gt;&gt;<span class="number">12</span>)&amp; one;</span><br><span class="line">  sum+=(x&gt;&gt;<span class="number">13</span>)&amp; one;</span><br><span class="line">  sum+=(x&gt;&gt;<span class="number">14</span>)&amp; one;</span><br><span class="line">  sum+=(x&gt;&gt;<span class="number">15</span>)&amp; one;</span><br><span class="line">  sum+=(x&gt;&gt;<span class="number">16</span>)&amp; one;</span><br><span class="line">  sum+=(x&gt;&gt;<span class="number">17</span>)&amp; one;</span><br><span class="line">  sum+=(x&gt;&gt;<span class="number">18</span>)&amp; one;</span><br><span class="line">  sum+=(x&gt;&gt;<span class="number">19</span>)&amp; one;</span><br><span class="line">  sum+=(x&gt;&gt;<span class="number">20</span>)&amp; one;</span><br><span class="line">  sum+=(x&gt;&gt;<span class="number">21</span>)&amp; one;</span><br><span class="line">  sum+=(x&gt;&gt;<span class="number">22</span>)&amp; one;</span><br><span class="line">  sum+=(x&gt;&gt;<span class="number">23</span>)&amp; one;</span><br><span class="line">  sum+=(x&gt;&gt;<span class="number">24</span>)&amp; one;</span><br><span class="line">  sum+=(x&gt;&gt;<span class="number">25</span>)&amp; one;</span><br><span class="line">  sum+=(x&gt;&gt;<span class="number">26</span>)&amp; one;</span><br><span class="line">  sum+=(x&gt;&gt;<span class="number">27</span>)&amp; one;</span><br><span class="line">  sum+=(x&gt;&gt;<span class="number">28</span>)&amp; one;</span><br><span class="line">  sum+=(x&gt;&gt;<span class="number">29</span>)&amp; one;</span><br><span class="line">  sum+=(x&gt;&gt;<span class="number">30</span>)&amp; one;</span><br><span class="line">  sum+=(x&gt;&gt;<span class="number">31</span>)&amp; one;   <span class="comment">//暴力求解，每一位都与掩码相与，得到1的个数</span></span><br><span class="line">  <span class="keyword">return</span> sum+<span class="number">1</span>; <span class="comment">//+1位 +的是符号位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：整数部分的实验就到这里为止了，这是我第一次做CSAPP的实验，有好一些题都得看了别人的题解才会做，觉得设计的解法很巧妙，学习到了还<strong>可以运用数电的思想去解决逻辑上的问题</strong>，后知后觉理解了其实逻辑上的硬件实现其实本身就是从最简单门电路的设计开始的。学习到了学习到了！也学习到了一些规律，特别是</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>E</mi><mi>S</mi><mi>U</mi><mi>L</mi><mi>T</mi><mo>=</mo><mi>X</mi><mi>Y</mi><mo>+</mo><mover accent="true"><mi>X</mi><mo stretchy="true">‾</mo></mover><mi>Z</mi></mrow><annotation encoding="application/x-tex">RESULT=XY+\overline{X}Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span></span></p><p>这条公式背后蕴含的<strong>根据X的值选择Y和Z其1</strong>的思想。</p><p>还有比如 <strong>-x=~x+1</strong> ，32位的最大值0x7fffffff +1 就变成了最小值0x8000000,将最大最小相加又变成了-1(0xffffffff)等一些位运算规律。</p><p><strong>慢慢填坑吧，就到这~~~</strong></p><p>注意：本文的<strong>很多解法都来自网络</strong>，我怕我日后忘记所以才记录下来。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-bitxor&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-bitxor&quot;&gt;&lt;/a&gt; 1 &lt;strong&gt;bitXor&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;目标：实现 x ^ y.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;限制：只能使用操作符～，&amp;amp;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最大操作次数： 14&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;难度：1&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    
    <category term="CSAPP" scheme="https://luo41.top/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>欧拉函数一个小的证明</title>
    <link href="https://luo41.top/2021/03/15/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%9A%84%E8%AF%81%E6%98%8E/"/>
    <id>https://luo41.top/2021/03/15/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%9A%84%E8%AF%81%E6%98%8E/</id>
    <published>2021-03-15T04:28:12.000Z</published>
    <updated>2021-06-02T02:25:43.372Z</updated>
    
    <content type="html"><![CDATA[<p>1 欧拉函数ϕ(n)表示<strong>小于n且与n互素的正整数的个数</strong>，且习惯上有ϕ(1)=1。</p><p>2 显然，对素数p，有ϕ§=p-1</p><p>3 证明ϕ(n)=ϕ(p<em>q)=ϕ§ * ϕ(q)=(p-1)</em>(q-1):    <strong>p,q为素数</strong>，证明如下</p><p>因为n=p*q,易得小于n的数正整数的集合S={1,…(pq-1)},一共有<strong>pq-1</strong>个元素，其中<strong>不与n互素</strong>的集合为A={p,2p,3p…(q-1)p}与B={q,2q,…(p-1)q}。且这两个集合没有重复元素，因为p和q都是素数，在集合A中找不到是q的整数倍的元素，同理在集合B中也找不到是p的整数倍的元素，因此<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>∪</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\cup B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>={p,2p…(q-1)p, q,2q,…(p-1)q}，元素个数为**(q-1)+(p-1)**,所以</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>p</mi><mi>q</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>q</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><mi>q</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>ϕ</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>ϕ</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ϕ(n)=(pq-1)-((q-1)+(p-1))=(p-1)*(q-1)=ϕ(p)*ϕ(q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">ϕ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">ϕ</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">ϕ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span></span></p><p><strong>证明完</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1 欧拉函数ϕ(n)表示&lt;strong&gt;小于n且与n互素的正整数的个数&lt;/strong&gt;，且习惯上有ϕ(1)=1。&lt;/p&gt;
&lt;p&gt;2 显然，对素数p，有ϕ§=p-1&lt;/p&gt;
&lt;p&gt;3 证明ϕ(n)=ϕ(p&lt;em&gt;q)=ϕ§ * ϕ(q)=(p-1)&lt;/em&gt;(q-1):  </summary>
      
    
    
    
    <category term="数学" scheme="https://luo41.top/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数论" scheme="https://luo41.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>乘法逆元的求法总结</title>
    <link href="https://luo41.top/2021/02/03/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%E7%9A%84%E6%B1%82%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://luo41.top/2021/02/03/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%E7%9A%84%E6%B1%82%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2021-02-03T10:12:34.000Z</published>
    <updated>2021-05-04T01:18:36.888Z</updated>
    
    <content type="html"><![CDATA[<h3 id="乘法逆元求法小结"><a class="markdownIt-Anchor" href="#乘法逆元求法小结"></a> 乘法逆元求法小结</h3><h4 id="逆元的定义"><a class="markdownIt-Anchor" href="#逆元的定义"></a> 逆元的定义</h4><p>对于整数a和p，如果a与p互质，我们定义x为a的逆元,计为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">a^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>,满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∗</mo><mi>x</mi><mo>≡</mo><mn>1</mn><mtext> </mtext><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a*x ≡ 1\ (mod \ p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span>。</p><span id="more"></span><h4 id="求解乘法逆元"><a class="markdownIt-Anchor" href="#求解乘法逆元"></a> 求解乘法逆元</h4><h6 id="1-拓展欧几里得算法egcd"><a class="markdownIt-Anchor" href="#1-拓展欧几里得算法egcd"></a> 1 拓展欧几里得算法(egcd)</h6><p>拓展的欧几里得算法原理是基于贝祖定理，对非零整数a,b，存在r和s使得</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>r</mi><mo>+</mo><mi>b</mi><mi>s</mi><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ar+bs=gcd(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></span></p><p>因为a，p互质，所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>r</mi><mo>+</mo><mi>b</mi><mi>p</mi><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ar+bp=gcd(a,p)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>,而由方程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∗</mo><mi>x</mi><mo>≡</mo><mn>1</mn><mtext> </mtext><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a*x ≡ 1\ (mod \ p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span>，等价于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>=</mo><mi>k</mi><mi>p</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ax=kp+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>(ax+(-k)p=1)，k为一个整数,所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>r</mi><mo>+</mo><mi>b</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">ar+bp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">p</span></span></span></span>=1中的r就相当于是x，也就是乘法逆元。求r即求得乘法逆元。</p><p>python代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul_reverse_element</span>(<span class="params">a,m</span>):</span>  //a,m  该算法求得a在mod m下的乘法逆元</span><br><span class="line">    r0,r1,s0,s1=<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    b=m</span><br><span class="line">    <span class="keyword">while</span>(b):</span><br><span class="line">        q,a,b=a//b,b,a%b</span><br><span class="line">        r0,r1=r1,r0-q*r1   </span><br><span class="line">    <span class="keyword">if</span> a!=<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;  //逆元不存在</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> (r0+m)%m;  //保证乘法逆元为正的</span><br></pre></td></tr></table></figure><h6 id="2-快速幂费尔马小定理"><a class="markdownIt-Anchor" href="#2-快速幂费尔马小定理"></a> 2 快速幂+费尔马小定理</h6><p><strong>费尔马小定理</strong>：若p为素数，a为正整数，且a,p互质，有：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>≡</mo><mn>1</mn><mtext> </mtext><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a^{p-1}≡1\ (mod\ p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.864108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span></span></p><p>所以</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∗</mo><mi>x</mi><mo>≡</mo><mn>1</mn><mtext> </mtext><mo>≡</mo><msup><mi>a</mi><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow></msup><mtext> </mtext><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a*x≡1\ ≡ a^{p-1}\ (mod\ p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace"> </span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>≡</mo><msup><mi>a</mi><mrow><mi>p</mi><mo>−</mo><mn>2</mn></mrow></msup><mtext> </mtext><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x≡a^{p-2}\ (mod\ p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span></span></p><p>接着用快速幂计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mi>p</mi><mo>−</mo><mn>2</mn></mrow></msup><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>p</mi></mrow><annotation encoding="application/x-tex">a^{p-2}\ mod\ p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">p</span></span></span></span>即可</p><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速幂+费尔马小定理求逆元</span></span><br><span class="line"><span class="comment">//x= a的p-2次方取余p </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">quick_pow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x,<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> pow,<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> r)</span></span>&#123;  <span class="comment">//x为底数，pow为幂，r为对r取余 </span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ans=<span class="number">1</span>,base=x;</span><br><span class="line"><span class="keyword">while</span>(pow&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(pow&amp;<span class="number">1</span>)&#123; <span class="comment">//pow为奇数 </span></span><br><span class="line">ans*=base;  <span class="comment">//指数除以2 还需要乘上一个底数 </span></span><br><span class="line">ans%=r; </span><br><span class="line">&#125;</span><br><span class="line">base*=base;</span><br><span class="line">base%=r;</span><br><span class="line">pow&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans%r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> a,p;</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;p;  </span><br><span class="line">cout&lt;&lt;<span class="built_in">quick_pow</span>(a,p<span class="number">-2</span>,p)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="3-阶乘法逆元求解on复杂度"><a class="markdownIt-Anchor" href="#3-阶乘法逆元求解on复杂度"></a> 3 阶乘法逆元求解O(n)复杂度</h6><p>首先设f[n]为n的阶乘，ans[n]为n的逆元，给出结论：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>=</mo><mi>a</mi><mi>n</mi><mi>s</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">]</mo><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex"> ans[n]=ans[n!]*(n-1)!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">!</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">!</mo><mo stretchy="false">]</mo><mo>=</mo><mi>a</mi><mi>n</mi><mi>s</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">]</mo><mo>∗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">ans[(n-1)!]=ans[n!]*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">!</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></span></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速幂+费尔马小定理求逆元</span></span><br><span class="line"><span class="comment">//x= a的p-2次方取余p </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span>  ll;</span><br><span class="line"><span class="function">ll  <span class="title">quick_pow</span><span class="params">(ll x,ll pow,ll r)</span></span>&#123;  <span class="comment">//x为底数，pow为幂，r为对r取余 </span></span><br><span class="line">ll  ans=<span class="number">1</span>,base=x;</span><br><span class="line"><span class="keyword">while</span>(pow&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(pow&amp;<span class="number">1</span>)&#123; <span class="comment">//pow为奇数 </span></span><br><span class="line">ans*=base;  <span class="comment">//指数除以2 还需要乘上一个底数 </span></span><br><span class="line">ans%=r; </span><br><span class="line">&#125;</span><br><span class="line">base*=base;</span><br><span class="line">base%=r;</span><br><span class="line">pow&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans%r;</span><br><span class="line">&#125;</span><br><span class="line">ll  f[<span class="number">3000050</span>];  <span class="comment">//阶乘 </span></span><br><span class="line">ll ans[<span class="number">3000050</span>]; <span class="comment">//逆元 </span></span><br><span class="line"><span class="keyword">int</span> inv[<span class="number">5050</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,p;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;p;</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">//0的阶乘为1</span></span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">f[i]=(f[i<span class="number">-1</span>]*i)%p;  <span class="comment">//这里是在mop p的条件下</span></span><br><span class="line">&#125;</span><br><span class="line">ll last_reverse=<span class="built_in">quick_pow</span>(f[n],p<span class="number">-2</span>,p); <span class="comment">//利用快速幂求得n！的逆元</span></span><br><span class="line">ll tem;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">ans[i]=(last_reverse*f[i<span class="number">-1</span>])%p; <span class="comment">//利用递推公式  i的逆元等于  i的阶乘的逆元 乘以 i-1的阶乘 </span></span><br><span class="line">tem=(last_reverse*i)%p;  <span class="comment">//利用公式2 求得ans[(n-1)!]的逆元 赋给last</span></span><br><span class="line">last_reverse=tem;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[i]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-线性递推算法"><a class="markdownIt-Anchor" href="#4-线性递推算法"></a> 4 线性递推算法</h6><p>对于等式<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∗</mo><mi>x</mi><mo>≡</mo><mn>1</mn><mtext> </mtext><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a*x ≡ 1\ (mod \ p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span>，设p=k*x+r(1&lt;r&lt;x)，等式同时mod p</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>∗</mo><mi>x</mi><mo>+</mo><mi>r</mi><mo>≡</mo><mn>0</mn><mtext> </mtext><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k*x+r≡0\ (mod\ p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span></span></p><p>同乘以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>i</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi mathvariant="normal">，</mi><msup><mi>r</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">i^{-1}，r^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>得到：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>∗</mo><msup><mi>r</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><msup><mi>i</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>≡</mo><mn>0</mn><mtext> </mtext><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k*r^{-1}+i^{-1}≡0\ (mod\ p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.947438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.864108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>i</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>≡</mo><mo>−</mo><mi>k</mi><mo>∗</mo><msup><mi>r</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mo stretchy="false">(</mo><mtext> </mtext><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i^{-1}≡-k*r^{-1}\ mod(\ p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.864108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mspace"> </span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>i</mi><mrow><mi mathvariant="normal">−</mi><mn>1</mn></mrow></msup><mo>≡</mo><mi mathvariant="normal">−</mi><mo stretchy="false">⌊</mo><mi>p</mi><mi mathvariant="normal">/</mi><mi>i</mi><mo stretchy="false">⌋</mo><mi mathvariant="normal">∗</mi><mo stretchy="false">(</mo><mi>p</mi><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>i</mi><msup><mo stretchy="false">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><mtext> </mtext><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i^{−1}≡−⌊p/i⌋∗(p\ mod\ i)^{-1}\ (mod\ p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.864108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mopen">⌊</span><span class="mord mathdefault">p</span><span class="mord">/</span><span class="mord mathdefault">i</span><span class="mclose">⌋</span><span class="mord">∗</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">i</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span></span></p><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> inv[<span class="number">3000500</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> p;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;p;</span><br><span class="line">cout&lt;&lt;inv[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">inv[i]=(p-p/i)*inv[p%i]%p;</span><br><span class="line"><span class="comment">//cout&lt;&lt;inv[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,inv[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅作为学习记录  欢迎指正.</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;乘法逆元求法小结&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#乘法逆元求法小结&quot;&gt;&lt;/a&gt; 乘法逆元求法小结&lt;/h3&gt;
&lt;h4 id=&quot;逆元的定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#逆元的定义&quot;&gt;&lt;/a&gt; 逆元的定义&lt;/h4&gt;
&lt;p&gt;对于整数a和p，如果a与p互质，我们定义x为a的逆元,计为&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;a^{-1}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8141079999999999em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.8141079999999999em;&quot;&gt;&lt;span style=&quot;top:-3.063em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mord mtight&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;,满足&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;≡&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mtext&gt; &lt;/mtext&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;a*x ≡ 1\ (mod \ p)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.46528em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;∗&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.46375em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;≡&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;mspace&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;mspace&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数论" scheme="https://luo41.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP一个小例子</title>
    <link href="https://luo41.top/2021/01/28/csapp%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>https://luo41.top/2021/01/28/csapp%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</id>
    <published>2021-01-28T08:09:51.000Z</published>
    <updated>2021-05-04T04:31:27.541Z</updated>
    
    <content type="html"><![CDATA[<p>标题党标题党</p><p>最近在CSAPP看到一个有趣的小例子  -1== 4294967295？</p><span id="more"></span><p>先上代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">-8</span>;</span><br><span class="line"><span class="keyword">int</span> y=<span class="number">7</span>;</span><br><span class="line"><span class="keyword">unsigned</span> ux=x;</span><br><span class="line"><span class="keyword">unsigned</span> uy=y;</span><br><span class="line">std::cout&lt;&lt;x+y&lt;&lt;std::endl;</span><br><span class="line">std::cout&lt;&lt;ux+uy&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br><span class="line">4294967295</span><br></pre></td></tr></table></figure><p>然后此时我们比较</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool judge=((x+y)==(ux+uy)?ture:false);</span><br><span class="line">std::cout&lt;&lt;judge&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure><p>-1==4294967295? 这肯定不相等啊</p><p>结果是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>查看一下两个数的二进制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cout&lt;&lt;<span class="string">&quot;二进制 &quot;</span>&lt;&lt;bitset&lt;32&gt;(x+y)&lt;&lt;std::endl;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;二进制 &quot;</span>&lt;&lt;bitset&lt;32&gt;(ux+uy)&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure><p>结果是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11111111111111111111111111111111</span><br><span class="line">11111111111111111111111111111111</span><br></pre></td></tr></table></figure><p>二进制表示完全相等，难道 == 符号比较两个数是否相等是比较他们的二进制表示是否完全相等？</p><p>不止是 == 符号 <strong>如果一个运算数是有符号的而另一个又是无符号的，C语言会隐式地将有符号参数强制类型转换为无符号数</strong>（好像大家都知道了）</p><p>＞符号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> u=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">bool</span> judge=((x&gt;u)?<span class="literal">true</span>:<span class="literal">false</span>);</span><br><span class="line">std::cout&lt;&lt;judge; </span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>结果为True,x处理为无符号数远大于2</p><p>结：<strong>补码和无符号加法有相同的位级行为，而且是可交换的</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;标题党标题党&lt;/p&gt;
&lt;p&gt;最近在CSAPP看到一个有趣的小例子  -1== 4294967295？&lt;/p&gt;</summary>
    
    
    
    
    <category term="CSAPP" scheme="https://luo41.top/tags/CSAPP/"/>
    
  </entry>
  
</feed>
